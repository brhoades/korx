diff -r 87f98d895296 -r 91f0a3d9f930 .hgtags
--- a/.hgtags	Sun Mar 29 01:15:08 2009 +0800
+++ b/.hgtags	Sat Jun 06 02:45:31 2009 +0800
@@ -5,3 +5,4 @@
 c9615b43aa75e07559c60c1b6a8f70b4e981cc9a 0.0.3
 766004a14b15a0c8c641b7decace3ad714a84dc3 0.9
 4135d88d07f11cc9e0527d4e6b1f389b8f4b961c 0.99
+87f98d895296ca5dd3f9570f799b4f2ffe0c5187 0.99
diff -r 87f98d895296 -r 91f0a3d9f930 Makefile
--- a/Makefile	Sun Mar 29 01:15:08 2009 +0800
+++ b/Makefile	Sat Jun 06 02:45:31 2009 +0800
@@ -24,9 +24,6 @@
 ifndef BUILD_CLIENT
   BUILD_CLIENT     = 1
 endif
-ifndef BUILD_CLIENT_SMP
-  BUILD_CLIENT_SMP = 1
-endif
 ifndef BUILD_CLIENT_TTY
   BUILD_CLIENT_TTY = 1
 endif
@@ -40,15 +37,6 @@
   BUILD_GAME_QVM   = 1
 endif
 
-# SMP only works on Mac, Linux and Windows
-ifneq ($(PLATFORM),darwin)
-ifneq ($(PLATFORM),mingw32)
-ifneq ($(PLATFORM),linux)
-  BUILD_CLIENT_SMP = 0
-endif
-endif
-endif
-
 #############################################################################
 #
 # If you require a different configuration from the defaults below, create a
@@ -95,10 +83,6 @@
   BUILD_DIR=build
 endif
 
-ifndef INSTALL_PREFIX
-  INSTALL_PREFIX = "/usr/local"
-endif
-
 ifndef GENERATE_DEPENDENCIES
   GENERATE_DEPENDENCIES=1
 endif
@@ -164,10 +148,6 @@
   USE_FREETYPE=1
 endif
 
-ifndef USE_OLD_HOMEPATH
-  USE_OLD_HOMEPATH=0
-endif
-
 ifndef USE_SSE
   ifeq ($(ARCH),x86_64)
     USE_SSE=2
@@ -221,7 +201,7 @@
 endif
 
 # version info
-VERSION_NUMBER=0.99
+VERSION_NUMBER=0.99r2
 
 ifeq ($(USE_SCM_VERSION),1)
   # For svn
@@ -265,6 +245,22 @@
 INSTALL=install
 MKDIR=mkdir
 
+ifndef BUILDROOT
+  BUILDROOT = ""
+endif
+ifndef INSTALL_PREFIX
+  INSTALL_PREFIX = "/usr/local"
+endif
+ifndef BINDIR
+  BINDIR = $(INSTALL_PREFIX)/bin
+endif
+ifndef LIBDIR
+  LIBDIR = $(INSTALL_PREFIX)/$(LIB)
+endif
+ifndef DATADIR
+  DATADIR = $(INSTALL_PREFIX)/share
+endif
+
 ifeq ($(PLATFORM),linux)
 
   ifeq ($(ARCH),alpha)
@@ -369,11 +365,10 @@
   SHLIBLDFLAGS=-shared $(LDFLAGS) --no-allow-shlib-undefined
 
   BASE_CFLAGS+=-I/usr/X11R6/include
-  THREAD_LDFLAGS=-L/usr/X11R6/$(LIB)
-  THREAD_LIBS=-lpthread -lX11
+  CLIENT_LDFLAGS=-L/usr/X11R6/$(LIB)
   LIBS=-ldl -lm
 
-  CLIENT_LIBS += $(shell sdl-config --libs) -lGL
+  CLIENT_LIBS += $(shell sdl-config --libs) -lGL -lpthread -lX11
 
   ifeq ($(USE_OPENAL),1)
     ifneq ($(USE_OPENAL_DLOPEN),1)
@@ -738,15 +733,14 @@
   SHLIBCFLAGS=-fPIC
   SHLIBLDFLAGS=-shared $(LDFLAGS) --no-allow-shlib-undefined
 
-  THREAD_LIBS=-lpthread
   # don't need -ldl (FreeBSD)
   LIBS+=-lm
 
-  CLIENT_LIBS += $(shell sdl-config --libs) -lGL
+  CLIENT_LIBS += $(shell sdl-config --libs) -lGL -lpthread
 
   ifeq ($(USE_OPENAL),1)
     ifneq ($(USE_OPENAL_DLOPEN),1)
-      CLIENT_LIBS += $(THREAD_LIBS) -lopenal
+      CLIENT_LIBS += -lopenal
     endif
   endif
 
@@ -762,8 +756,8 @@
 
 ifeq ($(PLATFORM),openbsd)
 
-  #default to i386, no tests done on anything else
-  ARCH=i386
+  #default to x86, no tests done on anything else
+  ARCH=x86
 
 
   BASE_CFLAGS = -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes \
@@ -798,14 +792,13 @@
   SHLIBCFLAGS=-fPIC
   SHLIBLDFLAGS=-shared $(LDFLAGS) --no-allow-shlib-undefined
 
-  THREAD_LIBS=-lpthread
   LIBS=-lm
 
-  CLIENT_LIBS = $(shell sdl-config --libs) -lGL
+  CLIENT_LIBS = $(shell sdl-config --libs) -lGL -lpthread
 
   ifeq ($(USE_OPENAL),1)
     ifneq ($(USE_OPENAL_DLOPEN),1)
-      CLIENT_LIBS += $(THREAD_LIBS) -lossaudio -lopenal
+      CLIENT_LIBS += -lossaudio -lopenal
     endif
   endif
 
@@ -821,15 +814,11 @@
 
 ifeq ($(PLATFORM),netbsd)
 
-  ifeq ($(shell uname -m),i386)
-    ARCH=x86
-  endif
-
   LIBS=-lm
   SHLIBEXT=so
   SHLIBCFLAGS=-fPIC
   SHLIBLDFLAGS=-shared $(LDFLAGS) --no-allow-shlib-undefined
-  THREAD_LIBS=-lpthread
+  CLIENT_LIBS=-lpthread
 
   BASE_CFLAGS = -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes
 
@@ -928,10 +917,9 @@
   SHLIBCFLAGS=-fPIC
   SHLIBLDFLAGS=-shared $(LDFLAGS) --no-allow-shlib-undefined
 
-  THREAD_LIBS=-lpthread
   LIBS=-lsocket -lnsl -ldl -lm
 
-  CLIENT_LIBS +=$(shell sdl-config --libs) -lGL
+  CLIENT_LIBS +=$(shell sdl-config --libs) -lGL -lpthread
 
 else # ifeq sunos
 
@@ -958,18 +946,15 @@
 TARGETS =
 
 ifneq ($(BUILD_SERVER),0)
-  TARGETS += $(B)/tremfusionded.$(ARCH)$(BINEXT)
+  TARGETS += $(B)/tremded.$(ARCH)$(BINEXT)
 endif
 
 ifneq ($(BUILD_CLIENT),0)
-  TARGETS += $(B)/tremfusion.$(ARCH)$(BINEXT)
-  ifneq ($(BUILD_CLIENT_SMP),0)
-    TARGETS += $(B)/tremfusion-smp.$(ARCH)$(BINEXT)
-  endif
+  TARGETS += $(B)/tremulous.$(ARCH)$(BINEXT)
 endif
 
 ifneq ($(BUILD_CLIENT_TTY),0)
-  TARGETS += $(B)/tremfusion-tty.$(ARCH)$(BINEXT)
+  TARGETS += $(B)/tremulous-tty.$(ARCH)$(BINEXT)
 endif
 
 ifneq ($(BUILD_GAME_SO),0)
@@ -1024,7 +1009,6 @@
 endif
 
 BASE_CFLAGS += -DPRODUCT_VERSION=\\\"$(VERSION)\\\"
-BASE_CFLAGS += -DUSE_OLD_HOMEPATH=$(USE_OLD_HOMEPATH)
 
 ifeq ($(V),1)
   echo_cmd=@:
@@ -1039,11 +1023,6 @@
 $(Q)$(CC) $(NOTSHLIBCFLAGS) $(CFLAGS) -o $@ -c $<
 endef
 
-define DO_SMP_CC
-$(echo_cmd) "SMP_CC $<"
-$(Q)$(CC) $(NOTSHLIBCFLAGS) $(CFLAGS) -DSMP -o $@ -c $<
-endef
-
 define DO_TTY_CC
 $(echo_cmd) "TTY_CC $<"
 $(Q)$(CC) $(NOTSHLIBCFLAGS) $(CFLAGS) $(TTYC_CFLAGS) -DBUILD_TTY_CLIENT -o $@ -c $<
@@ -1158,7 +1137,6 @@
 	@if [ ! -d $(BUILD_DIR) ];then $(MKDIR) $(BUILD_DIR);fi
 	@if [ ! -d $(B) ];then $(MKDIR) $(B);fi
 	@if [ ! -d $(B)/client ];then $(MKDIR) $(B)/client;fi
-	@if [ ! -d $(B)/clientsmp ];then $(MKDIR) $(B)/clientsmp;fi
 	@if [ ! -d $(B)/clienttty ];then $(MKDIR) $(B)/clienttty;fi
 	@if [ ! -d $(B)/ded ];then $(MKDIR) $(B)/ded;fi
 	@if [ ! -d $(B)/base ];then $(MKDIR) $(B)/base;fi
@@ -1174,22 +1152,6 @@
 	@if [ ! -d $(B)/tools/lburg ];then $(MKDIR) $(B)/tools/lburg;fi
 
 #############################################################################
-# INSTALL
-#############################################################################
-
-install: release
-	@echo ""
-	@echo "Installing TremFusion in $(INSTALL_PREFIX):"
-	@if [ ! -d $(INSTALL_PREFIX) ];then $(MKDIR) $(INSTALL_PREFIX);fi
-	@if [ ! -d $(INSTALL_PREFIX)/lib ];then $(MKDIR) $(INSTALL_PREFIX)/lib;fi
-	@if [ ! -d $(INSTALL_PREFIX)/share ];then $(MKDIR) $(INSTALL_PREFIX)/share;fi
-	@if [ ! -d $(INSTALL_PREFIX)/lib/tremfusion ];then $(MKDIR) $(INSTALL_PREFIX)/lib/tremfusion;fi
-	@if [ ! -d $(INSTALL_PREFIX)/share/tremfusion ];then $(MKDIR) $(INSTALL_PREFIX)/share/tremfusion;fi
-	@$(Q)$(INSTALL) -v $(BR)/tremfusion.$(ARCH)$(BINEXT) $(INSTALL_PREFIX)/lib/tremfusion/tremfusion
-	@$(Q)$(INSTALL) -v misc/transfer_settings.sh $(INSTALL_PREFIX)/share/tremfusion/transfer_settings.sh
-
-
-#############################################################################
 # QVM BUILD TOOLS
 #############################################################################
 
@@ -1465,7 +1427,8 @@
   \
   $(B)/client/sdl_gamma.o \
   $(B)/client/sdl_input.o \
-  $(B)/client/sdl_snd.o
+  $(B)/client/sdl_snd.o \
+  $(B)/client/sdl_glimp.o
 
 Q3TOBJ += \
   $(B)/clienttty/null_input.o \
@@ -1573,28 +1536,16 @@
     $(B)/client/libmumblelink.o
 endif
 
-Q3POBJ = \
-  $(B)/client/sdl_glimp.o
-
-Q3POBJ_SMP = \
-  $(B)/clientsmp/sdl_glimp.o
-
 Q3TOBJ += $(subst /client/,/clienttty/,$(Q3OBJ_))
 Q3OBJ += $(Q3OBJ_)
 
-$(B)/tremfusion.$(ARCH)$(BINEXT): $(Q3OBJ) $(Q3POBJ) $(LIBSDLMAIN) $(LIBOGG) $(LIBVORBIS) $(LIBVORBISFILE) $(LIBFREETYPE)
+$(B)/tremulous.$(ARCH)$(BINEXT): $(Q3OBJ) $(LIBSDLMAIN) $(LIBOGG) $(LIBVORBIS) $(LIBVORBISFILE) $(LIBFREETYPE)
 	$(echo_cmd) "LD $@"
 	$(Q)$(CC) $(CLIENT_CFLAGS) $(CFLAGS) $(CLIENT_LDFLAGS) $(LDFLAGS) \
-	    -o $@ $(Q3OBJ) $(Q3POBJ) $(CLIENT_LIBS) $(LIBS) \
+	    -o $@ $(Q3OBJ) $(CLIENT_LIBS) $(LIBS) \
         $(LIBSDLMAIN) $(LIBVORBISFILE) $(LIBVORBIS) $(LIBOGG) $(LIBFREETYPE)
 
-$(B)/tremfusion-smp.$(ARCH)$(BINEXT): $(Q3OBJ) $(Q3POBJ_SMP) $(LIBSDLMAIN) $(LIBOGG) $(LIBVORBIS) $(LIBVORBISFILE) $(LIBFREETYPE)
-	$(echo_cmd) "LD $@"
-	$(Q)$(CC) $(CLIENT_CFLAGS) $(CFLAGS) $(CLIENT_LDFLAGS) $(LDFLAGS) $(THREAD_LDFLAGS) \
-       -o $@ $(Q3OBJ) $(Q3POBJ_SMP) $(CLIENT_LIBS) $(LIBS) $(THREAD_LIBS) \
-        $(LIBSDLMAIN) $(LIBVORBISFILE) $(LIBVORBIS) $(LIBOGG) $(LIBFREETYPE)
-
-$(B)/tremfusion-tty.$(ARCH)$(BINEXT): $(Q3TOBJ)
+$(B)/tremulous-tty.$(ARCH)$(BINEXT): $(Q3TOBJ)
 	$(echo_cmd) "LD $@"
 	$(Q)$(CC) $(CFLAGS) $(TTYC_CFLAGS) $(TTYC_LDFLAGS) $(LDFLAGS) \
 	    -o $@ $(Q3TOBJ) $(TTYC_LIBS) $(LIBS)
@@ -1735,7 +1686,7 @@
     $(B)/ded/con_tty.o
 endif
 
-$(B)/tremfusionded.$(ARCH)$(BINEXT): $(Q3DOBJ)
+$(B)/tremded.$(ARCH)$(BINEXT): $(Q3DOBJ)
 	$(echo_cmd) "LD $@"
 	$(Q)$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(Q3DOBJ) $(LIBS)
 
@@ -1901,9 +1852,6 @@
 $(B)/client/%.o: $(SDLDIR)/%.c
 	$(DO_CC)
 
-$(B)/clientsmp/%.o: $(SDLDIR)/%.c
-	$(DO_SMP_CC)
-
 $(B)/client/%.o: $(SYSDIR)/%.c
 	$(DO_CC)
 
@@ -2027,7 +1975,7 @@
 # MISC
 #############################################################################
 
-OBJ = $(Q3OBJ) $(Q3POBJ) $(Q3POBJ_SMP) $(Q3TOBJ) $(Q3DOBJ) \
+OBJ = $(Q3OBJ) $(Q3TOBJ) $(Q3DOBJ) \
   $(GOBJ) $(CGOBJ) $(UIOBJ) \
   $(GVMOBJ) $(CGVMOBJ) $(UIVMOBJ)
 TOOLSOBJ = $(LBURGOBJ) $(Q3RCCOBJ) $(Q3LCCOBJ) $(Q3ASMOBJ)
diff -r 87f98d895296 -r 91f0a3d9f930 make-macosx-ub.sh
--- a/make-macosx-ub.sh	Sun Mar 29 01:15:08 2009 +0800
+++ b/make-macosx-ub.sh	Sat Jun 06 02:45:31 2009 +0800
@@ -1,19 +1,24 @@
 #!/bin/sh
-APPBUNDLE=Tremfusion.app
-BINARY=Tremfusion
-DEDBIN=Tremfusionded
-PKGINFO=APPLTREMFUSION
+APPBUNDLE=Tremulous.app
+BINARY=Tremulous.ub
+DEDBIN=Tremded.ub
+TTYBIN=Tremulous-tty.ub
+PKGINFO=APPLTREM
 ICNS=misc/Tremfusion.icns
 DESTDIR=build/release-darwin-ub
 BASEDIR=base
 
 BIN_OBJ="
-	build/release-darwin-ppc/tremfusion-smp.ppc
-	build/release-darwin-x86/tremfusion-smp.x86
+	build/release-darwin-ppc/tremulous.ppc
+	build/release-darwin-x86/tremulous.x86
 "
 BIN_DEDOBJ="
-	build/release-darwin-ppc/tremfusionded.ppc
-	build/release-darwin-x86/tremfusionded.x86
+	build/release-darwin-ppc/tremded.ppc
+	build/release-darwin-x86/tremded.x86
+"
+BIN_TTYOBJ="
+	build/release-darwin-ppc/tremulous-tty.ppc
+	build/release-darwin-x86/tremulous-tty.x86
 "
 
 cd `dirname $0`
@@ -113,12 +118,13 @@
 
 # ppc client and server
 (ARCH=ppc USE_OPENAL_DLOPEN=1 CC=$PPC_CC CFLAGS=$PPC_CFLAGS \
-	LDFLAGS=$PPC_LDFLAGS make -j$NCPU BUILD_CLIENT_SMP=1 BUILD_GAME_SO=0 \
-	BUILD_GAME_QVM=0 $*) || exit 1;
+	LDFLAGS=$PPC_LDFLAGS make -j$NCPU BUILD_CLIENT=1 BUILD_GAME_SO=0 \
+	BUILD_GAME_QVM=0 BUILD_SERVER=1 BUILD_CLIENT_TTY=1 $*) || exit 1;
 
 # intel client and server
 (ARCH=x86 CFLAGS=$X86_CFLAGS LDFLAGS=$X86_LDFLAGS make -j$NCPU \
-	BUILD_CLIENT_SMP=1 BUILD_GAME_SO=0 BUILD_GAME_QVM=0 $*) || exit 1;
+	BUILD_CLIENT=1 BUILD_GAME_SO=0 BUILD_GAME_QVM=0 \
+	BUILD_SERVER=1 BUILD_CLIENT_TTY=1 $*) || exit 1;
 
 echo "Creating .app bundle $DESTDIR/$APPBUNDLE"
 if [ ! -d $DESTDIR/$APPBUNDLE/Contents/MacOS/$BASEDIR ]; then
@@ -148,11 +154,11 @@
 		<key>CFBundleIconFile</key>
 		<string>Tremfusion.icns</string>
 		<key>CFBundleIdentifier</key>
-		<string>net.tremfusion</string>
+		<string>net.tremulous</string>
 		<key>CFBundleInfoDictionaryVersion</key>
 		<string>6.0</string>
 		<key>CFBundleName</key>
-		<string>Tremfusion</string>
+		<string>Tremulous</string>
 		<key>CFBundlePackageType</key>
 		<string>APPL</string>
 		<key>CFBundleShortVersionString</key>
@@ -171,4 +177,5 @@
 
 lipo -create -o $DESTDIR/$APPBUNDLE/Contents/MacOS/$BINARY $BIN_OBJ
 lipo -create -o $DESTDIR/$DEDBIN $BIN_DEDOBJ
+lipo -create -o $DESTDIR/$TTYBIN $BIN_TTYOBJ
 cp src/libs/macosx/*.dylib $DESTDIR/$APPBUNDLE/Contents/MacOS/
diff -r 87f98d895296 -r 91f0a3d9f930 misc/merge-ioq3-into-trem.sh
--- a/misc/merge-ioq3-into-trem.sh	Sun Mar 29 01:15:08 2009 +0800
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,42 +0,0 @@
-#! /bin/sh
-
-cd /tmp
-
-# Make sure previous copies are gone
-rm -rf quake3/
-
-# Checkout a new copy of ioq3
-svn co svn://svn.icculus.org/quake3/trunk/ quake3
-cd quake3/
-
-IOQ3REVISION=`svnversion .`
-IOQ3VERSION=ioq3-r$IOQ3REVISION
-
-rm -rf $IOQ3VERSION
-svn export . $IOQ3VERSION
-cd $IOQ3VERSION
-
-# Remove READMEs and the like
-rm -rf BUGS ChangeLog README COPYING.txt NOTTODO TODO id-readme.txt misc/
-
-# Remove Q3 ui stuff
-rm -rf ui/
-
-# Remove Windows/VC related stuff
-rm -f `find -iname "*.bat"`
-rm -f `find -iname "*.lnt"`
-rm -f `find -iname "*.sln"`
-rm -f `find -iname "*.vcproj"`
-rm -f `find -iname "*.def"`
-rm -f `find -iname "*.q3asm"`
-rm -f `find -iname "*.mak"`
-rm -f `find -iname "*.ico"`
-rm -f `find -iname "*.bmp"`
-
-# Remove game code
-rm -rf code/cgame/ code/game/ code/ui/ code/q3_ui/
-
-mv code src
-
-cd ..
-svn_load_dirs svn://svn.icculus.org/tremulous/ -t upstream/$IOQ3VERSION upstream/current $IOQ3VERSION/
diff -r 87f98d895296 -r 91f0a3d9f930 misc/run-tremfusion.sh.in
--- a/misc/run-tremfusion.sh.in	Sun Mar 29 01:15:08 2009 +0800
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,37 +0,0 @@
-#!/bin/bash
-
-BINARY=@INSTALL_PREFIX@/lib/tremfusion/$(basename $0)
-BASE_PATH="/usr/share/tremulous"
-EXTRA_PATH="@INSTALL_PREFIX@/share/tremfusion"
-QUIET=0
-
-# Transfer settings if necessary
-
-if [ -d $HOME/.tremfusion ]; then
-	exec @INSTALL_PREFIX@/share/tremfusion/transfer_settings.sh >/dev/null 2>&1 || :
-fi
-
-# TremFusion binaries don't understand "regular" command line parameters. Let's
-# catch them here, to avoid accidently launching the binary.
-
-while [ "$1" != "" ]; do {
-	if [ "$1" = "+set" -o "$1" = "+connect" ]; then
-		break;
-	fi
-	case "$1" in
-		-q|--quiet)
-			QUIET=1
-			;;
-	esac
-	shift
-}; done
-
-# Ready to rumble!
-
-if [ ${QUIET} -eq 1 ]; then
-	exec ${BINARY} +set fs_basepath ${BASE_PATH} +set fs_extrapath ${EXTRA_PATH} +set fs_extrapaks z-tremfusion-menus-0.99 $* >/dev/null 2>&1
-else
-	exec ${BINARY} +set fs_basepath ${BASE_PATH} +set fs_extrapath ${EXTRA_PATH} +set fs_extrapaks z-tremfusion-menus-0.99 $*
-fi
-
-exit $?
diff -r 87f98d895296 -r 91f0a3d9f930 misc/sdl-win32-fixes.diff
--- a/misc/sdl-win32-fixes.diff	Sun Mar 29 01:15:08 2009 +0800
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,608 +0,0 @@
-Index: src/video/wincommon/SDL_lowvideo.h
-===================================================================
---- src/video/wincommon/SDL_lowvideo.h	(revision 4474)
-+++ src/video/wincommon/SDL_lowvideo.h	(working copy)
-@@ -51,10 +51,13 @@
- /* Hidden "this" pointer for the video functions */
- #define _THIS	SDL_VideoDevice *this
- 
-+#define FULLSCREEN() \
-+	((SDL_VideoSurface->flags & SDL_FULLSCREEN) == SDL_FULLSCREEN)
-+
- #define WINDIB_FULLSCREEN()						\
- (									\
- 	SDL_VideoSurface &&						\
--	((SDL_VideoSurface->flags & SDL_FULLSCREEN) == SDL_FULLSCREEN) && \
-+	FULLSCREEN() && \
- 	(((SDL_VideoSurface->flags & SDL_OPENGL   ) == SDL_OPENGL    ) || \
- 	((SDL_strcmp(this->name, "windib") == 0) || \
- 	 (SDL_strcmp(this->name, "gapi") == 0))) \
-@@ -62,13 +65,19 @@
- #define DDRAW_FULLSCREEN() 						\
- (									\
- 	SDL_VideoSurface &&						\
--	((SDL_VideoSurface->flags & SDL_FULLSCREEN) == SDL_FULLSCREEN) && \
-+	FULLSCREEN() && \
- 	((SDL_VideoSurface->flags & SDL_OPENGL    ) != SDL_OPENGL    ) && \
- 	(SDL_strcmp(this->name, "directx") == 0)				\
- )
- 
--#define DINPUT_FULLSCREEN()	DDRAW_FULLSCREEN()
-+#define DINPUT_FULLSCREEN() 						\
-+(									\
-+	FULLSCREEN() && \
-+	(strcmp(this->name, "directx") == 0)				\
-+)
- 
-+#define DINPUT() (strcmp(this->name, "directx") == 0)
-+
- /* The main window -- and a function to set it for the audio */
- #ifdef _WIN32_WCE
- extern LPWSTR SDL_Appname;
-Index: src/video/wincommon/SDL_sysevents.c
-===================================================================
---- src/video/wincommon/SDL_sysevents.c	(revision 4474)
-+++ src/video/wincommon/SDL_sysevents.c	(working copy)
-@@ -363,7 +363,6 @@
- {
- 	SDL_VideoDevice *this = current_video;
- 	static int mouse_pressed = 0;
--	static int in_window = 0;
- #ifdef WMMSG_DEBUG
- 	fprintf(stderr, "Received windows message:  ");
- 	if ( msg > MAX_WMMSG ) {
-@@ -439,62 +438,40 @@
- 		break;
- 
- 		case WM_MOUSEMOVE: {
--			
--			/* Mouse is handled by DirectInput when fullscreen */
--			if ( SDL_VideoSurface && ! DINPUT_FULLSCREEN() ) {
--				Sint16 x, y;
--
--				/* mouse has entered the window */
--				if ( ! in_window ) {
- #ifdef WM_MOUSELEAVE
-+			/* No need to handle SDL_APPMOUSEFOCUS when fullscreen */
-+			if ( SDL_VideoSurface && !FULLSCREEN() ) {
-+				/* mouse has entered the window */
-+
-+				if ( !(SDL_GetAppState() & SDL_APPMOUSEFOCUS) ) {
- 					TRACKMOUSEEVENT tme;
- 
- 					tme.cbSize = sizeof(tme);
- 					tme.dwFlags = TME_LEAVE;
- 					tme.hwndTrack = SDL_Window;
- 					_TrackMouseEvent(&tme);
-+				}
-+			}
- #endif /* WM_MOUSELEAVE */
--					in_window = TRUE;
- 
--					posted = SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
--				}
-+			/* Mouse motion is handled in DIB_PumpEvents or
-+			 * DX5_PumpEvents, depending on the video driver
-+			 * in use */
- 
--				/* mouse has moved within the window */
--				x = LOWORD(lParam);
--				y = HIWORD(lParam);
--				if ( mouse_relative ) {
--					POINT center;
--					center.x = (SDL_VideoSurface->w/2);
--					center.y = (SDL_VideoSurface->h/2);
--					x -= (Sint16)center.x;
--					y -= (Sint16)center.y;
--					if ( x || y ) {
--						ClientToScreen(SDL_Window, &center);
--						SetCursorPos(center.x, center.y);
--						posted = SDL_PrivateMouseMotion(0, 1, x, y);
--					}
--				} else {
--#ifdef SDL_VIDEO_DRIVER_GAPI
--					if (SDL_VideoSurface && this->hidden->gapiInfo)
--						GapiTransform(this->hidden->gapiInfo->coordinateTransform, this->hidden->gapiInfo->hiresFix, &x, &y);
--#endif
--					posted = SDL_PrivateMouseMotion(0, 0, x, y);
--				}
--			}
-+			posted = SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
- 		}
- 		return(0);
- 
- #ifdef WM_MOUSELEAVE
- 		case WM_MOUSELEAVE: {
- 
--			/* Mouse is handled by DirectInput when fullscreen */
--			if ( SDL_VideoSurface && ! DINPUT_FULLSCREEN() ) {
-+			/* No need to handle SDL_APPMOUSEFOCUS when fullscreen */
-+			if ( SDL_VideoSurface && !FULLSCREEN() ) {
- 				/* mouse has left the window */
- 				/* or */
- 				/* Elvis has left the building! */
- 				posted = SDL_PrivateAppActive(0, SDL_APPMOUSEFOCUS);
- 			}
--			in_window = FALSE;
- 		}
- 		return(0);
- #endif /* WM_MOUSELEAVE */
-@@ -508,7 +485,7 @@
- 		case WM_XBUTTONDOWN:
- 		case WM_XBUTTONUP: {
- 			/* Mouse is handled by DirectInput when fullscreen */
--			if ( SDL_VideoSurface && ! DINPUT_FULLSCREEN() ) {
-+			if ( SDL_VideoSurface && ! DINPUT() ) {
- 				WORD xbuttonval = 0;
- 				Sint16 x, y;
- 				Uint8 button, state;
-@@ -572,20 +549,8 @@
- 						mouse_pressed = 0;
- 					}
- 				}
--				if ( mouse_relative ) {
--				/*	RJR: March 28, 2000
--					report internal mouse position if in relative mode */
--					x = 0; y = 0;
--				} else {
--					x = (Sint16)LOWORD(lParam);
--					y = (Sint16)HIWORD(lParam);
--#ifdef SDL_VIDEO_DRIVER_GAPI
--					if (SDL_VideoSurface && this->hidden->gapiInfo)
--						GapiTransform(this->hidden->gapiInfo->coordinateTransform, this->hidden->gapiInfo->hiresFix, &x, &y);
--#endif
--				}
- 				posted = SDL_PrivateMouseButton(
--							state, button, x, y);
-+							state, button, 0, 0);
- 
- 				/*
- 				 * MSDN says:
-@@ -606,7 +571,7 @@
- 
- #if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
- 		case WM_MOUSEWHEEL: 
--			if ( SDL_VideoSurface && ! DINPUT_FULLSCREEN() ) {
-+			if ( SDL_VideoSurface && ! DINPUT() ) {
- 				int move = (short)HIWORD(wParam);
- 				if ( move ) {
- 					Uint8 button;
-Index: src/video/wincommon/SDL_sysmouse.c
-===================================================================
---- src/video/wincommon/SDL_sysmouse.c	(revision 4474)
-+++ src/video/wincommon/SDL_sysmouse.c	(working copy)
-@@ -188,8 +188,7 @@
- {
- 	POINT mouse_pos;
- 
--	/* The fullscreen cursor must be done in software with DirectInput */
--	if ( !this->screen || DDRAW_FULLSCREEN() ) {
-+	if ( !this->screen ) {
- 		return(0);
- 	}
- 
-@@ -208,15 +207,20 @@
- 
- void WIN_WarpWMCursor(_THIS, Uint16 x, Uint16 y)
- {
--	if ( DDRAW_FULLSCREEN() ) {
--		SDL_PrivateMouseMotion(0, 0, x, y);
--	} else if ( mouse_relative) {
-+	if ( mouse_relative) {
- 		/*	RJR: March 28, 2000
- 			leave physical cursor at center of screen if
- 			mouse hidden and grabbed */
- 		SDL_PrivateMouseMotion(0, 0, x, y);
- 	} else {
- 		POINT pt;
-+
-+		/* With DirectInput the position doesn't follow
-+		 * the cursor, so it is set manually */
-+		if ( DINPUT() ) {
-+			SDL_PrivateMouseMotion(0, 0, x, y);
-+		}
-+
- 		pt.x = x;
- 		pt.y = y;
- 		ClientToScreen(SDL_Window, &pt);
-@@ -227,20 +231,15 @@
- /* Update the current mouse state and position */
- void WIN_UpdateMouse(_THIS)
- {
--	RECT rect;
- 	POINT pt;
- 
--	if ( ! DDRAW_FULLSCREEN() ) {
--		GetClientRect(SDL_Window, &rect);
--		GetCursorPos(&pt);
--		MapWindowPoints(NULL, SDL_Window, &pt, 1);
--		if (PtInRect(&rect, pt) && (WindowFromPoint(pt) == SDL_Window)){
--			SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
--			SDL_PrivateMouseMotion(0,0, (Sint16)pt.x, (Sint16)pt.y);
--		} else {
--			SDL_PrivateAppActive(0, SDL_APPMOUSEFOCUS);
--		}
--	}
-+	/* Always unset SDL_APPMOUSEFOCUS to give the WM_MOUSEMOVE event
-+	 * handler a chance to install a TRACKMOUSEEVENT */
-+	SDL_PrivateAppActive(0, SDL_APPMOUSEFOCUS);
-+
-+	GetCursorPos(&pt);
-+	ScreenToClient(SDL_Window, &pt);
-+	SDL_PrivateMouseMotion(0,0, (Sint16)pt.x, (Sint16)pt.y);
- }
- 
- /* Check to see if we need to enter or leave mouse relative mode */
-Index: src/video/windib/SDL_dibevents.c
-===================================================================
---- src/video/windib/SDL_dibevents.c	(revision 4474)
-+++ src/video/windib/SDL_dibevents.c	(working copy)
-@@ -271,6 +271,36 @@
- 	return(DefWindowProc(hwnd, msg, wParam, lParam));
- }
- 
-+static void DIB_GenerateMouseMotionEvent(void)
-+{
-+	extern int mouse_relative;
-+	extern int posted;
-+
-+	POINT mouse;
-+	GetCursorPos( &mouse );
-+
-+	if ( mouse_relative ) {
-+		POINT center;
-+		center.x = (SDL_VideoSurface->w/2);
-+		center.y = (SDL_VideoSurface->h/2);
-+		ClientToScreen(SDL_Window, &center);
-+
-+		mouse.x -= (Sint16)center.x;
-+		mouse.y -= (Sint16)center.y;
-+		if ( mouse.x || mouse.y ) {
-+			SetCursorPos(center.x, center.y);
-+			posted = SDL_PrivateMouseMotion(0, 1, mouse.x, mouse.y);
-+		}
-+	} else if ( SDL_GetAppState() & SDL_APPMOUSEFOCUS ) {
-+		ScreenToClient(SDL_Window, &mouse);
-+#ifdef _WIN32_WCE
-+		if (SDL_VideoSurface)
-+			GapiTransform(this->hidden->userOrientation, this->hidden->hiresFix, &mouse.x, &mouse.y);
-+#endif
-+		posted = SDL_PrivateMouseMotion(0, 0, mouse.x, mouse.y);
-+	}
-+}
-+
- void DIB_PumpEvents(_THIS)
- {
- 	MSG msg;
-@@ -280,6 +310,10 @@
- 			DispatchMessage(&msg);
- 		}
- 	}
-+
-+	if ( SDL_GetAppState() & SDL_APPINPUTFOCUS ) {
-+		DIB_GenerateMouseMotionEvent( );
-+	}
- }
- 
- static HKL hLayoutUS = NULL;
-@@ -518,8 +552,13 @@
- 		Uint16	wchars[2];
- 
- 		GetKeyboardState(keystate);
--		if (SDL_ToUnicode((UINT)vkey, scancode, keystate, wchars, sizeof(wchars)/sizeof(wchars[0]), 0) == 1)
-+		/* Numlock isn't taken into account in ToUnicode, so we catch that case here */
-+		if ((keystate[VK_NUMLOCK] & 1) && vkey >= VK_NUMPAD0 && vkey <= VK_NUMPAD9)
- 		{
-+			keysym->sym = keysym->unicode = vkey - VK_NUMPAD0 + '0';
-+		}
-+		else if (SDL_ToUnicode((UINT)vkey, scancode, keystate, wchars, sizeof(wchars)/sizeof(wchars[0]), 0) > 0)
-+		{
- 			keysym->unicode = wchars[0];
- 		}
- #endif /* NO_GETKEYBOARDSTATE */
-Index: src/video/windx5/SDL_dx5events.c
-===================================================================
---- src/video/windx5/SDL_dx5events.c	(revision 4474)
-+++ src/video/windx5/SDL_dx5events.c	(working copy)
-@@ -143,9 +143,14 @@
- 		(DISCL_FOREGROUND|DISCL_NONEXCLUSIVE),
- 		(DISCL_FOREGROUND|DISCL_NONEXCLUSIVE), handle_keyboard },
- 	{ "mouse",
--		&GUID_SysMouse, &c_dfDIMouse,
-+		&GUID_SysMouse,
-+#if DIRECTINPUT_VERSION >= 0x700
-+		&c_dfDIMouse2,
-+#else
-+		&c_dfDIMouse,
-+#endif
- 		(DISCL_FOREGROUND|DISCL_NONEXCLUSIVE),
--		(DISCL_FOREGROUND|DISCL_EXCLUSIVE), handle_mouse },
-+		(DISCL_FOREGROUND|DISCL_NONEXCLUSIVE), handle_mouse },
- 	{ NULL, NULL, NULL, 0, 0, NULL }
- };
- 	
-@@ -285,6 +290,76 @@
- 		}
- 	}
- }
-+
-+static void post_mouse_motion(int relative, Sint16 x, Sint16 y)
-+{
-+	extern int mouse_relative;
-+
-+	if ( SDL_GetAppState() & (SDL_APPINPUTFOCUS|SDL_APPMOUSEFOCUS) ==
-+		(SDL_APPINPUTFOCUS|SDL_APPMOUSEFOCUS) ) {
-+		posted = SDL_PrivateMouseMotion(
-+			0, relative, x, y);
-+
-+		if ( !mouse_relative ) {
-+			/* As DirectInput reads raw device coordinates, it has no notion of
-+			 * cursors or absolute position. We must assume responsibility for
-+			 * keeping track of this. */
-+			int current_x, current_y;
-+			POINT cursor;
-+			RECT trap;
-+			RECT window;
-+			int at_edge;
-+
-+			/* Get the current cursor position */
-+			SDL_GetMouseState(&current_x, &current_y);
-+			cursor.x = current_x;
-+			cursor.y = current_y;
-+			ClientToScreen(SDL_Window, &cursor);
-+
-+			/* Construct a 1 pixel square RECT that is used to confine the cursor
-+			 * pointer to a specific pixel using ClipCursor. This is used in
-+			 * preference to SetCursorPos as it avoids the cursor jumping around as
-+			 * both the OS and SDL attempt to move it simultaneously. */
-+			trap.left = cursor.x;
-+			trap.top = cursor.y;
-+			trap.right = cursor.x + 1;
-+			trap.bottom = cursor.y + 1;
-+
-+			GetClientRect(SDL_Window, &window);
-+			window.right -= window.left; window.left = 0;
-+			window.bottom -= window.top; window.top = 0;
-+
-+			/* As we're assuming control over the cursor, we need to know when to
-+			 * relinquish control of it back to the operating system. This is when
-+			 * the cursor reaches the edge of the window. */
-+			at_edge = (current_x == window.left) ||
-+				(current_x == (window.right - 1)) ||
-+				(current_y == window.top) ||
-+				(current_y == (window.bottom - 1));
-+
-+			if ( at_edge ) {
-+				ClipCursor(NULL);
-+			} else {
-+				ClipCursor(&trap);
-+			}
-+		} else {
-+			/* When in relative mode, warp the OS's idea of where the cursor is to
-+			 * the center of the screen. This isn't really necessary as DirectInput
-+			 * reads from the hardware itself, but in case things go wrong, the
-+			 * cursor will be left in a sensible place. */
-+			POINT center;
-+			center.x = (SDL_VideoSurface->w/2);
-+			center.y = (SDL_VideoSurface->h/2);
-+			ClientToScreen(SDL_Window, &center);
-+			SetCursorPos(center.x, center.y);
-+		}
-+	} else {
-+		/* No window or mouse focus, control is lost */
-+		mouse_lost = 1;
-+		ClipCursor(NULL);
-+	}
-+}
-+
- static void handle_mouse(const int numevents, DIDEVICEOBJECTDATA *ptrbuf)
- {
- 	int i;
-@@ -298,14 +373,8 @@
- 		return;
- 	}
- 
--	/* If we are in windowed mode, Windows is taking care of the mouse */
--	if (  (SDL_PublicSurface->flags & SDL_OPENGL) ||
--	     !(SDL_PublicSurface->flags & SDL_FULLSCREEN) ) {
--		return;
--	}
--
- 	/* If the mouse was lost, regain some sense of mouse state */
--	if ( mouse_lost ) {
-+	if ( mouse_lost && (SDL_GetAppState() & SDL_APPMOUSEFOCUS) ) {
- 		POINT mouse_pos;
- 		Uint8 old_state;
- 		Uint8 new_state;
-@@ -313,14 +382,17 @@
- 		/* Set ourselves up with the current cursor position */
- 		GetCursorPos(&mouse_pos);
- 		ScreenToClient(SDL_Window, &mouse_pos);
--		posted = SDL_PrivateMouseMotion(0, 0,
--				(Sint16)mouse_pos.x, (Sint16)mouse_pos.y);
-+		post_mouse_motion( 0, (Sint16)mouse_pos.x, (Sint16)mouse_pos.y);
- 
- 		/* Check for mouse button changes */
- 		old_state = SDL_GetMouseState(NULL, NULL);
- 		new_state = 0;
- 		{ /* Get the new DirectInput button state for the mouse */
-+#if DIRECTINPUT_VERSION >= 0x700
-+			DIMOUSESTATE2 distate;
-+#else
- 			DIMOUSESTATE distate;
-+#endif
- 			HRESULT result;
- 
- 			result=IDirectInputDevice2_GetDeviceState(SDL_DIdev[1],
-@@ -341,14 +413,13 @@
- 		for ( i=0; i<8; ++i ) {
- 			if ( (old_state&0x01) != (new_state&0x01) ) {
- 				button = (Uint8)(i+1);
--				/* Button #2 on two button mice is button 3
--				   (the middle button is button 2)
--				 */
--				if ( button == 2 ) {
--					button = 3;
--				} else
--				if ( button == 3 ) {
--					button = 2;
-+				/* Map DI button numbers to SDL */
-+				switch ( button ) {
-+					case 2: button = SDL_BUTTON_RIGHT; break;
-+					case 3: button = SDL_BUTTON_MIDDLE; break;
-+					case 4: button = SDL_BUTTON_X1; break;
-+					case 5: button = SDL_BUTTON_X2; break;
-+					default: break;
- 				}
- 				if ( new_state & 0x01 ) {
- 					/* Grab mouse so we get mouse-up */
-@@ -387,8 +458,7 @@
- 			case DIMOFS_X:
- 				if ( timestamp != ptrbuf[i].dwTimeStamp ) {
- 					if ( xrel || yrel ) {
--						posted = SDL_PrivateMouseMotion(
--								0, 1, xrel, yrel);
-+						post_mouse_motion(1, xrel, yrel);
- 						xrel = 0;
- 						yrel = 0;
- 					}
-@@ -399,8 +469,7 @@
- 			case DIMOFS_Y:
- 				if ( timestamp != ptrbuf[i].dwTimeStamp ) {
- 					if ( xrel || yrel ) {
--						posted = SDL_PrivateMouseMotion(
--								0, 1, xrel, yrel);
-+						post_mouse_motion(1, xrel, yrel);
- 						xrel = 0;
- 						yrel = 0;
- 					}
-@@ -410,8 +479,7 @@
- 				break;
- 			case DIMOFS_Z:
- 				if ( xrel || yrel ) {
--					posted = SDL_PrivateMouseMotion(
--							0, 1, xrel, yrel);
-+					post_mouse_motion(1, xrel, yrel);
- 					xrel = 0;
- 					yrel = 0;
- 				}
-@@ -429,22 +497,26 @@
- 			case DIMOFS_BUTTON1:
- 			case DIMOFS_BUTTON2:
- 			case DIMOFS_BUTTON3:
-+#if DIRECTINPUT_VERSION >= 0x700
-+			case DIMOFS_BUTTON4:
-+			case DIMOFS_BUTTON5:
-+			case DIMOFS_BUTTON6:
-+			case DIMOFS_BUTTON7:
-+#endif
- 				if ( xrel || yrel ) {
--					posted = SDL_PrivateMouseMotion(
--							0, 1, xrel, yrel);
-+					post_mouse_motion(1, xrel, yrel);
- 					xrel = 0;
- 					yrel = 0;
- 				}
- 				timestamp = 0;
- 				button = (Uint8)(ptrbuf[i].dwOfs-DIMOFS_BUTTON0)+1;
--				/* Button #2 on two button mice is button 3
--				   (the middle button is button 2)
--				 */
--				if ( button == 2 ) {
--					button = 3;
--				} else
--				if ( button == 3 ) {
--					button = 2;
-+				/* Map DI button numbers to SDL */
-+				switch ( button ) {
-+					case 2: button = SDL_BUTTON_RIGHT; break;
-+					case 3: button = SDL_BUTTON_MIDDLE; break;
-+					case 4: button = SDL_BUTTON_X1; break;
-+					case 5: button = SDL_BUTTON_X2; break;
-+					default: break;
- 				}
- 				if ( ptrbuf[i].dwData & 0x80 ) {
- 					/* Grab mouse so we get mouse-up */
-@@ -471,7 +543,7 @@
- 		}
- 	}
- 	if ( xrel || yrel ) {
--		posted = SDL_PrivateMouseMotion( 0, 1, xrel, yrel);
-+		post_mouse_motion(1, xrel, yrel);
- 	}
- }
- 
-@@ -516,10 +588,7 @@
- 
- 		/* The keyboard is handled via DirectInput */
- 		case WM_SYSKEYUP:
--		case WM_SYSKEYDOWN: {
--			/* Pass syskey to DefWindwoProc (ALT-F4, etc.) */
--		}
--		break;
-+		case WM_SYSKEYDOWN:
- 		case WM_KEYUP:
- 		case WM_KEYDOWN: {
- 			/* Ignore windows keyboard messages */;
-@@ -840,8 +909,13 @@
- 		keysym->unicode = vkey;
- #else
- 		GetKeyboardState(keystate);
--		if (SDL_ToUnicode(vkey, scancode, keystate, wchars, sizeof(wchars)/sizeof(wchars[0]), 0) == 1)
-+		/* Numlock isn't taken into account in ToUnicode, so we catch that case here */
-+		if ((keystate[VK_NUMLOCK] & 1) && vkey >= VK_NUMPAD0 && vkey <= VK_NUMPAD9)
- 		{
-+			keysym->sym = keysym->unicode = vkey - VK_NUMPAD0 + '0';
-+		}
-+		else if (SDL_ToUnicode(vkey, scancode, keystate, wchars, sizeof(wchars)/sizeof(wchars[0]), 0) > 0)
-+		{
- 			keysym->unicode = wchars[0];
- 		}
- #endif /* NO_GETKEYBOARDSTATE */
-Index: src/video/windx5/directx.h
-===================================================================
---- src/video/windx5/directx.h	(revision 4474)
-+++ src/video/windx5/directx.h	(working copy)
-@@ -72,7 +72,7 @@
- /* We need these defines to mark what version of DirectX API we use */
- #define DIRECTDRAW_VERSION  0x0700
- #define DIRECTSOUND_VERSION 0x0500
--#define DIRECTINPUT_VERSION 0x0500
-+#define DIRECTINPUT_VERSION 0x0700
- 
- #ifdef __GNUC__
- #define NONAMELESSUNION
-@@ -81,4 +81,20 @@
- #include <dsound.h>
- #include <dinput.h>
- 
-+#if DIRECTINPUT_VERSION >= 0x0700 && !defined(DIMOFS_BUTTON4)
-+typedef struct _DIMOUSESTATE2 {
-+    LONG    lX;
-+    LONG    lY;
-+    LONG    lZ;
-+    BYTE    rgbButtons[8];
-+} DIMOUSESTATE2, *LPDIMOUSESTATE2;
-+
-+#define DIMOFS_BUTTON4 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 4)
-+#define DIMOFS_BUTTON5 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 5)
-+#define DIMOFS_BUTTON6 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 6)
-+#define DIMOFS_BUTTON7 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 7)
-+
-+extern const DIDATAFORMAT c_dfDIMouse2;
-+#endif
-+
- #endif /* _directx_h */
-Index: configure.in
-===================================================================
---- configure.in	(revision 4474)
-+++ configure.in	(working copy)
-@@ -2442,7 +2442,7 @@
-         # Set up the system libraries we need
-         EXTRA_LDFLAGS="$EXTRA_LDFLAGS -luser32 -lgdi32 -lwinmm"
-         if test x$have_directx = xyes; then
--            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -ldxguid"
-+            EXTRA_LDFLAGS="$EXTRA_LDFLAGS -ldxguid -ldinput8"
-         fi
-         # The Win32 platform requires special setup
-         SOURCES="$SOURCES $srcdir/src/main/win32/*.rc"
diff -r 87f98d895296 -r 91f0a3d9f930 misc/transfer_settings.sh
--- a/misc/transfer_settings.sh	Sun Mar 29 01:15:08 2009 +0800
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,53 +0,0 @@
-#!/bin/sh
-
-# Find the path
-if [ -d "$HOME/.tremulous" ]; then
-	SRCDIR="$HOME/.tremulous"
-	DESTDIR="$HOME/.tremfusion"
-else
-	echo "Tremulous home directory could not be found."
-	exit 1
-fi
-
-echo "Tremulous home directory found at $SRCDIR"
-echo "Copying settings to $DESTDIR"
-
-mkdir -p $DESTDIR
-cd $SRCDIR
-
-# Copy directory structure
-echo "Copying directory structure..."
-find * -type d \
-	-exec mkdir $DESTDIR/{} \;
-
-# Hard link all the read-only stuff
-echo "Hard-linking large files..."
-find * \( -type f -o -type l \) \
-	\( -name \*.pk3 \
-	-o -name \*.jpg \
-	-o -name \*.tga \
-	-o -name \*.svdm_\* \
-	-o -name \*.dm_\* \
-	-o -name \*.avi \) \
-	-exec ln {} $DESTDIR/{} \;
-	
-# Copy the rest
-echo "Copying small files..."
-find * \( -type f -o -type l \) \
-	! -name \*.pk3 \
-	! -name \*.jpg \
-	! -name \*.tga \
-	! -name \*.svdm_\* \
-	! -name \*.dm_\* \
-	! -name \*.tmp \
-	! -name \*.avi \
-	-exec cp -dp {} $DESTDIR/{} \;
-
-# Fix some setting
-echo "Fixing autogen.cfg..."
-sed -e 's/seta\ cl_defaultUI\ \"[^\"]*\"//' \
-	-e 's/seta\ fs_extrapaks\ \"[^\"]*\"//' \
-	-e 's/seta\ s_alDriver\ \"[^\"]*\"//' \
-	autogen.cfg > $DESTDIR/autogen.cfg
-
-echo "Done."
diff -r 87f98d895296 -r 91f0a3d9f930 misc/tremfusion.xpm
--- a/misc/tremfusion.xpm	Sun Mar 29 01:15:08 2009 +0800
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,962 +0,0 @@
-/* XPM */
-static char * tremfusion_xpm[] = {
-"48 48 911 2",
-"  	c None",
-". 	c #3C727E",
-"+ 	c #2C565C",
-"@ 	c #204447",
-"# 	c #1A3A3C",
-"$ 	c #173536",
-"% 	c #1A3D3F",
-"& 	c #193C3E",
-"* 	c #163536",
-"= 	c #1E4042",
-"- 	c #2B5256",
-"; 	c #3B6C76",
-"> 	c #366A74",
-", 	c #386E76",
-"' 	c #34676F",
-") 	c #1A3F42",
-"! 	c #0E2323",
-"~ 	c #275357",
-"{ 	c #112B2C",
-"] 	c #102C2C",
-"^ 	c #133537",
-"/ 	c #133435",
-"( 	c #14383A",
-"_ 	c #0F2728",
-": 	c #0E2525",
-"< 	c #10292A",
-"[ 	c #1C3D3F",
-"} 	c #316169",
-"| 	c #143132",
-"1 	c #2B5D61",
-"2 	c #33686F",
-"3 	c #346A72",
-"4 	c #275155",
-"5 	c #2F5C62",
-"6 	c #407C8B",
-"7 	c #173638",
-"8 	c #133739",
-"9 	c #0E2424",
-"0 	c #0F2627",
-"a 	c #294F55",
-"b 	c #112A2B",
-"c 	c #254A4E",
-"d 	c #3E7786",
-"e 	c #386D79",
-"f 	c #14393B",
-"g 	c #30646B",
-"h 	c #153839",
-"i 	c #112F30",
-"j 	c #0F2829",
-"k 	c #102828",
-"l 	c #122D2E",
-"m 	c #142F30",
-"n 	c #325F67",
-"o 	c #2F5A62",
-"p 	c #23474A",
-"q 	c #123031",
-"r 	c #112C2D",
-"s 	c #102929",
-"t 	c #0F292A",
-"u 	c #113031",
-"v 	c #33646D",
-"w 	c #417885",
-"x 	c #32616A",
-"y 	c #32626C",
-"z 	c #407D8C",
-"A 	c #3E7887",
-"B 	c #295055",
-"C 	c #164548",
-"D 	c #0F2626",
-"E 	c #123132",
-"F 	c #143739",
-"G 	c #123436",
-"H 	c #1C4547",
-"I 	c #244A4D",
-"J 	c #2A5359",
-"K 	c #366973",
-"L 	c #2D5A61",
-"M 	c #1A3B3D",
-"N 	c #13383A",
-"O 	c #1D4E51",
-"P 	c #102A2B",
-"Q 	c #0F2727",
-"R 	c #102B2C",
-"S 	c #183638",
-"T 	c #274E52",
-"U 	c #2A565C",
-"V 	c #123435",
-"W 	c #1E3F42",
-"X 	c #264B50",
-"Y 	c #1F5358",
-"Z 	c #24585D",
-"` 	c #123335",
-" .	c #1A494C",
-"..	c #1B5155",
-"+.	c #19474A",
-"@.	c #28595D",
-"#.	c #17383A",
-"$.	c #29585C",
-"%.	c #215358",
-"&.	c #255054",
-"*.	c #143C3F",
-"=.	c #0F2525",
-"-.	c #163435",
-";.	c #204143",
-">.	c #1A393A",
-",.	c #18393B",
-"'.	c #2A575E",
-").	c #2E5D65",
-"!.	c #17474A",
-"~.	c #163839",
-"{.	c #3C7481",
-"].	c #295155",
-"^.	c #254E51",
-"/.	c #245053",
-"(.	c #215D61",
-"_.	c #2D6166",
-":.	c #2A5F64",
-"<.	c #337079",
-"[.	c #1D575B",
-"}.	c #25585C",
-"|.	c #265E62",
-"1.	c #205C61",
-"2.	c #275D61",
-"3.	c #153C3E",
-"4.	c #2C5F64",
-"5.	c #378291",
-"6.	c #346C74",
-"7.	c #184244",
-"8.	c #102C2D",
-"9.	c #173435",
-"0.	c #305F67",
-"a.	c #102829",
-"b.	c #2C5860",
-"c.	c #376B76",
-"d.	c #22494C",
-"e.	c #193B3D",
-"f.	c #356872",
-"g.	c #23494C",
-"h.	c #1C565B",
-"i.	c #245D62",
-"j.	c #245B60",
-"k.	c #2B5E63",
-"l.	c #34727B",
-"m.	c #2A5E63",
-"n.	c #327681",
-"o.	c #377E8D",
-"p.	c #295F63",
-"q.	c #336E78",
-"r.	c #336C74",
-"s.	c #31666E",
-"t.	c #31666C",
-"u.	c #31676E",
-"v.	c #194244",
-"w.	c #1E4B4E",
-"x.	c #1B4345",
-"y.	c #376872",
-"z.	c #31626B",
-"A.	c #143032",
-"B.	c #295156",
-"C.	c #1D3E40",
-"D.	c #153E41",
-"E.	c #235C60",
-"F.	c #2B5B61",
-"G.	c #346D74",
-"H.	c #24585C",
-"I.	c #2B5E62",
-"J.	c #387984",
-"K.	c #35737F",
-"L.	c #3B8392",
-"M.	c #2E6065",
-"N.	c #336971",
-"O.	c #347984",
-"P.	c #31656B",
-"Q.	c #245356",
-"R.	c #205357",
-"S.	c #316871",
-"T.	c #336A72",
-"U.	c #2F6167",
-"V.	c #32686E",
-"W.	c #2E6267",
-"X.	c #3B707A",
-"Y.	c #234E53",
-"Z.	c #112E2F",
-"`.	c #214447",
-" +	c #113032",
-".+	c #2A5458",
-"++	c #102D2D",
-"@+	c #17494D",
-"#+	c #1B5C61",
-"$+	c #2F6369",
-"%+	c #285E63",
-"&+	c #1A4E52",
-"*+	c #31646A",
-"=+	c #2D5E64",
-"-+	c #184C50",
-";+	c #1A4F53",
-">+	c #265A5F",
-",+	c #316870",
-"'+	c #1E484B",
-")+	c #30646A",
-"!+	c #337B87",
-"~+	c #336D75",
-"{+	c #2E6067",
-"]+	c #2B5559",
-"^+	c #183B3C",
-"/+	c #23474B",
-"(+	c #194649",
-"_+	c #224A4C",
-":+	c #2F5A60",
-"<+	c #1D5155",
-"[+	c #32686F",
-"}+	c #1D585D",
-"|+	c #254F53",
-"1+	c #215A5E",
-"2+	c #225D61",
-"3+	c #1C474A",
-"4+	c #1E5C61",
-"5+	c #367680",
-"6+	c #336C75",
-"7+	c #34717A",
-"8+	c #336970",
-"9+	c #3B7B89",
-"0+	c #36737E",
-"a+	c #347B89",
-"b+	c #337680",
-"c+	c #2A5559",
-"d+	c #3D7786",
-"e+	c #163A3B",
-"f+	c #386E79",
-"g+	c #22484B",
-"h+	c #396D76",
-"i+	c #3C7583",
-"j+	c #1E494D",
-"k+	c #225B60",
-"l+	c #2D5F65",
-"m+	c #285E62",
-"n+	c #3C8492",
-"o+	c #336B73",
-"p+	c #2A595F",
-"q+	c #398695",
-"r+	c #1F5C61",
-"s+	c #235D61",
-"t+	c #34808D",
-"u+	c #327C8A",
-"v+	c #2F7B89",
-"w+	c #307B89",
-"x+	c #348392",
-"y+	c #317F8D",
-"z+	c #347A86",
-"A+	c #2B5F64",
-"B+	c #346D76",
-"C+	c #2D5B60",
-"D+	c #264E52",
-"E+	c #0F2828",
-"F+	c #1C3E41",
-"G+	c #38707D",
-"H+	c #1F474A",
-"I+	c #347986",
-"J+	c #295D62",
-"K+	c #326A73",
-"L+	c #388190",
-"M+	c #205B60",
-"N+	c #4291A3",
-"O+	c #408FA3",
-"P+	c #34717C",
-"Q+	c #347884",
-"R+	c #348290",
-"S+	c #336F78",
-"T+	c #337A87",
-"U+	c #398E9E",
-"V+	c #388B9B",
-"W+	c #307C8A",
-"X+	c #307C8B",
-"Y+	c #338291",
-"Z+	c #378696",
-"`+	c #327782",
-" @	c #336F7A",
-".@	c #2C5E63",
-"+@	c #3E7783",
-"@@	c #3F7B8A",
-"#@	c #2E5F66",
-"$@	c #204B4E",
-"%@	c #336168",
-"&@	c #326067",
-"*@	c #33747F",
-"=@	c #31747F",
-"-@	c #336E77",
-";@	c #326E79",
-">@	c #338191",
-",@	c #377884",
-"'@	c #368A99",
-")@	c #398C9D",
-"!@	c #3A8FA0",
-"~@	c #4A9AB1",
-"{@	c #3E91A4",
-"]@	c #4192A7",
-"^@	c #418DA0",
-"/@	c #367C8A",
-"(@	c #31808E",
-"_@	c #368B9B",
-":@	c #3D90A2",
-"<@	c #338392",
-"[@	c #338493",
-"}@	c #358190",
-"|@	c #2C5D63",
-"1@	c #33646C",
-"2@	c #24494D",
-"3@	c #132F30",
-"4@	c #194143",
-"5@	c #3C7782",
-"6@	c #337987",
-"7@	c #377A86",
-"8@	c #326F79",
-"9@	c #337E8D",
-"0@	c #317F8E",
-"a@	c #408C9E",
-"b@	c #387884",
-"c@	c #3A828F",
-"d@	c #3D91A3",
-"e@	c #388D9D",
-"f@	c #357781",
-"g@	c #1D4346",
-"h@	c #2A575B",
-"i@	c #356A71",
-"j@	c #326D76",
-"k@	c #377E8B",
-"l@	c #3A7681",
-"m@	c #4E9EB7",
-"n@	c #367681",
-"o@	c #3C8696",
-"p@	c #378494",
-"q@	c #327B87",
-"r@	c #305F65",
-"s@	c #3E7D8D",
-"t@	c #122D2D",
-"u@	c #386C78",
-"v@	c #164649",
-"w@	c #275055",
-"x@	c #366971",
-"y@	c #346C75",
-"z@	c #5BABCD",
-"A@	c #4293A8",
-"B@	c #3C899B",
-"C@	c #4899B0",
-"D@	c #509DBB",
-"E@	c #38737E",
-"F@	c #4291A4",
-"G@	c #3E91A3",
-"H@	c #346F79",
-"I@	c #3F92A5",
-"J@	c #4A9BB2",
-"K@	c #3A6C75",
-"L@	c #458495",
-"M@	c #2E6168",
-"N@	c #398392",
-"O@	c #336B75",
-"P@	c #398B9C",
-"Q@	c #2F646C",
-"R@	c #1A3C3E",
-"S@	c #366870",
-"T@	c #1C5054",
-"U@	c #2A545A",
-"V@	c #376E77",
-"W@	c #3C889A",
-"X@	c #4999B0",
-"Y@	c #4295A9",
-"Z@	c #397884",
-"`@	c #428FA3",
-" #	c #5CACCD",
-".#	c #4E9DB6",
-"+#	c #316B74",
-"@#	c #4697AC",
-"##	c #3E90A3",
-"$#	c #3A8D9E",
-"%#	c #4393A8",
-"&#	c #398797",
-"*#	c #33808C",
-"=#	c #32646A",
-"-#	c #2C565B",
-";#	c #2F707A",
-">#	c #327B88",
-",#	c #3C7581",
-"'#	c #2F5A61",
-")#	c #2B545B",
-"!#	c #36666D",
-"~#	c #1D5053",
-"{#	c #3D7380",
-"]#	c #3D7885",
-"^#	c #4C9DB5",
-"/#	c #57A6C6",
-"(#	c #55A6C6",
-"_#	c #5EABCE",
-":#	c #275257",
-"<#	c #29565B",
-"[#	c #3E7B8C",
-"}#	c #40889B",
-"|#	c #4294A8",
-"1#	c #4898AF",
-"2#	c #4797AE",
-"3#	c #51A0BB",
-"4#	c #4C9CB5",
-"5#	c #36747F",
-"6#	c #3A6F7A",
-"7#	c #1F4144",
-"8#	c #438394",
-"9#	c #2F5E65",
-"0#	c #2F7A88",
-"a#	c #346972",
-"b#	c #488596",
-"c#	c #28555A",
-"d#	c #23484B",
-"e#	c #2B595E",
-"f#	c #285054",
-"g#	c #427C89",
-"h#	c #3F92A6",
-"i#	c #3F90A3",
-"j#	c #327D8C",
-"k#	c #254B4E",
-"l#	c #214042",
-"m#	c #234C50",
-"n#	c #3B808E",
-"o#	c #4D9AB5",
-"p#	c #4C9DB7",
-"q#	c #4697AB",
-"r#	c #448A9E",
-"s#	c #3B8C9D",
-"t#	c #376C75",
-"u#	c #2A5257",
-"v#	c #2D5C62",
-"w#	c #36676E",
-"x#	c #2F7A89",
-"y#	c #357785",
-"z#	c #376D76",
-"A#	c #325A5F",
-"B#	c #254E52",
-"C#	c #284F53",
-"D#	c #3B717C",
-"E#	c #3C8EA0",
-"F#	c #438EA2",
-"G#	c #32656D",
-"H#	c #3A6E78",
-"I#	c #41737E",
-"J#	c #234345",
-"K#	c #31747E",
-"L#	c #29595F",
-"M#	c #4495AA",
-"N#	c #368493",
-"O#	c #4F9EB9",
-"P#	c #4C9BB3",
-"Q#	c #396C75",
-"R#	c #3E7A89",
-"S#	c #21484B",
-"T#	c #326268",
-"U#	c #377078",
-"V#	c #499AB2",
-"W#	c #34646B",
-"X#	c #3D7582",
-"Y#	c #3C7582",
-"Z#	c #325E66",
-"`#	c #3A6F79",
-" $	c #388999",
-".$	c #4B9AB1",
-"+$	c #285459",
-"@$	c #407F90",
-"#$	c #38676F",
-"$$	c #4B9AB2",
-"%$	c #4A99B0",
-"&$	c #2E6269",
-"*$	c #3B7682",
-"=$	c #1F484B",
-"-$	c #35636C",
-";$	c #255356",
-">$	c #4B8EA3",
-",$	c #346F77",
-"'$	c #3A8B9C",
-")$	c #357C88",
-"!$	c #4494A9",
-"~$	c #3C7F8C",
-"{$	c #3F7480",
-"]$	c #3B7883",
-"^$	c #4091A4",
-"/$	c #2C5C61",
-"($	c #4B99B2",
-"_$	c #4897AE",
-":$	c #2E5A60",
-"<$	c #427E8E",
-"[$	c #2E5D63",
-"}$	c #3D7782",
-"|$	c #4491A5",
-"1$	c #3B8798",
-"2$	c #317C8A",
-"3$	c #2D575C",
-"4$	c #306267",
-"5$	c #378594",
-"6$	c #39747F",
-"7$	c #317E8D",
-"8$	c #4594A9",
-"9$	c #3F8C9D",
-"0$	c #34636D",
-"a$	c #376B75",
-"b$	c #3C818F",
-"c$	c #3F889A",
-"d$	c #4B9CB5",
-"e$	c #4697AD",
-"f$	c #3B8898",
-"g$	c #305C62",
-"h$	c #427E8D",
-"i$	c #2C595D",
-"j$	c #328291",
-"k$	c #2C595F",
-"l$	c #417684",
-"m$	c #468190",
-"n$	c #437D8A",
-"o$	c #366E78",
-"p$	c #2C5C62",
-"q$	c #2F7380",
-"r$	c #306770",
-"s$	c #275256",
-"t$	c #19383A",
-"u$	c #2C5A5F",
-"v$	c #3A7A86",
-"w$	c #3E747F",
-"x$	c #2A5558",
-"y$	c #3C6C76",
-"z$	c #346E77",
-"A$	c #4E9FB9",
-"B$	c #3B8E9F",
-"C$	c #386A72",
-"D$	c #4394A8",
-"E$	c #4294A9",
-"F$	c #377D89",
-"G$	c #357A87",
-"H$	c #30717C",
-"I$	c #2F7987",
-"J$	c #306E78",
-"K$	c #35676F",
-"L$	c #23494D",
-"M$	c #2E5B61",
-"N$	c #3A707C",
-"O$	c #3C7580",
-"P$	c #376B74",
-"Q$	c #32646C",
-"R$	c #316065",
-"S$	c #437F90",
-"T$	c #387C88",
-"U$	c #376A73",
-"V$	c #3C7783",
-"W$	c #3F8C9E",
-"X$	c #3A808E",
-"Y$	c #295458",
-"Z$	c #2C555B",
-"`$	c #37737E",
-" %	c #3B8EA0",
-".%	c #388C9D",
-"+%	c #378B9B",
-"@%	c #358796",
-"#%	c #317884",
-"$%	c #326069",
-"%%	c #366974",
-"&%	c #3E7885",
-"*%	c #4797AD",
-"=%	c #3D7F8D",
-"-%	c #3E707C",
-";%	c #3B737F",
-">%	c #3B737E",
-",%	c #368494",
-"'%	c #357783",
-")%	c #2C595E",
-"!%	c #407B89",
-"~%	c #34656C",
-"{%	c #34666C",
-"]%	c #3E7B88",
-"^%	c #4394A9",
-"/%	c #348696",
-"(%	c #32818F",
-"_%	c #328392",
-":%	c #31818F",
-"<%	c #2B5B62",
-"[%	c #376C77",
-"}%	c #427F8E",
-"|%	c #2F5B62",
-"1%	c #3B7E8C",
-"2%	c #37656C",
-"3%	c #316068",
-"4%	c #376D75",
-"5%	c #36656D",
-"6%	c #264B4E",
-"7%	c #3B737D",
-"8%	c #3C7480",
-"9%	c #397F8C",
-"0%	c #458292",
-"a%	c #2B565B",
-"b%	c #386C77",
-"c%	c #417B89",
-"d%	c #31666D",
-"e%	c #39737E",
-"f%	c #315D62",
-"g%	c #3F7B89",
-"h%	c #327884",
-"i%	c #2F7683",
-"j%	c #22484C",
-"k%	c #306B74",
-"l%	c #377783",
-"m%	c #30626B",
-"n%	c #356E78",
-"o%	c #3B747F",
-"p%	c #37676F",
-"q%	c #335E64",
-"r%	c #336D77",
-"s%	c #265256",
-"t%	c #396F78",
-"u%	c #376C76",
-"v%	c #35656C",
-"w%	c #224A4D",
-"x%	c #34636A",
-"y%	c #386B74",
-"z%	c #3A707A",
-"A%	c #1B555A",
-"B%	c #2F585E",
-"C%	c #31646D",
-"D%	c #30656E",
-"E%	c #418899",
-"F%	c #35727D",
-"G%	c #356D76",
-"H%	c #3F7786",
-"I%	c #366C75",
-"J%	c #326770",
-"K%	c #4998AF",
-"L%	c #316066",
-"M%	c #397581",
-"N%	c #3B7985",
-"O%	c #2E4A4D",
-"P%	c #326771",
-"Q%	c #306369",
-"R%	c #3D7E8C",
-"S%	c #458FA4",
-"T%	c #3E7683",
-"U%	c #437F8E",
-"V%	c #37707A",
-"W%	c #244A4E",
-"X%	c #295A5E",
-"Y%	c #3E7682",
-"Z%	c #1D4245",
-"`%	c #386A73",
-" &	c #3F7783",
-".&	c #3C8291",
-"+&	c #305E66",
-"@&	c #24474A",
-"#&	c #133031",
-"$&	c #234A4E",
-"%&	c #27494B",
-"&&	c #418698",
-"*&	c #3A636A",
-"=&	c #3D7581",
-"-&	c #3A717C",
-";&	c #376A74",
-">&	c #1D4649",
-",&	c #34727D",
-"'&	c #1E474A",
-")&	c #33646E",
-"!&	c #32636A",
-"~&	c #3A7380",
-"{&	c #458394",
-"]&	c #3D8290",
-"^&	c #39676E",
-"/&	c #3A7884",
-"(&	c #21494C",
-"_&	c #183739",
-":&	c #274B4E",
-"<&	c #3A646B",
-"[&	c #316269",
-"}&	c #33626A",
-"|&	c #378998",
-"1&	c #397580",
-"2&	c #386E77",
-"3&	c #428698",
-"4&	c #3C8595",
-"5&	c #224C4F",
-"6&	c #3B727C",
-"7&	c #4E9DB8",
-"8&	c #2E585F",
-"9&	c #3D7783",
-"0&	c #3A6D76",
-"a&	c #3F8494",
-"b&	c #365D62",
-"c&	c #3B696F",
-"d&	c #315C63",
-"e&	c #477680",
-"f&	c #306169",
-"g&	c #406E77",
-"h&	c #3A727F",
-"i&	c #305E64",
-"j&	c #396E77",
-"k&	c #31808F",
-"l&	c #34686E",
-"m&	c #265156",
-"n&	c #3F7A87",
-"o&	c #2E6369",
-"p&	c #346770",
-"q&	c #468596",
-"r&	c #2B585E",
-"s&	c #224244",
-"t&	c #3C707A",
-"u&	c #3F7C89",
-"v&	c #438190",
-"w&	c #35666E",
-"x&	c #3B727D",
-"y&	c #3E7C8C",
-"z&	c #376870",
-"A&	c #396F79",
-"B&	c #3F7079",
-"C&	c #2F575C",
-"D&	c #265356",
-"E&	c #29575D",
-"F&	c #31646B",
-"G&	c #2D5A5F",
-"H&	c #3E7A86",
-"I&	c #346F78",
-"J&	c #2E6066",
-"K&	c #37727D",
-"L&	c #447D8B",
-"M&	c #386A74",
-"N&	c #306168",
-"O&	c #35676E",
-"P&	c #3D6E77",
-"Q&	c #3D7684",
-"R&	c #427E8C",
-"S&	c #28565A",
-"T&	c #1B4F53",
-"U&	c #275E62",
-"V&	c #3E7784",
-"W&	c #398291",
-"X&	c #428899",
-"Y&	c #418393",
-"Z&	c #457F8D",
-"`&	c #377580",
-" *	c #3D656B",
-".*	c #38717B",
-"+*	c #3F7988",
-"@*	c #3A7886",
-"#*	c #33676E",
-"$*	c #295E63",
-"%*	c #33666D",
-"&*	c #448495",
-"**	c #33656C",
-"=*	c #3F7C8A",
-"-*	c #43879A",
-";*	c #478192",
-">*	c #36707A",
-",*	c #40656C",
-"'*	c #3F92A4",
-")*	c #397782",
-"!*	c #3F7A88",
-"~*	c #3F747E",
-"{*	c #2F5C63",
-"]*	c #2E5E66",
-"^*	c #378898",
-"/*	c #275559",
-"(*	c #386770",
-"_*	c #26565A",
-":*	c #2A5B61",
-"<*	c #396B74",
-"[*	c #265559",
-"}*	c #1F4D50",
-"|*	c #3A7682",
-"1*	c #3B8D9E",
-"2*	c #1B3E40",
-"3*	c #37585C",
-"4*	c #315F66",
-"5*	c #25484B",
-"6*	c #3A676F",
-"7*	c #447581",
-"8*	c #32656C",
-"9*	c #32636B",
-"0*	c #3F6971",
-"a*	c #368290",
-"b*	c #388C9C",
-"c*	c #3C8D9D",
-"d*	c #2F636A",
-"e*	c #34656D",
-"f*	c #2C585D",
-"g*	c #35717B",
-"h*	c #2D5358",
-"i*	c #214F53",
-"j*	c #397481",
-"k*	c #2F737F",
-"l*	c #30737F",
-"m*	c #336972",
-"n*	c #28565B",
-"o*	c #2F5D65",
-"p*	c #376267",
-"q*	c #467C89",
-"r*	c #366B72",
-"s*	c #356066",
-"t*	c #33727C",
-"u*	c #317987",
-"v*	c #326971",
-"w*	c #1D5256",
-"x*	c #285155",
-"y*	c #2E5C64",
-"z*	c #1E484C",
-"A*	c #27595E",
-"B*	c #3A6A73",
-"C*	c #2A585E",
-"D*	c #214C4F",
-"E*	c #38717E",
-"F*	c #39727D",
-"G*	c #3D8EA0",
-"H*	c #3C8D9E",
-"I*	c #337580",
-"J*	c #32808F",
-"K*	c #1F4D51",
-"L*	c #1B3C3F",
-"M*	c #325356",
-"N*	c #2B5458",
-"O*	c #375D62",
-"P*	c #3E8DA0",
-"Q*	c #3A8696",
-"R*	c #336D76",
-"S*	c #386D78",
-"T*	c #245457",
-"U*	c #2E5B63",
-"V*	c #26585D",
-"W*	c #204F52",
-"X*	c #3A707B",
-"Y*	c #1E494C",
-"Z*	c #1E575B",
-"`*	c #2F6268",
-" =	c #1A5357",
-".=	c #274A4D",
-"+=	c #324F52",
-"@=	c #2D5E63",
-"#=	c #265054",
-"$=	c #316972",
-"%=	c #328391",
-"&=	c #2B585D",
-"*=	c #336B76",
-"==	c #1B484B",
-"-=	c #284E52",
-";=	c #3B7381",
-">=	c #204649",
-",=	c #327C89",
-"'=	c #1F5A5F",
-")=	c #2B6065",
-"!=	c #1B494C",
-"~=	c #33747D",
-"{=	c #348796",
-"]=	c #235D62",
-"^=	c #20585D",
-"/=	c #2F636C",
-"(=	c #2C555A",
-"_=	c #398A9B",
-":=	c #348695",
-"<=	c #368A9A",
-"[=	c #2D6066",
-"}=	c #33717B",
-"|=	c #2F6368",
-"1=	c #2A5358",
-"2=	c #3E7684",
-"3=	c #336870",
-"4=	c #28585C",
-"5=	c #2D5F66",
-"6=	c #3F8493",
-"7=	c #356E77",
-"8=	c #2B5C61",
-"9=	c #438292",
-"0=	c #316067",
-"a=	c #2B595D",
-"b=	c #316167",
-"c=	c #326066",
-"d=	c #274F53",
-"e=	c #295358",
-"f=	c #325F66",
-"g=	c #468291",
-"h=	c #407A88",
-"i=	c #305B60",
-"j=	c #48889B",
-"k=	c #418596",
-"l=	c #3D8494",
-"m=	c #4590A7",
-"n=	c #4395AA",
-"o=	c #2C5B62",
-"p=	c #346870",
-"q=	c #2E6266",
-"r=	c #2D585E",
-"s=	c #325B62",
-"t=	c #2C5A5E",
-"u=	c #34747E",
-"v=	c #356B74",
-"w=	c #3C7986",
-"x=	c #458393",
-"y=	c #3D7D8A",
-"z=	c #366F7A",
-"A=	c #184245",
-"B=	c #234B4F",
-"C=	c #1B3F42",
-"D=	c #3B8391",
-"E=	c #1A4446",
-"F=	c #27565A",
-"G=	c #386E78",
-"H=	c #305A60",
-"I=	c #3F7885",
-"J=	c #437B88",
-"K=	c #3F7F90",
-"L=	c #3D7C88",
-"M=	c #3F7580",
-"N=	c #416F79",
-"O=	c #487F8E",
-"P=	c #4A8495",
-"Q=	c #376C74",
-"R=	c #3D7481",
-"                                    . + @ # $ % & * $ = - ;                                     ",
-"                              > , ' ) ! ! ~ { ] ^ / ( _ : ! < [ }                               ",
-"                          + | 1 2 3 4 5 6   7 8 9 < ! : 0 9 ! ! ! { a                           ",
-"                          * b c d         e f g ^ h i j ! ! ! k l 9 9 m n                       ",
-"                          o               p 9 q r s ! ! t u _ v   w x y z                       ",
-"                A                       B 9 0 C ^ ! u D E F G H I J K                           ",
-"              L [                     M ! ! ! N O ! P Q ! j R 8 ! ! ! D S T                     ",
-"            U V W                 X Y Z `  .j C ..+.@.#.$.%.&.*.=.! ! ! -.;.>.l ,.'.            ",
-"          ).!.~.{.            ].^./.(._.:.<.[.}.|.1.2.3.4.5.6.7.!.8.! 9.      0.a.9 b.          ",
-"        c.d.e.f.            g.h.!.i.j.k.l.m.n.o.p.q.r.s.t.u.v.N w.x.h y.        z.9 P f.        ",
-"        A.! B.            C.D.E.F.G.H.I.J.K.L.M.N.O.P.Q.R.S.T.U.V.W.X.            Y.Z.|         ",
-"      `. +C.            .+++@+#+$+%+&+j.*+m.=+-+;+>+,+'+)+!+~+p.{+1.]+              ^+=./+      ",
-"    > (+_+            :+p.<+i.1.W.[+}+|+1+2+%.3+4+m.5+q.6+7+8+9+0+a+b+c+            d+q e+f+    ",
-"    g+& h+          i+j+k+i.l+m+k.n+o+p+2 i.$+q+r+s+t+u+v+w+x+y+z+A+B+C+              D+E+F+    ",
-"  G+8 H+            + [+I+J+K+L+M+N+O+P+Q+R+r.S+T+r.U+V+W+X+Y+Z+`+ @.@+@                { Q @@  ",
-"  #@$@%@            &@*@=@-@;@>@,@'@)@!@~@{@]@^@{+/@(@_@)@:@<@[@}@|@1@                  |+_ 2@  ",
-"  3@4@              5@6@7@8@9@0@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@                    s@_ t@  ",
-"u@v@w@              x@y@z@A@B@C@D@E@F@G@U+k@,@H@I@J@K@L@M@N@O@P@Q@                        R@! . ",
-"S@T@U@              V@W@X@Y@Z@`@ #.#+#@###Y+$#%#&#*#=#  r@-#;#>#,#                        '#++)#",
-"!#~#{#              ]#^#/#(#_#:#<#[#}#^#|#1#2#3#4#5#6#  7#8#9#0#a#                        b#c#d#",
-"e#f#                g#h#i#j#k#l#P m#n#o#p#{@q#r#s#t#  u#v#  w#x#y#z#                        A#I ",
-"B#C#                D#E#F#G#H#  I#J#K#L#M#|#N#O#P#Q#R#S#T#  U#V#W#X#                            ",
-"Y#Z#                `# $.$+$@$      #$S#$$%$&$%$%$*$=$-$;$>$,$'$S.                              ",
-"                    X#)$!$~$          {$]$^$/$($%$_$:$<$[$}$|$1$2$3$                            ",
-"                      4$Y+5$6$          K+7$D+p 8$9$0$  a$b$c$d$e$f$g$h$                        ",
-"                      i$y+j$k$l$m$n$o$p$q$r$s$t$u$v$w$  x$y$z$A$~@X@B$C$                        ",
-"                      , D$%$E$F$G$H$I$I$J$K$L$M$N$O$P$Q$R$S$T$U$V$W$X$B+                    Y$Z$",
-"                      `$|# %.%+%M#E#@%#%9#  $%@ %%&%*%=%-%2@;%  >%,%'%)%!%u@                ~%{%",
-"                      ]%^%/%(%0#_%:%I$<%  [%}%|%1%2%3%4%5%6%7%8%' 9%]+0%a%b%              c%d%e%",
-"f%n                   g%h%0#:%W+i%j%k%l%m%n%h+o%%$p%q%r%T.s%  t%%$u%  v%w%                x%%+y%",
-"z%A%B%                  C%D%E%F%G%H%I%J%K%%$L%M%N%O%5#P%2%Q%!%R%S%T%U%V%W%                c+X%Y%",
-"  %+Z%                      `%     &.&+&B.@&#&$&%&&&!#B#*&k$=&5#-&  ;&V$                  w.>&  ",
-"  ,&'&)&                    !&M$~&{&]&^&/&(&2%_&:&g+<&[&}&        :+|&1&                k$`+2&  ",
-"  3&4&5&                    6&7&8&  9&0&a&b&c&d&e&f&g&h&i&        j&k&l&                m&,+n&  ",
-"    o&[.p&                  q&r&s&t&u&v&w&x&y&z&  A&B&            C&T.D&              E&F&G&    ",
-"    H&I&J&                    K&P$w$L&7%M&N&O&P&  Q&            R&f#=@S&              T&U&V&    ",
-"      z#W&{+                  X&Y&Z&5@`& *[@.*        N$    +*M@@*9+Y+#*            <#$*%*      ",
-"      &***k$b%                =*-*;*>*N%,*'*)*  !*G&  ]+~*{*]*^*1#K%5./*          (*_*:*        ",
-"        <*[*}*M%              |*1*.+|%2*3*4*5*6*7*8*{&9*0*a*b*c*}#B$d*e*        V&f*g*-&        ",
-"          h*p+i*              j*B$k*4*l*m*n*o*p*q*r*s*B.O&t*u*v*w*x*y*          z*A*B*          ",
-"            C*l+D*E*          F*G*H*I*J*F$K*p+L*M*N*O*:@P*Q*R*D*S*            {+T*U*            ",
-"              <#V*W*X*          D+Y*Z*=@`* =.=+=@=#=$=%=^%A@&=                J&*=              ",
-"                w@==-=            ;=>=,='=)=S#!=r.~={=t.]=^=;&                /=                ",
-"                                    (=_=!+:=<=*@)=[=}=u.|=1=        2=                          ",
-"                                    6 3=4=m&5=6=W.7=l.O.8=    9=0=a=b=                          ",
-"                              c=d=e=f=g=  h=i=j=k=l=m=n=o=a%L%p=q=k$r=                          ",
-"                              s=t=u=v=w=x=y=z=_+A=B=C=D=E=/$F=G=H=I=                            ",
-"                                  =*J=]%K=L=M=N=O=P=`#*$Q=L%R=                                  "};
diff -r 87f98d895296 -r 91f0a3d9f930 src/cgame/cg_draw.c
--- a/src/cgame/cg_draw.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/cgame/cg_draw.c	Sat Jun 06 02:45:31 2009 +0800
@@ -3494,6 +3494,10 @@
   if( cg.levelShot )
     return;
 
+  // fading to black if stamina runs out
+  // (only 2D that can't be disabled)
+  CG_DrawLighting( );
+
   if( cg_draw2D.integer == 0 )
     return;
 
@@ -3503,20 +3507,21 @@
     return;
   }
 
-  CG_DrawLighting( );
-
-  if( cg.snap->ps.persistant[ PERS_SPECSTATE ] == SPECTATOR_NOT )
+  if( cg.snap->ps.persistant[ PERS_SPECSTATE ] == SPECTATOR_NOT &&
+      !( cg.snap->ps.stats[ STAT_STATE ] & SS_HOVELING ) &&
+      cg.snap->ps.stats[ STAT_HEALTH ] > 0 )
+  {
     menu = Menus_FindByName( BG_ClassConfig( cg.predictedPlayerState.stats
                                                  [ STAT_CLASS ] )->hudName );
+    CG_DrawBuildableStatus( );
+  }
+
   if( !menu )
+  {
     menu = Menus_FindByName( "default_hud" );
-  if( !menu ) // still couldn't find it
-    CG_Error( "Default HUD could not be found" );
 
-  if( !( cg.snap->ps.stats[ STAT_STATE ] & SS_HOVELING ) &&
-      ( cg.snap->ps.stats[ STAT_HEALTH ] > 0 ) )
-  {
-    CG_DrawBuildableStatus( );
+    if( !menu ) // still couldn't find it
+      CG_Error( "Default HUD could not be found" );
   }
 
   Menu_Paint( menu, qtrue );
diff -r 87f98d895296 -r 91f0a3d9f930 src/cgame/cg_ents.c
--- a/src/cgame/cg_ents.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/cgame/cg_ents.c	Sat Jun 06 02:45:31 2009 +0800
@@ -216,7 +216,6 @@
 */
 static void CG_EntityEffects( centity_t *cent )
 {
-  int i;
 
   // update sound origins
   CG_SetEntitySoundPosition( cent );
@@ -818,42 +817,22 @@
 {
   int           i;
   entityState_t *es;
-  centity_t     *source = NULL, *target = NULL;
+  centity_t     *source = NULL, *target = NULL, *attacker = NULL;
+  int           targets[ LEVEL2_AREAZAP_MAX_TARGETS ], creator;
 
   es = &cent->currentState;
 
-
-  //FIXME: find a better way to send zap targets
-  for( i = 0; i <= 2; i++ )
+  BG_UnpackZapTargets( es, &creator, targets, LEVEL2_AREAZAP_MAX_TARGETS + 1 );
+  attacker = &cg_entities[ creator ];
+  for( i = 0; i < LEVEL2_AREAZAP_MAX_TARGETS; i++ )
   {
-    switch( i )
-    {
-      case 0:
-        if( es->time <= 0 )
-          continue;
-
-        source = &cg_entities[ es->misc ];
-        target = &cg_entities[ es->time ];
-        break;
-
-      case 1:
-        if( es->time2 <= 0 )
-          continue;
-
-        source = &cg_entities[ es->time ];
-        target = &cg_entities[ es->time2 ];
-        break;
-
-      case 2:
-        if( es->constantLight <= 0 )
-          continue;
-
-        source = &cg_entities[ es->time ];
-        target = &cg_entities[ es->constantLight ];
-        break;
-
-    }
-
+    if( i == 0 )
+      source = attacker;
+    else
+      source = &cg_entities[ targets[ 0 ] ];
+    if( targets[ i ] == ENTITYNUM_NONE )
+      continue;
+    target = &cg_entities[ targets[ i ] ];
     if( !CG_IsTrailSystemValid( &cent->level2ZapTS[ i ] ) )
       cent->level2ZapTS[ i ] = CG_SpawnNewTrailSystem( cgs.media.level2ZapTS );
 
@@ -1071,7 +1050,7 @@
   switch( es->eType )
   {
     case ET_LEV2_ZAP_CHAIN:
-      for( i = 0; i <= 2; i++ )
+      for( i = 0; i <= LEVEL2_AREAZAP_MAX_TARGETS; i++ )
       {
         if( CG_IsTrailSystemValid( &cent->level2ZapTS[ i ] ) )
           CG_DestroyTrailSystem( &cent->level2ZapTS[ i ] );
diff -r 87f98d895296 -r 91f0a3d9f930 src/cgame/cg_local.h
--- a/src/cgame/cg_local.h	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/cgame/cg_local.h	Sat Jun 06 02:45:31 2009 +0800
@@ -675,7 +675,7 @@
   particleSystem_t      *entityPS;
   qboolean              entityPSMissing;
 
-  trailSystem_t         *level2ZapTS[ 3 ];
+  trailSystem_t         *level2ZapTS[ LEVEL2_AREAZAP_MAX_TARGETS ];
   int                   level2ZapTime;
 
   trailSystem_t         *muzzleTS; //used for the tesla and reactor
diff -r 87f98d895296 -r 91f0a3d9f930 src/client/cl_keys.c
--- a/src/client/cl_keys.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/client/cl_keys.c	Sat Jun 06 02:45:31 2009 +0800
@@ -605,7 +605,7 @@
 			g_consoleField.cursor++;
 		}
 
-		Com_Printf ( "%s^7%s\n", cl_consolePrompt->string, g_consoleField.buffer );
+		Com_Printf ( "[skipnotify]%s^7%s\n", cl_consolePrompt->string, g_consoleField.buffer );
 
 		// leading slash is an explicit command
 		if ( g_consoleField.buffer[0] == '\\' || g_consoleField.buffer[0] == '/' ) {
diff -r 87f98d895296 -r 91f0a3d9f930 src/client/cl_main.c
--- a/src/client/cl_main.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/client/cl_main.c	Sat Jun 06 02:45:31 2009 +0800
@@ -1804,7 +1804,8 @@
 	// clear pak references
 	FS_ClearPakReferences( FS_UI_REF | FS_CGAME_REF );
 	// reinitialize the filesystem if the game directory or checksum has changed
-	FS_ConditionalRestart( clc.checksumFeed );
+	if ( cls.state <= CA_CONNECTED || cls.state == CA_CINEMATIC )
+		FS_ConditionalRestart( clc.checksumFeed );
 
 	cls.rendererStarted = qfalse;
 	cls.uiStarted = qfalse;
diff -r 87f98d895296 -r 91f0a3d9f930 src/game/bg_misc.c
--- a/src/game/bg_misc.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/game/bg_misc.c	Sat Jun 06 02:45:31 2009 +0800
@@ -3451,6 +3451,117 @@
 
 /*
 ===============
+BG_PackZapTargets
+
+pack up to 12 targets into an entityState_t
+===============
+*/
+//FIXME: magic - 1 and count makes no sense
+void BG_PackZapTargets( entityState_t *es, int creator, const int *targets, int count )
+{
+  int i;
+  es->misc = es->time = es->time2 = es->constantLight = 0;
+  for( i = 0; i < MAX_GENTITYNUM_PACK; i++ )
+  {
+    int entityNum = ENTITYNUM_NONE;
+    if( i < count )
+    {
+      if( i == 0 )
+        entityNum = creator;
+      else
+        entityNum = targets[ i - 1 ];
+    }
+    if( entityNum & ~(GENTITYNUM_MASK) )
+    {
+      Com_Printf("Warning: BG_PackZapTargets: targets[%d] (%d) doesn't fit in %d bits, using ENTITYNUM_NONE\n",
+                 i, targets[i], GENTITYNUM_BITS);
+      entityNum = ENTITYNUM_NONE;
+    }
+    switch( i )
+    {
+      case 0:
+        es->misc |= entityNum;
+        break;
+      case 1:
+        es->time |= entityNum;
+        break;
+      case 2:
+        es->time |= entityNum << GENTITYNUM_BITS;
+        break;
+      case 3:
+        es->time |= entityNum << (GENTITYNUM_BITS * 2);
+        break;
+      case 4:
+        es->time2 |= entityNum;
+        break;
+      case 5:
+        es->time2 |= entityNum << GENTITYNUM_BITS;
+        break;
+      case 6:
+        es->time2 |= entityNum << (GENTITYNUM_BITS * 2);
+        break;
+      case 7:
+        es->constantLight |= entityNum;
+        break;
+      case 8:
+        es->constantLight |= entityNum << GENTITYNUM_BITS;
+        break;
+      case 9:
+        es->constantLight |= entityNum << (GENTITYNUM_BITS * 2);
+    }
+  }
+}
+
+/*
+===============
+BG_UnpackZapTargets
+
+unpacks the 12 targets in an entityState_t
+===============
+*/
+void BG_UnpackZapTargets( entityState_t *es, int *creator, int *targets, int count )
+{
+  int i;
+  for( i = 0; i < count; i++ )
+  {
+    switch( i )
+    {
+      case 0:
+        if(creator)
+          *creator = es->misc & GENTITYNUM_MASK;
+        break;
+      case 1:
+        targets[ i - 1 ] = es->time & GENTITYNUM_MASK;
+        break;
+      case 2:
+        targets[ i - 1 ] = (es->time >> GENTITYNUM_BITS) & GENTITYNUM_MASK;
+        break;
+      case 3:
+        targets[ i - 1 ] = (es->time >> (GENTITYNUM_BITS * 2)) & GENTITYNUM_MASK;
+        break;
+      case 4:
+        targets[ i - 1 ] = es->time2 & GENTITYNUM_MASK;
+        break;
+      case 5:
+        targets[ i - 1 ] = (es->time2 >> GENTITYNUM_BITS) & GENTITYNUM_MASK;
+        break;
+      case 6:
+        targets[ i - 1 ] = (es->time2 >> (GENTITYNUM_BITS * 2)) & GENTITYNUM_MASK;
+        break;
+      case 7:
+        targets[ i - 1 ] = es->constantLight & GENTITYNUM_MASK;
+        break;
+      case 8:
+        targets[ i - 1 ] = (es->constantLight >> GENTITYNUM_BITS) & GENTITYNUM_MASK;
+        break;
+      case 9:
+        targets[ i - 1 ] = (es->constantLight >> (GENTITYNUM_BITS * 2)) & GENTITYNUM_MASK;
+        break;
+    }
+  }
+}
+/*
+===============
 BG_ParseCSVEquipmentList
 ===============
 */
diff -r 87f98d895296 -r 91f0a3d9f930 src/game/bg_pmove.c
--- a/src/game/bg_pmove.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/game/bg_pmove.c	Sat Jun 06 02:45:31 2009 +0800
@@ -106,16 +106,14 @@
 PM_StartWeaponAnim
 ===================
 */
-/* FIXME: need to backport weaponAnim
 static void PM_StartWeaponAnim( int anim )
 {
-  if( PM_Paralyzed( pm->ps->pm_type ) )
+  /*if( PM_Paralyzed( pm->ps->pm_type ) )
     return;
 
   pm->ps->weaponAnim = ( ( pm->ps->weaponAnim & ANIM_TOGGLEBIT ) ^ ANIM_TOGGLEBIT )
-    | anim;
+    | anim;*/
 }
-*/
 
 
 /*
@@ -190,15 +188,13 @@
 PM_ContinueWeaponAnim
 ===================
 */
-/* FIXME: weaponAnim needs backporting
 static void PM_ContinueWeaponAnim( int anim )
 {
-  if( ( pm->ps->weaponAnim & ~ANIM_TOGGLEBIT ) == anim )
+  /*if( ( pm->ps->weaponAnim & ~ANIM_TOGGLEBIT ) == anim )
     return;
 
-  PM_StartWeaponAnim( anim );
+  PM_StartWeaponAnim( anim );*/
 }
-*/
 
 /*
 ===================
@@ -2780,7 +2776,7 @@
   if( !( pm->ps->persistant[ PERS_STATE ] & PS_NONSEGMODEL ) )
   {
     PM_StartTorsoAnim( TORSO_DROP );
-    //PM_StartWeaponAnim( WANIM_DROP );
+    PM_StartWeaponAnim( WANIM_DROP );
   }
 }
 
@@ -2808,7 +2804,7 @@
   if( !( pm->ps->persistant[ PERS_STATE ] & PS_NONSEGMODEL ) )
   {
     PM_StartTorsoAnim( TORSO_RAISE );
-    //PM_StartWeaponAnim( WANIM_RAISE );
+    PM_StartWeaponAnim( WANIM_RAISE );
   }
 }
 
@@ -3053,9 +3049,13 @@
         PM_ContinueTorsoAnim( TORSO_STAND );
     }
 
+    PM_ContinueWeaponAnim( WANIM_IDLE );
+
     return;
   }
 
+  // start the animation even if out of ammo
+
   maxClips = BG_Weapon( pm->ps->weapon )->maxClips;
 
   // check for out of ammo
@@ -3106,6 +3106,7 @@
 
     //drop the weapon
     PM_StartTorsoAnim( TORSO_DROP );
+    PM_StartWeaponAnim( WANIM_RELOAD );
 
     pm->ps->weaponTime += BG_Weapon( pm->ps->weapon )->reloadTime;
     return;
@@ -3280,40 +3281,78 @@
         if( pm->ps->weaponstate == WEAPON_READY )
         {
           PM_StartTorsoAnim( TORSO_ATTACK );
+          PM_StartWeaponAnim( WANIM_ATTACK1 );
         }
         break;
 
       case WP_BLASTER:
         PM_StartTorsoAnim( TORSO_ATTACK2 );
+        PM_StartWeaponAnim( WANIM_ATTACK1 );
         break;
 
       default:
         PM_StartTorsoAnim( TORSO_ATTACK );
+        PM_StartWeaponAnim( WANIM_ATTACK1 );
         break;
     }
   }
   else
   {
-    if( pm->ps->weapon == WP_ALEVEL4 )
+    //hack to get random attack animations
+    int num = abs( pm->ps->commandTime ) % 3;
+
+    //FIXME: it would be nice to have these hard coded policies in
+    //       weapon.cfg
+    switch( pm->ps->weapon )
     {
-      //hack to get random attack animations
-      int num = abs( pm->ps->commandTime ) % 3;
+      case WP_ALEVEL1_UPG:
+      case WP_ALEVEL1:
+        if( attack1 )
+        {
+          num %= 6;
+          PM_ForceLegsAnim( NSPA_ATTACK1 );
+          PM_StartWeaponAnim( WANIM_ATTACK1 + num );
+        }
+        break;
 
-      if( num == 0 )
-        PM_ForceLegsAnim( NSPA_ATTACK1 );
-      else if( num == 1 )
-        PM_ForceLegsAnim( NSPA_ATTACK2 );
-      else if( num == 2 )
-        PM_ForceLegsAnim( NSPA_ATTACK3 );
-    }
-    else
-    {
-      if( attack1 )
-        PM_ForceLegsAnim( NSPA_ATTACK1 );
-      else if( attack2 )
-        PM_ForceLegsAnim( NSPA_ATTACK2 );
-      else if( attack3 )
-        PM_ForceLegsAnim( NSPA_ATTACK3 );
+      case WP_ALEVEL2_UPG:
+        if( attack2 )
+        {
+          PM_ForceLegsAnim( NSPA_ATTACK2 );
+          PM_StartWeaponAnim( WANIM_ATTACK7 );
+        }
+      case WP_ALEVEL2:
+        if( attack1 )
+        {
+          num %= 6;
+          PM_ForceLegsAnim( NSPA_ATTACK1 );
+          PM_StartWeaponAnim( WANIM_ATTACK1 + num );
+        }
+        break;
+
+      case WP_ALEVEL4:
+        num %= 3;
+        PM_ForceLegsAnim( NSPA_ATTACK1 + num );
+        PM_StartWeaponAnim( WANIM_ATTACK1 + num );
+        break;
+
+      default:
+        if( attack1 )
+        {
+          PM_ForceLegsAnim( NSPA_ATTACK1 );
+          PM_StartWeaponAnim( WANIM_ATTACK1 );
+        }
+        else if( attack2 )
+        {
+          PM_ForceLegsAnim( NSPA_ATTACK2 );
+          PM_StartWeaponAnim( WANIM_ATTACK2 );
+        }
+        else if( attack3 )
+        {
+          PM_ForceLegsAnim( NSPA_ATTACK3 );
+          PM_StartWeaponAnim( WANIM_ATTACK3 );
+        }
+        break;
     }
 
     pm->ps->torsoTimer = TIMER_ATTACK;
diff -r 87f98d895296 -r 91f0a3d9f930 src/game/bg_public.h
--- a/src/game/bg_public.h	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/game/bg_public.h	Sat Jun 06 02:45:31 2009 +0800
@@ -772,6 +772,11 @@
   WANIM_ATTACK1,
   WANIM_ATTACK2,
   WANIM_ATTACK3,
+  WANIM_ATTACK4,
+  WANIM_ATTACK5,
+  WANIM_ATTACK6,
+  WANIM_ATTACK7,
+  WANIM_ATTACK8,
 
   MAX_WEAPON_ANIMATIONS
 } weaponAnimNumber_t;
@@ -1114,6 +1119,9 @@
 qboolean  BG_HasEnergyWeapon( playerState_t *ps );
 qboolean  BG_PlayerCanChangeWeapon( playerState_t *ps );
 
+void BG_PackZapTargets( entityState_t *es, int creator, const int *entityNums, int count );
+void BG_UnpackZapTargets( entityState_t *es, int *creator, int *entityNums, int count );
+
 const buildableAttributes_t *BG_BuildableByName( const char *name );
 const buildableAttributes_t *BG_BuildableByEntityName( const char *name );
 const buildableAttributes_t *BG_Buildable( buildable_t buildable );
diff -r 87f98d895296 -r 91f0a3d9f930 src/game/g_client.c
--- a/src/game/g_client.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/game/g_client.c	Sat Jun 06 02:45:31 2009 +0800
@@ -1301,7 +1301,7 @@
   if ( Q_stricmp( Info_ValueForKey( userinfo, "cg_version" ), PRODUCT_NAME ) ) {
     trap_SendServerCommand( clientNum, "disconnect \"Your client is missing files.\n\n"
       "To enjoy our games in full colour and detail you need to enable autodownload (cl_allowDownload 1).\n"
-      "For a client with fast http-download visit tremfusion.tremforges.net\n\n"
+      "For a client with fast http-download visit http://www.tremfusion.net/\n\n"
       "Open your console and enter: /cl_allowDownload 1\n\"" );
     return;
   }
diff -r 87f98d895296 -r 91f0a3d9f930 src/game/g_weapon.c
--- a/src/game/g_weapon.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/game/g_weapon.c	Sat Jun 06 02:45:31 2009 +0800
@@ -1149,7 +1149,7 @@
     }
   }
 
-  return NULL;
+  return &g_entities[ ENTITYNUM_NONE ];
 }
 
 /*
@@ -1161,27 +1161,17 @@
 {
   int       j;
   gentity_t *effect = zap->effectChannel;
+  int       targets[MAX_ZAP_TARGETS];
 
   effect->s.eType = ET_LEV2_ZAP_CHAIN;
   effect->classname = "lev2zapchain";
   G_SetOrigin( effect, zap->creator->s.origin );
-  effect->s.misc = zap->creator->s.number;
-
-  effect->s.time = effect->s.time2 = effect->s.constantLight = -1;
-
   for( j = 0; j < zap->numTargets; j++ )
   {
     int number = zap->targets[ j ]->s.number;
-
-    switch( j )
-    {
-      case 0: effect->s.time = number;          break;
-      case 1: effect->s.time2 = number;         break;
-      case 2: effect->s.constantLight = number; break;
-      default:                                  break;
-    }
+    targets[ j ] = number;
   }
-
+  BG_PackZapTargets( &effect->s, zap->creator->s.number, targets, zap->numTargets);
   trap_LinkEntity( effect );
 }
 
@@ -1210,13 +1200,18 @@
 
       zap->targets[ 0 ] = target;
       zap->numTargets = 1;
-
-      for( j = 1; j < MAX_ZAP_TARGETS && zap->targets[ j - 1 ]; j++ )
+      G_Damage( target, creator , zap->creator, forward, target->s.origin,
+                LEVEL2_AREAZAP_DMG, DAMAGE_NO_KNOCKBACK | DAMAGE_NO_LOCDAMAGE, MOD_LEVEL2_ZAP );        
+      for( j = 1; j < MAX_ZAP_TARGETS; j++ )
       {
         zap->targets[ j ] = G_FindNewZapTarget( zap->targets[ 0 ] );
 
         if( zap->targets[ j ] )
+        {
           zap->numTargets++;
+          G_Damage( zap->targets[ j ], zap->targets[ 0 ] , zap->creator, forward, target->s.origin,
+                    LEVEL2_AREAZAP_DMG, DAMAGE_NO_KNOCKBACK | DAMAGE_NO_LOCDAMAGE, MOD_LEVEL2_ZAP );        
+        }
       }
 
       zap->effectChannel = G_Spawn( );
@@ -1263,7 +1258,7 @@
 
         }
       }
-
+      /*
       if( zap->numTargets )
       {
         damage = ceil( ( (float)msec / LEVEL2_AREAZAP_TIME ) *
@@ -1276,16 +1271,15 @@
         {
           gentity_t *source;
           gentity_t *target = zap->targets[ j ];
-          float     r = 1.0f / zap->numTargets;
           vec3_t    forward;
-
+          
           if( j == 0 )
             source = zap->creator;
           else
             source = zap->targets[ 0 ];
+          
 
-
-
+          
           VectorSubtract( target->s.origin, source->s.origin, forward );
           VectorNormalize( forward );
 
@@ -1297,7 +1291,7 @@
           }
         }
       }
-
+      */
       G_UpdateZapEffect( zap );
 
       zap->timeToLive -= msec;
diff -r 87f98d895296 -r 91f0a3d9f930 src/game/tremulous.h
--- a/src/game/tremulous.h	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/game/tremulous.h	Sat Jun 06 02:45:31 2009 +0800
@@ -130,7 +130,7 @@
 #define LEVEL4_TRAMPLE_DURATION        3000  // msec trample lasts on full charge
 //#define LEVEL4_TRAMPLE_STOP_PERCENTAGE 20    // removed from the end of trample when it isn't very useful
 #define LEVEL4_TRAMPLE_STOP_PENALTY    1     // charge lost per msec when stopped
-#define LEVEL4_TRAMPLE_REPEAT          75    // msec before a trample will rehit a player
+#define LEVEL4_TRAMPLE_REPEAT          100 // msec before a trample will rehit a player
 
 #define LEVEL4_CRUSH_DAMAGE_PER_V      0.5f  // damage per falling velocity
 #define LEVEL4_CRUSH_DAMAGE            120   // to players only
diff -r 87f98d895296 -r 91f0a3d9f930 src/libs/win32/libSDL.a
Binary file src/libs/win32/libSDL.a has changed
diff -r 87f98d895296 -r 91f0a3d9f930 src/libs/win32/libSDLmain.a
Binary file src/libs/win32/libSDLmain.a has changed
diff -r 87f98d895296 -r 91f0a3d9f930 src/master/messages.c
--- a/src/master/messages.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/master/messages.c	Sat Jun 06 02:45:31 2009 +0800
@@ -408,7 +408,7 @@
 	const size_t	headersize = strlen (packetheader);
 	char					packet[ MAX_PACKET_SIZE ];
 	char					challenge[ MAX_PACKET_SIZE ];
-	const char		*motd = "^2Latest version ^7of ^4Trem^3Fusion ^7is ^1" VERSION;
+	const char		*motd = "^3The latest version of Tremfusion is " VERSION;
 	size_t				packetind;
 	char					*value;
 	char		version[ 1024 ], renderer[ 1024 ];
diff -r 87f98d895296 -r 91f0a3d9f930 src/qcommon/cmd.c
--- a/src/qcommon/cmd.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/qcommon/cmd.c	Sat Jun 06 02:45:31 2009 +0800
@@ -61,6 +61,16 @@
  
 delayed_cmd_s delayed_cmd[MAX_DELAYED_COMMANDS]; 
 
+typedef struct cmd_function_s
+{
+	struct cmd_function_s	*next;
+	char					*name;
+	xcommand_t				function;
+	completionFunc_t	complete;
+} cmd_function_t;
+
+cmd_function_t *Cmd_FindCommand( const char *cmd_name );
+
 //=============================================================================
 
 /*
@@ -826,7 +836,7 @@
 	int 	v1;
 	int 	v2;
 
-	if (Cmd_Argc() == 3) {
+	if (Cmd_Argc() == 4) {
 		v1 = atoi(Cmd_Argv(2));
 		v2 = atoi(Cmd_Argv(3));
 		Cvar_SetValueLatched(Cmd_Argv(1), (int)(rand() / (float)RAND_MAX * (MAX(v1, v2) - MIN(v1, v2)) + MIN(v1, v2)));
@@ -1014,6 +1024,8 @@
 	// Modify/create an alias
 	if (Cmd_Argc() > 2)
 	{
+		cmd_function_t	*cmd;
+
 		// Crude protection from infinite loops
 		if (!strcmp(Cmd_Argv(2), name))
 		{
@@ -1021,6 +1033,14 @@
 			return;
 		}
 
+		// Don't allow overriding builtin commands
+		cmd = Cmd_FindCommand( name );
+		if (cmd && cmd->function != Cmd_RunAlias_f)
+		{
+			Com_Printf("Can't override a builtin function with an alias\n");
+			return;
+		}
+
 		// Create/update an alias
 		if (!alias)
 		{
@@ -1086,15 +1106,6 @@
 =============================================================================
 */
 
-typedef struct cmd_function_s
-{
-	struct cmd_function_s	*next;
-	char					*name;
-	xcommand_t				function;
-	completionFunc_t	complete;
-} cmd_function_t;
-
-
 typedef struct cmdContext_s
 {
 	int		argc;
diff -r 87f98d895296 -r 91f0a3d9f930 src/qcommon/common.c
--- a/src/qcommon/common.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/qcommon/common.c	Sat Jun 06 02:45:31 2009 +0800
@@ -165,6 +165,12 @@
 	va_end (argptr);
 	is_new_line = msg[strlen(msg) - 1] == '\n';
 
+	// hack to get skipnotify working with timestamps
+	if ( buf != msg && !Q_strncmp( buf, "[skipnotify]", 12 ) ) {
+		memmove(msg + 12, msg, 16);
+		memcpy(msg, "[skipnotify]", 12);
+	}
+
 	if ( rd_buffer ) {
 		if ((strlen (msg) + strlen(rd_buffer)) > (rd_buffersize - 1)) {
 			rd_flush(rd_buffer);
@@ -182,7 +188,10 @@
 #endif
 
 	// echo to dedicated console and early console
-	Sys_Print( msg );
+	if ( !Q_strncmp( msg, "[skipnotify]", 12 ) )
+		Sys_Print( msg + 12 );
+	else
+		Sys_Print( msg );
 
 	// logfile
 	if ( com_logfile && com_logfile->integer ) {
@@ -219,7 +228,10 @@
       opening_qconsole = qfalse;
 		}
 		if ( logfile && FS_Initialized()) {
-			FS_Write(msg, strlen(msg), logfile);
+			if ( !Q_strncmp( msg, "[skipnotify]", 12 ) )
+				FS_Write(msg + 12, strlen(msg + 12), logfile);
+			else
+				FS_Write(msg, strlen(msg), logfile);
 		}
 	}
 }
@@ -684,7 +696,7 @@
 
 	hash = 0;
 	for (i = 0; i < maxlen && string[i] != '\0'; i++) {
-		hash += string[i] * (119 + i);
+		hash += (string[i] == '%' || string[i] < 0 ? '.' : string[i]) * (119 + i);
 	}
 	hash = (hash ^ (hash >> 10) ^ (hash >> 20));
 	return hash;
@@ -3159,10 +3171,10 @@
 	matchCount = 0;
 	shortestMatch[ 0 ] = 0;
 
-	Cmd_AliasCompletion( FindMatches );
+	Cmd_DelayCompletion( FindMatches );
 
 	if( !Field_Complete( ) )
-		Cmd_AliasCompletion( PrintMatches );
+		Cmd_DelayCompletion( PrintMatches );
 }
 
 /*
diff -r 87f98d895296 -r 91f0a3d9f930 src/qcommon/files.c
--- a/src/qcommon/files.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/qcommon/files.c	Sat Jun 06 02:45:31 2009 +0800
@@ -217,8 +217,6 @@
 static	cvar_t		*fs_basepath;
 static	cvar_t		*fs_basegame;
 static	cvar_t		*fs_gamedirvar;
-static	cvar_t		*fs_extrapaks;
-static	cvar_t		*fs_restrict;
         cvar_t		*fs_autogen;
 static	searchpath_t	*fs_searchpaths;
 static	int			fs_readCount;			// total bytes read
@@ -261,10 +259,6 @@
 static int		fs_numServerPaks;
 static int		fs_serverPaks[MAX_SEARCH_PATHS];				// checksums
 
-// extra paks are on top of the search paths, overriding the current directory and bypassing pure
-static int		fs_numExtraPaks;
-static char		*fs_extraPaks[MAX_SEARCH_PATHS];				// pk3 names
-
 // only used for autodownload, to make sure the client has at least
 // all the pk3 files that are referenced at the server side
 static int		fs_numServerReferencedPaks;
@@ -294,7 +288,7 @@
 #ifndef DEDICATED
 	int i;
 	extern int cl_connectedToPureServer;
-	if ( fs_numServerPaks && ( cl_connectedToPureServer || fs_restrict->integer ) ) {
+	if ( fs_numServerPaks && cl_connectedToPureServer ) {
 		for ( i = 0 ; i < fs_numServerPaks ; i++ ) {
 			// FIXME: also use hashed file names
 			// NOTE TTimo: a pk3 with same checksum but different name would be validated too
@@ -303,12 +297,7 @@
 				return qtrue;		// on the aproved list
 			}
 		}
-		for ( i = 0 ; i < fs_numExtraPaks ; i++ ) {
-			if ( !Q_stricmp( pack->pakBasename, fs_extraPaks[i] ) ) {
-				return qtrue;		// on the aproved list
-			}
-		}
-		return qfalse;	// not on the pure server pak list or extra pak list
+		return qfalse;	// not on the pure server pak list
 	}
 #endif
 	return qtrue;
@@ -2769,84 +2758,6 @@
 }
 
 /*
-=====================
-FS_SetExtraPaks
-=====================
-*/
-static void FS_SetExtraPaks( const char *pakNames ) {
-	int		i, c;
-
-#ifndef DEDICATED
-	extern int cl_connectedToPureServer;
-	if ( cl_connectedToPureServer ) {
-		fs_numExtraPaks = 0;
-		return;
-	}
-#endif
-
-	Cmd_TokenizeString( pakNames );
-
-	c = Cmd_Argc();
-	if ( c > MAX_SEARCH_PATHS ) {
-		c = MAX_SEARCH_PATHS;
-	}
-
-	fs_numExtraPaks = c;
-
-	for ( i = 0 ; i < c ; i++ ) {
-		if (fs_extraPaks[i]) {
-			Z_Free(fs_extraPaks[i]);
-		}
-		fs_extraPaks[i] = CopyString( Cmd_Argv( i ) );
-	}
-}
-
-/*
-================
-FS_ReorderExtraPaks
-NOTE TTimo: the reordering that happens here is not reflected in the cvars (\cvarlist *pak*)
-  this can lead to misleading situations, see https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=540
-================
-*/
-static void FS_ReorderExtraPaks( void )
-{
-	searchpath_t *s;
-	int i;
-	searchpath_t **p_insert_index, // for linked list reordering
-		**p_previous; // when doing the scan
-
-	fs_unpureAllowed = qfalse;
-
-	// only relevant when we have a list of extra paks
-	if ( !fs_numExtraPaks )
-		return;
-
-	p_insert_index = &fs_searchpaths; // we insert in order at the beginning of the list
-	for ( i = 0 ; i < fs_numExtraPaks ; i++ ) {
-		p_previous = p_insert_index; // track the pointer-to-current-item
-		for (s = *p_insert_index; s; s = s->next) {
-			// the part of the list before p_insert_index has been sorted already
-			if ((s->pack && !Q_stricmp( fs_extraPaks[i], s->pack->pakBasename )) ||
-			    (s->dir && !Q_stricmp( fs_extraPaks[i], "." ))) {
-				// move this element to the insert list
-				*p_previous = s->next;
-				s->next = *p_insert_index;
-				*p_insert_index = s;
-				// increment insert list
-				p_insert_index = &s->next;
-
-				if (s->dir)
-					fs_unpureAllowed = qtrue;
-				else
-					s->pack->referenced |= FS_EXTRA_REF;
-				break; // iterate to next server pack
-			}
-			p_previous = &s->next;
-		}
-	}
-}
-
-/*
 ================
 FS_Startup
 ================
@@ -2874,8 +2785,6 @@
 	fs_homepath = Cvar_Get ("fs_homepath", homePath, CVAR_INIT|CVAR_PROTECTED );
 	fs_extrapath = Cvar_Get ("fs_extrapath", extraPath, CVAR_INIT|CVAR_PROTECTED );
 	fs_gamedirvar = Cvar_Get ("fs_game", "", CVAR_LATCH|CVAR_SYSTEMINFO );
-	fs_extrapaks = Cvar_Get ("fs_extrapaks", "", CVAR_ARCHIVE|CVAR_VM_CREATED );
-	fs_restrict = Cvar_Get ("fs_restrict", "0", CVAR_ARCHIVE );
 	fs_autogen = Cvar_Get ("fs_autogen", Q3CONFIG_CFG, CVAR_INIT );
 
 	// add search path elements in reverse priority order
@@ -2884,12 +2793,12 @@
 	}
 	// fs_homepath is somewhat particular to *nix systems, only add if relevant
 
-	#ifdef MACOS_X
+#ifdef MACOS_X
 	fs_apppath = Cvar_Get ("fs_apppath", Sys_DefaultAppPath(), CVAR_INIT|CVAR_PROTECTED );
 	// Make MacOSX also include the base path included with the .app bundle
 	if (fs_apppath->string[0])
 		FS_AddGameDirectory(fs_apppath->string, gameName);
-	#endif
+#endif
 
 	// NOTE: same filtering below for mods and basegame
 	if (fs_extrapath->string[0] && Q_stricmp(fs_extrapath->string,fs_homepath->string)) {
@@ -2904,11 +2813,11 @@
 		if (fs_basepath->string[0]) {
 			FS_AddGameDirectory(fs_basepath->string, fs_basegame->string);
 		}
-		#ifdef MACOS_X
+#ifdef MACOS_X
 		if (fs_apppath->string[0]) {
 			FS_AddGameDirectory(fs_apppath->string, fs_basegame->string);
 		}
-		#endif
+#endif
 		if (fs_extrapath->string[0] && Q_stricmp(fs_extrapath->string,fs_homepath->string)) {
 			FS_AddGameDirectory(fs_extrapath->string, fs_basegame->string);
 		}
@@ -2922,11 +2831,11 @@
 		if (fs_basepath->string[0]) {
 			FS_AddGameDirectory(fs_basepath->string, fs_gamedirvar->string);
 		}
-		#ifdef MACOS_X
+#ifdef MACOS_X
 		if (fs_apppath->string[0]) {
 			FS_AddGameDirectory(fs_apppath->string, fs_gamedirvar->string);
 		}
-		#endif
+#endif
 		if (fs_extrapath->string[0] && Q_stricmp(fs_extrapath->string,fs_homepath->string)) {
 			FS_AddGameDirectory(fs_extrapath->string, fs_gamedirvar->string);
 		}
@@ -2946,15 +2855,11 @@
 	// reorder the pure pk3 files according to server order
 	FS_ReorderPurePaks();
 
-	FS_SetExtraPaks( fs_extrapaks->string );
-	FS_ReorderExtraPaks();
-
 	// print the current search paths
 	if ( fs_debug->integer )
 		FS_Path_f();
 
 	fs_gamedirvar->modified = qfalse; // We just loaded, it's not modified
-	fs_extrapaks->modified = qfalse; // We just loaded, it's not modified
 
 	Com_DPrintf( "----------------------\n" );
 	Com_DPrintf( "%d files in pk3 files\n", fs_packFiles );
@@ -3284,8 +3189,6 @@
 	Com_StartupVariable( "fs_basegame" );
 	Com_StartupVariable( "fs_game" );
 	Com_StartupVariable( "fs_autogen" );
-	Com_StartupVariable( "fs_extrapaks" );
-	Com_StartupVariable( "fs_restrict" );
 
 	// try to start up normally
 	FS_Startup( BASEGAME );
@@ -3368,7 +3271,7 @@
 =================
 */
 qboolean FS_ConditionalRestart( int checksumFeed ) {
-	if( fs_gamedirvar->modified || fs_basegame->modified || fs_extrapaks->modified || checksumFeed != fs_checksumFeed ) {
+	if( fs_gamedirvar->modified || fs_basegame->modified || checksumFeed != fs_checksumFeed ) {
 		FS_Restart( checksumFeed );
 		return qtrue;
 	}
diff -r 87f98d895296 -r 91f0a3d9f930 src/qcommon/q_shared.h
--- a/src/qcommon/q_shared.h	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/qcommon/q_shared.h	Sat Jun 06 02:45:31 2009 +0800
@@ -30,7 +30,7 @@
 #define PRODUCT_NAME            "tremfusion"
 
 #ifdef _MSC_VER
-# define PRODUCT_VERSION          "0.99"
+# define PRODUCT_VERSION          "0.99r2"
 #endif
 
 #define CLIENT_WINDOW_TITLE       "Tremfusion " PRODUCT_VERSION
@@ -39,8 +39,9 @@
 
 #define MAX_TEAMNAME 32
 
-#define GAMENAME BASEGAME
-#define GAMENAME_FOR_MASTER GAMENAME
+#define BASEGAME "base"
+
+#define GAMENAME_FOR_MASTER "tremulous"
 
 #ifdef _MSC_VER
 
@@ -1030,6 +1031,8 @@
 
 #define	GENTITYNUM_BITS		10		// don't need to send any more
 #define	MAX_GENTITIES		(1<<GENTITYNUM_BITS)
+#define GENTITYNUM_MASK		(MAX_GENTITIES - 1)
+#define MAX_GENTITYNUM_PACK	10
 
 // entitynums are communicated with GENTITY_BITS, so any reserved
 // values that are going to be communcated over the net need to
diff -r 87f98d895296 -r 91f0a3d9f930 src/qcommon/qcommon.h
--- a/src/qcommon/qcommon.h	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/qcommon/qcommon.h	Sat Jun 06 02:45:31 2009 +0800
@@ -246,7 +246,7 @@
 #define MASTER_SERVER_NAME	"master.tremulous.net"
 #endif
 #ifndef MOTD_SERVER_NAME
-#define MOTD_SERVER_NAME	"master.tremforges.net"
+#define MOTD_SERVER_NAME	"master.tremfusion.net"
 #endif
 
 #define	PORT_MASTER			30710
@@ -575,8 +575,6 @@
 
 #define	MAX_FILE_HANDLES	64
 
-#define BASEGAME "base"
-
 #ifdef DEDICATED
 #	define Q3CONFIG_CFG "autogen_server.cfg"
 #else
diff -r 87f98d895296 -r 91f0a3d9f930 src/qcommon/qsse.c
--- a/src/qcommon/qsse.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/qcommon/qsse.c	Sat Jun 06 02:45:31 2009 +0800
@@ -202,136 +202,6 @@
 		*dst++ = *src++ + add;
 	}
 }
-void CopyArrayAndAddConstantShort_sse2(unsigned short *dst, unsigned *src, int add, int count)
-{
-	v8s	addVec, dataVec;
-	v4i	dataVec1, dataVec2, nextVec, mask;
-	
-	addVec = s8sInit(add);
-	
-	/* make dst is 4-byte aligned */
-	if ( ((int)dst & 0x02) && count > 0 ) {
-		*dst++ = (unsigned short)(*src++ + add);
-		count--;
-	}
-	
-	/* make dst is 8-byte aligned */
-	if ( ((int)dst & 0x04) && count > 1 ) {
-		*dst++ = (unsigned short)(*src++ + add);
-		*dst++ = (unsigned short)(*src++ + add);
-		count -= 2;
-	}
-	
-	/* make dst is 16-byte aligned */
-	if ( ((int)dst & 0x08) && count > 3 ) {
-		*dst++ = (unsigned short)(*src++ + add);
-		*dst++ = (unsigned short)(*src++ + add);
-		*dst++ = (unsigned short)(*src++ + add);
-		*dst++ = (unsigned short)(*src++ + add);
-		count -= 4;
-	}
-	
-	/* fast SSE2 loop */
-	switch ( 0x0c & (int)src ){
-        case 0x0:
-		while( count > 7 ) {
-			count -= 8;
-			dataVec1 = v4iLoadA( (int *)src );
-			src += 4;
-			dataVec2 = v4iLoadA( (int *)src );
-			src += 4;
-			dataVec = v8sAdd( v4i_to_v8s( dataVec1, dataVec2 ), addVec );
-			v8sStoreA( (short *)dst, dataVec );
-			dst += 8;
-		}
-		break;
-	case 0x4:
-		src += 3;
-		dataVec1 = v4iLoadA( (int *)(src - 4) );
-		dataVec2 = v4iLoadA( (int *)(src) );
-		src += 4;
-		mask = v4iInit( 0, -1, -1, -1 );
-		while( count > 7 ) {
-			count -= 8;
-
-			nextVec = v4iLoadA( (int *)src );
-			src += 4;
-			dataVec1 = v4iOr( v4iAnd( mask, dataVec1 ),
-					  v4iAndNot( mask, dataVec2 ) );
-			dataVec2 = v4iOr( v4iAnd( mask, dataVec2 ),
-					  v4iAndNot( mask, nextVec ) );
-			dataVec1 = _mm_shuffle_epi32( dataVec1, 0x39 );
-			dataVec2 = _mm_shuffle_epi32( dataVec2, 0x39 );
-			dataVec = v8sAdd( v4i_to_v8s( dataVec1, dataVec2 ), addVec );
-			v8sStoreA( (short *)dst, dataVec );
-			dst += 8;
-			
-			dataVec1 = nextVec;
-			dataVec2 = v4iLoadA( (int *)src );
-			src += 4;
-		}
-		src -= 7;
-		break;
-	case 0x8:
-		src += 2;
-		dataVec1 = v4iLoadA( (int *)(src - 4) );
-		dataVec2 = v4iLoadA( (int *)(src) );
-		src += 4;
-		mask = v4iInit( 0, 0, -1, -1 );
-		while( count > 7 ) {
-			count -= 8;
-
-			nextVec = v4iLoadA( (int *)src );
-			src += 4;
-			dataVec1 = v4iOr( v4iAnd( mask, dataVec1 ),
-					  v4iAndNot( mask, dataVec2 ) );
-			dataVec2 = v4iOr( v4iAnd( mask, dataVec2 ),
-					  v4iAndNot( mask, nextVec ) );
-			dataVec1 = _mm_shuffle_epi32( dataVec1, 0x4e );
-			dataVec2 = _mm_shuffle_epi32( dataVec2, 0x4e );
-			dataVec = v8sAdd( v4i_to_v8s( dataVec1, dataVec2 ), addVec );
-			v8sStoreA( (short *)dst, dataVec );
-			dst += 8;
-			
-			dataVec1 = nextVec;
-			dataVec2 = v4iLoadA( (int *)src );
-			src += 4;
-		}
-		src -= 6;
-		break;
-	case 0xc:
-		src += 1;
-		dataVec1 = v4iLoadA( (int *)(src - 4) );
-		dataVec2 = v4iLoadA( (int *)(src) );
-		src += 4;
-		mask = v4iInit( 0, 0, 0, -1 );
-		while( count > 7 ) {
-			count -= 8;
-			
-			nextVec = v4iLoadA( (int *)src );
-			src += 4;
-			dataVec1 = v4iOr( v4iAnd( mask, dataVec1 ),
-					  v4iAndNot( mask, dataVec2 ) );
-			dataVec2 = v4iOr( v4iAnd( mask, dataVec2 ),
-					  v4iAndNot( mask, nextVec ) );
-			dataVec1 = _mm_shuffle_epi32( dataVec1, 0x93 );
-			dataVec2 = _mm_shuffle_epi32( dataVec2, 0x93 );
-			dataVec = v8sAdd( v4i_to_v8s( dataVec1, dataVec2 ), addVec );
-			v8sStoreA( (short *)dst, dataVec );
-			dst += 8;
-			
-			dataVec1 = nextVec;
-			dataVec2 = v4iLoadA( (int *)src );
-			src += 4;
-		}
-		src -= 5;
-		break;
-    	}
-	/* copy any remaining data */
-	while( count-- > 0 ) {
-		*dst++ = *src++ + add;
-	}
-}
 #endif
 
 void CopyArrayAndAddConstant_sse1(unsigned *dst, unsigned *src, int add, int count)
@@ -382,72 +252,6 @@
 		*dst++ = *src++ + add;
 	}
 }
-void CopyArrayAndAddConstantShort_sse1(unsigned short *dst, unsigned *src, int add, int count)
-{
-	v4s	addVec, dataVec;
-	v2i	dataVec1, dataVec2, nextVec, mask;
-	
-	addVec = s4sInit(add);
-	
-	/* make dst is 4-byte aligned */
-	if ( ((int)dst & 0x02) && count > 0 ) {
-		*dst++ = (unsigned short)(*src++ + add);
-		count--;
-	}
-	
-	/* make dst is 8-byte aligned */
-	if ( ((int)dst & 0x04) && count > 1 ) {
-		*dst++ = (unsigned short)(*src++ + add);
-		*dst++ = (unsigned short)(*src++ + add);
-		count -= 2;
-	}
-	
-	/* fast MMX loop */
-	switch ( 0x04 & (int)src ){
-	case 0x0:
-		while( count > 3 ) {
-			count -= 4;
-			dataVec1 = v2iLoadA( (int *)src );
-			src += 2;
-			dataVec2 = v2iLoadA( (int *)src );
-			src += 2;
-			dataVec = v4sAdd( v2i_to_v4s( dataVec1, dataVec2 ), addVec );
-			v4sStoreA( (short *)dst, dataVec );
-			dst += 4;
-		}
-		break;
-	case 0x4:
-		src += 1;
-		dataVec1 = v2iLoadA( (int *)(src - 2) );
-		dataVec2 = v2iLoadA( (int *)(src) );
-		src += 2;
-		mask = v2iInit( 0, -1 );
-		while( count > 3 ) {
-			nextVec = v2iLoadA( (int *)src );
-			src += 2;
-			dataVec1 = v2iOr( v2iAnd( mask, dataVec1 ),
-					  v2iAndNot( mask, dataVec2 ) );
-			dataVec2 = v2iOr( v2iAnd( mask, dataVec2 ),
-					  v2iAndNot( mask, nextVec ) );
-			dataVec1 = _mm_unpacklo_pi32( _mm_unpackhi_pi32( dataVec1, dataVec1), dataVec1 );
-			dataVec2 = _mm_unpacklo_pi32( _mm_unpackhi_pi32( dataVec2, dataVec2), dataVec2 );
-			dataVec = v2i_to_v4s( dataVec1, dataVec2 );
-			dataVec = v2iAdd( dataVec, addVec );
-			v4sStoreA( (short *)dst, dataVec );
-			dst += 4;
-			
-			dataVec1 = nextVec;
-			dataVec2 = v2iLoadA( (int *)(src) );
-			src += 2;
-		}
-		src -= 3;
-		break;
-	}
-	/* copy any remaining data */
-	while( count-- > 0 ) {
-		*dst++ = *src++ + add;
-	}
-}
 
 
 /* sincos function */
diff -r 87f98d895296 -r 91f0a3d9f930 src/qcommon/qsse.h
--- a/src/qcommon/qsse.h	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/qcommon/qsse.h	Sat Jun 06 02:45:31 2009 +0800
@@ -824,10 +824,8 @@
 
 #if id386_sse >= 2
 void CopyArrayAndAddConstant_sse2(unsigned *dst, unsigned *src, int add, int count);
-void CopyArrayAndAddConstantShort_sse2(unsigned short *dst, unsigned *src, int add, int count);
 #endif
 void CopyArrayAndAddConstant_sse1(unsigned *dst, unsigned *src, int add, int count);
-void CopyArrayAndAddConstantShort_sse1(unsigned short *dst, unsigned *src, int add, int count);
 
 static ID_INLINE v4f
 vec3_to_v4f(const vec3_t vec) {
diff -r 87f98d895296 -r 91f0a3d9f930 src/qcommon/vm.c
--- a/src/qcommon/vm.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/qcommon/vm.c	Sat Jun 06 02:45:31 2009 +0800
@@ -395,6 +395,9 @@
 		return NULL;
 	}
 
+	// show where the qvm was loaded from
+	Cmd_ExecuteString( va( "which %s\n", filename ) );
+
 	if( LittleLong( header.h->vmMagic ) == VM_MAGIC_VER2 ) {
 		Com_DPrintf( "...which has vmMagic VM_MAGIC_VER2\n" );
 
diff -r 87f98d895296 -r 91f0a3d9f930 src/qcommon/vm_x86_64_assembler.c
--- a/src/qcommon/vm_x86_64_assembler.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/qcommon/vm_x86_64_assembler.c	Sat Jun 06 02:45:31 2009 +0800
@@ -30,6 +30,8 @@
 typedef unsigned int u32;
 typedef unsigned long u64;
 
+void Com_DPrintf(const char *fmt, ...) __attribute__ ((format (printf, 1, 2)));
+
 static char* out;
 static unsigned compiledOfs;
 static unsigned assembler_pass;
diff -r 87f98d895296 -r 91f0a3d9f930 src/renderer/qgl.h
--- a/src/renderer/qgl.h	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/renderer/qgl.h	Sat Jun 06 02:45:31 2009 +0800
@@ -29,9 +29,6 @@
 
 #include <SDL_opengl.h>
 
-// GL_EXT_draw_range_elements
-extern void (APIENTRYP qglDrawRangeElementsEXT) (GLenum mode, GLsizei count, GLuint start, GLuint end, GLenum type, const GLvoid *indices);
-
 extern void (APIENTRYP qglActiveTextureARB) (GLenum texture);
 extern void (APIENTRYP qglClientActiveTextureARB) (GLenum texture);
 extern void (APIENTRYP qglMultiTexCoord2fARB) (GLenum target, GLfloat s, GLfloat t);
@@ -39,148 +36,6 @@
 extern void (APIENTRYP qglLockArraysEXT) (GLint first, GLsizei count);
 extern void (APIENTRYP qglUnlockArraysEXT) (void);
 
-// GL_ARB_vertex_buffer_object
-extern void (APIENTRYP qglBindBufferARB) (GLenum target, GLuint buffer);
-extern void (APIENTRYP qglDeleteBuffersARB) (GLsizei n, const GLuint *buffers);
-extern void (APIENTRYP qglGenBuffersARB) (GLsizei n, GLuint *buffers);
-extern GLboolean (APIENTRYP qglIsBufferARB) (GLuint buffer);
-extern void (APIENTRYP qglBufferDataARB) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
-extern void (APIENTRYP qglBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
-extern void (APIENTRYP qglGetBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
-extern GLvoid *(APIENTRYP qglMapBufferARB) (GLenum target, GLenum access);
-extern GLboolean (APIENTRYP qglUnmapBufferARB) (GLenum target);
-extern void (APIENTRYP qglGetBufferParameterivARB) (GLenum target, GLenum pname, GLint *params);
-extern void (APIENTRYP qglGetBufferPointervARB) (GLenum target, GLenum pname, GLvoid **params);
-
-// GL_ARB_shader_objects
-extern GLvoid (APIENTRYP qglDeleteObjectARB) (GLhandleARB obj);
-extern GLhandleARB (APIENTRYP qglGetHandleARB) (GLenum pname);
-extern GLvoid (APIENTRYP qglDetachObjectARB) (GLhandleARB containerObj, GLhandleARB attachedObj);
-extern GLhandleARB (APIENTRYP qglCreateShaderObjectARB) (GLenum shaderType);
-extern GLvoid (APIENTRYP qglShaderSourceARB) (GLhandleARB shaderObj, GLsizei count, const GLcharARB **string,
-					      const GLint *length);
-extern GLvoid (APIENTRYP qglCompileShaderARB) (GLhandleARB shaderObj);
-extern GLhandleARB (APIENTRYP qglCreateProgramObjectARB) (void);
-extern GLvoid (APIENTRYP qglAttachObjectARB) (GLhandleARB containerObj, GLhandleARB obj);
-extern GLvoid (APIENTRYP qglLinkProgramARB) (GLhandleARB programObj);
-extern GLvoid (APIENTRYP qglUseProgramObjectARB) (GLhandleARB programObj);
-extern GLvoid (APIENTRYP qglValidateProgramARB) (GLhandleARB programObj);
-extern GLvoid (APIENTRYP qglUniform1fARB) (GLint location, GLfloat v0);
-extern GLvoid (APIENTRYP qglUniform2fARB) (GLint location, GLfloat v0, GLfloat v1);
-extern GLvoid (APIENTRYP qglUniform3fARB) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
-extern GLvoid (APIENTRYP qglUniform4fARB) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
-extern GLvoid (APIENTRYP qglUniform1iARB) (GLint location, GLint v0);
-extern GLvoid (APIENTRYP qglUniform2iARB) (GLint location, GLint v0, GLint v1);
-extern GLvoid (APIENTRYP qglUniform3iARB) (GLint location, GLint v0, GLint v1, GLint v2);
-extern GLvoid (APIENTRYP qglUniform4iARB) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
-extern GLvoid (APIENTRYP qglUniform1fvARB) (GLint location, GLsizei count, const GLfloat *value);
-extern GLvoid (APIENTRYP qglUniform2fvARB) (GLint location, GLsizei count, const GLfloat *value);
-extern GLvoid (APIENTRYP qglUniform3fvARB) (GLint location, GLsizei count, const GLfloat *value);
-extern GLvoid (APIENTRYP qglUniform4fvARB) (GLint location, GLsizei count, const GLfloat *value);
-extern GLvoid (APIENTRYP qglUniform1ivARB) (GLint location, GLsizei count, const GLint *value);
-extern GLvoid (APIENTRYP qglUniform2ivARB) (GLint location, GLsizei count, const GLint *value);
-extern GLvoid (APIENTRYP qglUniform3ivARB) (GLint location, GLsizei count, const GLint *value);
-extern GLvoid (APIENTRYP qglUniform4ivARB) (GLint location, GLsizei count, const GLint *value);
-extern GLvoid (APIENTRYP qglUniformMatrix2fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
-extern GLvoid (APIENTRYP qglUniformMatrix3fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
-extern GLvoid (APIENTRYP qglUniformMatrix4fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
-extern GLvoid (APIENTRYP qglGetObjectParameterfvARB) (GLhandleARB obj, GLenum pname, GLfloat *params);
-extern GLvoid (APIENTRYP qglGetObjectParameterivARB) (GLhandleARB obj, GLenum pname, GLint *params);
-extern GLvoid (APIENTRYP qglGetInfoLogARB) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
-extern GLvoid (APIENTRYP qglGetAttachedObjectsARB) (GLhandleARB containerObj, GLsizei maxCount, GLsizei *count,
-						    GLhandleARB *obj);
-extern GLint (APIENTRYP qglGetUniformLocationARB) (GLhandleARB programObj, const GLcharARB *name);
-extern GLvoid (APIENTRYP qglGetActiveUniformARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
-						  GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
-extern GLvoid (APIENTRYP qglGetUniformfvARB) (GLhandleARB programObj, GLint location, GLfloat *params);
-extern GLvoid (APIENTRYP qglGetUniformivARB) (GLhandleARB programObj, GLint location, GLint *params);
-extern GLvoid (APIENTRYP qglGetShaderSourceARB) (GLhandleARB obj, GLsizei maxLength, GLsizei *length,
-						 GLcharARB *source);
-
-// GL_ARB_vertex_shader
-extern GLvoid (APIENTRYP qglVertexAttrib1fARB) (GLuint index, GLfloat v0);
-extern GLvoid (APIENTRYP qglVertexAttrib1sARB) (GLuint index, GLshort v0);
-extern GLvoid (APIENTRYP qglVertexAttrib1dARB) (GLuint index, GLdouble v0);
-extern GLvoid (APIENTRYP qglVertexAttrib2fARB) (GLuint index, GLfloat v0, GLfloat v1);
-extern GLvoid (APIENTRYP qglVertexAttrib2sARB) (GLuint index, GLshort v0, GLshort v1);
-extern GLvoid (APIENTRYP qglVertexAttrib2dARB) (GLuint index, GLdouble v0, GLdouble v1);
-extern GLvoid (APIENTRYP qglVertexAttrib3fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2);
-extern GLvoid (APIENTRYP qglVertexAttrib3sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2);
-extern GLvoid (APIENTRYP qglVertexAttrib3dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
-extern GLvoid (APIENTRYP qglVertexAttrib4fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
-extern GLvoid (APIENTRYP qglVertexAttrib4sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3);
-extern GLvoid (APIENTRYP qglVertexAttrib4dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
-extern GLvoid (APIENTRYP qglVertexAttrib4NubARB) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
-extern GLvoid (APIENTRYP qglVertexAttrib1fvARB) (GLuint index, GLfloat *v);
-extern GLvoid (APIENTRYP qglVertexAttrib1svARB) (GLuint index, GLshort *v);
-extern GLvoid (APIENTRYP qglVertexAttrib1dvARB) (GLuint index, GLdouble *v);
-extern GLvoid (APIENTRYP qglVertexAttrib2fvARB) (GLuint index, GLfloat *v);
-extern GLvoid (APIENTRYP qglVertexAttrib2svARB) (GLuint index, GLshort *v);
-extern GLvoid (APIENTRYP qglVertexAttrib2dvARB) (GLuint index, GLdouble *v);
-extern GLvoid (APIENTRYP qglVertexAttrib3fvARB) (GLuint index, GLfloat *v);
-extern GLvoid (APIENTRYP qglVertexAttrib3svARB) (GLuint index, GLshort *v);
-extern GLvoid (APIENTRYP qglVertexAttrib3dvARB) (GLuint index, GLdouble *v);
-extern GLvoid (APIENTRYP qglVertexAttrib4fvARB) (GLuint index, GLfloat *v);
-extern GLvoid (APIENTRYP qglVertexAttrib4svARB) (GLuint index, GLshort *v);
-extern GLvoid (APIENTRYP qglVertexAttrib4dvARB) (GLuint index, GLdouble *v);
-extern GLvoid (APIENTRYP qglVertexAttrib4ivARB) (GLuint index, GLint *v);
-extern GLvoid (APIENTRYP qglVertexAttrib4bvARB) (GLuint index, GLbyte *v);
-extern GLvoid (APIENTRYP qglVertexAttrib4ubvARB) (GLuint index, GLubyte *v);
-extern GLvoid (APIENTRYP qglVertexAttrib4usvARB) (GLuint index, GLushort *v);
-extern GLvoid (APIENTRYP qglVertexAttrib4uivARB) (GLuint index, GLuint *v);
-extern GLvoid (APIENTRYP qglVertexAttrib4NbvARB) (GLuint index, const GLbyte *v);
-extern GLvoid (APIENTRYP qglVertexAttrib4NsvARB) (GLuint index, const GLshort *v);
-extern GLvoid (APIENTRYP qglVertexAttrib4NivARB) (GLuint index, const GLint *v);
-extern GLvoid (APIENTRYP qglVertexAttrib4NubvARB) (GLuint index, const GLubyte *v);
-extern GLvoid (APIENTRYP qglVertexAttrib4NusvARB) (GLuint index, const GLushort *v);
-extern GLvoid (APIENTRYP qglVertexAttrib4NuivARB) (GLuint index, const GLuint *v);
-extern GLvoid (APIENTRYP qglVertexAttribPointerARB) (GLuint index, GLint size, GLenum type, GLboolean normalized,
-						     GLsizei stride, const GLvoid *pointer);
-extern GLvoid (APIENTRYP qglEnableVertexAttribArrayARB) (GLuint index);
-extern GLvoid (APIENTRYP qglDisableVertexAttribArrayARB) (GLuint index);
-extern GLvoid (APIENTRYP qglBindAttribLocationARB) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
-extern GLvoid (APIENTRYP qglGetActiveAttribARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
-						 GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
-extern GLint (APIENTRYP qglGetAttribLocationARB) (GLhandleARB programObj, const GLcharARB *name);
-extern GLvoid (APIENTRYP qglGetVertexAttribdvARB) (GLuint index, GLenum pname, GLdouble *params);
-extern GLvoid (APIENTRYP qglGetVertexAttribfvARB) (GLuint index, GLenum pname, GLfloat *params);
-extern GLvoid (APIENTRYP qglGetVertexAttribivARB) (GLuint index, GLenum pname, GLint *params);
-extern GLvoid (APIENTRYP qglGetVertexAttribPointervARB) (GLuint index, GLenum pname, GLvoid **pointer);
-
-// GL_ARB_framebuffer_object
-extern GLboolean (APIENTRYP qglIsRenderbuffer) (GLuint renderbuffer);
-extern GLvoid (APIENTRYP qglBindRenderbuffer) (GLenum target, GLuint renderbuffer);
-extern GLvoid (APIENTRYP qglDeleteRenderbuffers) (GLsizei n, const GLuint *renderbuffers);
-extern GLvoid (APIENTRYP qglGenRenderbuffers) (GLsizei n, GLuint *renderbuffers);
-extern GLvoid (APIENTRYP qglRenderbufferStorage) (GLenum target, GLenum internalformat,
-						  GLsizei width, GLsizei height);
-extern GLvoid (APIENTRYP qglRenderbufferStorageMultisample) (GLenum target, GLsizei samples,
-							     GLenum internalformat,
-							     GLsizei width, GLsizei height);
-extern GLvoid (APIENTRYP qglGetRenderbufferParameteriv) (GLenum target, GLenum pname, GLint *params);
-extern GLboolean (APIENTRYP qglIsFramebuffer) (GLuint framebuffer);
-extern GLvoid (APIENTRYP qglBindFramebuffer) (GLenum target, GLuint framebuffer);
-extern GLvoid (APIENTRYP qglDeleteFramebuffers) (GLsizei n, const GLuint *framebuffers);
-extern GLvoid (APIENTRYP qglGenFramebuffers) (GLsizei n, GLuint *framebuffers);
-extern GLenum (APIENTRYP qglCheckFramebufferStatus) (GLenum target);
-extern GLvoid (APIENTRYP qglFramebufferTexture1D) (GLenum target, GLenum attachment,
-						   GLenum textarget, GLuint texture, GLint level);
-extern GLvoid (APIENTRYP qglFramebufferTexture2D) (GLenum target, GLenum attachment,
-						   GLenum textarget, GLuint texture, GLint level);
-extern GLvoid (APIENTRYP qglFramebufferTexture3D) (GLenum target, GLenum attachment,
-						   GLenum textarget, GLuint texture,
-						   GLint level, GLint layer);
-extern GLvoid (APIENTRYP qglFramebufferTextureLayer) (GLenum target, GLenum attachment,
-						      GLuint texture, GLint level, GLint layer);
-extern GLvoid (APIENTRYP qglFramebufferRenderbuffer) (GLenum target, GLenum attachment,
-						      GLenum renderbuffertarget, GLuint renderbuffer);
-extern GLvoid (APIENTRYP qglGetFramebufferAttachmentParameteriv) (GLenum target, GLenum attachment,
-								  GLenum pname, GLint *params);
-extern GLvoid (APIENTRYP qglBlitFramebuffer) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
-					      GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
-					      GLbitfield mask, GLenum filter);
-extern GLvoid (APIENTRYP qglGenerateMipmap) (GLenum target);
-
 
 //===========================================================================
 
diff -r 87f98d895296 -r 91f0a3d9f930 src/renderer/tr_animation.c
--- a/src/renderer/tr_animation.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/renderer/tr_animation.c	Sat Jun 06 02:45:31 2009 +0800
@@ -62,13 +62,12 @@
 RB_SurfaceAnim
 ==============
 */
-void RB_SurfaceAnim( surfaceType_t *surf ) {
-	md4Surface_t		*surface = (md4Surface_t *)surf;
+void RB_SurfaceAnim( md4Surface_t *surface ) {
 	int				i, j, k;
 	float			frontlerp, backlerp;
 	int				*triangles;
 	int				indexes;
-	int				baseVertex;
+	int				baseIndex, baseVertex;
 	int				numVerts;
 	md4Vertex_t		*v;
 	md4Bone_t		bones[MD4_MAX_BONES];
@@ -77,10 +76,7 @@
 	md4Frame_t		*frame;
 	md4Frame_t		*oldFrame;
 	int				frameSize;
-	GLuint			*indexPtr;
-	GLushort		*indexPtrShort;
-	vec4_t			*xyzPtr, *normalPtr;
-	vec2_t			*texCoordPtr;
+
 
 	if (  backEnd.currentEntity->e.oldframe == backEnd.currentEntity->e.frame ) {
 		backlerp = 0;
@@ -98,36 +94,17 @@
 	oldFrame = (md4Frame_t *)((byte *)header + header->ofsFrames + 
 			backEnd.currentEntity->e.oldframe * frameSize );
 
-	if ( !tess.indexPtr ) {
-		/* only calculate number of vertices/indexes */
-		tess.numIndexes += surface->numTriangles * 3;
-		tess.numVertexes += surface->numVerts;
-		return;
-	}
-
 	RB_CheckOverflow( surface->numVerts, surface->numTriangles * 3 );
 
-	indexPtr = ptrPlusOffset(tess.indexPtr, tess.indexInc * tess.numIndexes);
-	xyzPtr = ptrPlusOffset(tess.xyzPtr, tess.xyzInc * tess.numVertexes);
-	normalPtr = ptrPlusOffset(tess.normalPtr, tess.normalInc * tess.numVertexes);
-	texCoordPtr = ptrPlusOffset(tess.texCoordPtr, tess.texCoordInc * tess.numVertexes);
-
 	triangles = (int *) ((byte *)surface + surface->ofsTriangles);
 	indexes = surface->numTriangles * 3;
+	baseIndex = tess.numIndexes;
 	baseVertex = tess.numVertexes;
-
-	if ( tess.indexInc == sizeof(GLushort) ) {
-		indexPtrShort = (GLushort *)indexPtr;
-		for (j = 0 ; j < indexes ; j++) {
-			*indexPtrShort++ = (GLushort)(baseVertex + triangles[j]);
-		}
-	} else {
-		for (j = 0 ; j < indexes ; j++) {
-			*indexPtr++ = baseVertex + triangles[j];
-		}
+	for (j = 0 ; j < indexes ; j++) {
+		tess.indexes[baseIndex + j] = baseIndex + triangles[j];
 	}
 	tess.numIndexes += indexes;
-	
+
 	//
 	// lerp all the needed bones
 	//
@@ -152,11 +129,11 @@
 	//v = (md4Vertex_t *) ((byte *)surface + surface->ofsVerts + 12);
 	v = (md4Vertex_t *) ((byte *)surface + surface->ofsVerts);
 	for ( j = 0; j < numVerts; j++ ) {
-		vec4_t	tempVert, tempNormal;
+		vec3_t	tempVert, tempNormal;
 		md4Weight_t	*w;
 
-		VectorClear( tempVert ); tempVert[3] = 0.0;
-		VectorClear( tempNormal ); tempNormal[3] = 0.0;
+		VectorClear( tempVert );
+		VectorClear( tempNormal );
 		w = v->weights;
 		for ( k = 0 ; k < v->numWeights ; k++, w++ ) {
 			bone = bonePtr + w->boneIndex;
@@ -170,14 +147,16 @@
 			tempNormal[2] += w->boneWeight * DotProduct( bone->matrix[2], v->normal );
 		}
 
-		Vector4Copy( *xyzPtr, tempVert );
-		xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
+		tess.xyz[baseVertex + j][0] = tempVert[0];
+		tess.xyz[baseVertex + j][1] = tempVert[1];
+		tess.xyz[baseVertex + j][2] = tempVert[2];
 
-		Vector4Copy( *normalPtr, tempNormal );
-		normalPtr = ptrPlusOffset(normalPtr, tess.normalInc);
+		tess.normal[baseVertex + j][0] = tempNormal[0];
+		tess.normal[baseVertex + j][1] = tempNormal[1];
+		tess.normal[baseVertex + j][2] = tempNormal[2];
 
-		Vector2Copy( *texCoordPtr, v->texCoords );
-		texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
+		tess.texCoords[baseVertex + j][0][0] = v->texCoords[0];
+		tess.texCoords[baseVertex + j][0][1] = v->texCoords[1];
 
 		// FIXME
 		// This makes TFC's skeletons work.  Shouldn't be necessary anymore, but left
@@ -466,9 +445,8 @@
 RB_MDRSurfaceAnim
 ==============
 */
-void RB_MDRSurfaceAnim( surfaceType_t *surf )
+void RB_MDRSurfaceAnim( md4Surface_t *surface )
 {
-	md4Surface_t *surface = (md4Surface_t *) surf;
 	int				i, j, k;
 	float			frontlerp, backlerp;
 	int				*triangles;
diff -r 87f98d895296 -r 91f0a3d9f930 src/renderer/tr_backend.c
--- a/src/renderer/tr_backend.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/renderer/tr_backend.c	Sat Jun 06 02:45:31 2009 +0800
@@ -83,20 +83,6 @@
 		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE1_ARB )\n" );
 		qglClientActiveTextureARB( GL_TEXTURE1_ARB );
 		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE1_ARB )\n" );
-	}
-	else if ( unit == 2 )
-	{
-		qglActiveTextureARB( GL_TEXTURE2_ARB );
-		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE2_ARB )\n" );
-		qglClientActiveTextureARB( GL_TEXTURE2_ARB );
-		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE2_ARB )\n" );
-	}
-	else if ( unit == 3 )
-	{
-		qglActiveTextureARB( GL_TEXTURE3_ARB );
-		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE3_ARB )\n" );
-		qglClientActiveTextureARB( GL_TEXTURE3_ARB );
-		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE3_ARB )\n" );
 	} else {
 		ri.Error( ERR_DROP, "GL_SelectTexture: unit = %i", unit );
 	}
@@ -403,26 +389,6 @@
 
 
 /*
-** GL_State
-**
-** This routine is responsible for setting the most commonly changed state
-** in Q3.
-*/
-void GL_VBO( GLuint vbo, GLuint ibo )
-{
-	if ( glState.currentVBO != vbo ) {
-		glState.currentVBO = vbo;
-		qglBindBufferARB (GL_ARRAY_BUFFER_ARB, vbo );
-	}
-
-	if ( glState.currentIBO != ibo ) {
-		glState.currentIBO = ibo;
-		qglBindBufferARB (GL_ELEMENT_ARRAY_BUFFER_ARB, ibo );
-	}
-}
-
-
-/*
 ================
 RB_Hyperspace
 
@@ -544,49 +510,6 @@
 }
 
 
-/*
-==================
-findShaderVBO
-==================
-*/
-static int
-findShaderVBO( shader_t *shader, int VBOkey ) {
-	int		i;
-	vboInfo_t	vbo;
-	
-	if ( shader->VBOs[0].key == VBOkey )
-		return qtrue;
-
-	if ( shader->VBOs[0].key == 0 )
-		return qfalse;
-
-	for ( i = 1; i < MAX_VBOS_PER_SHADER; i++ ) {
-		if ( shader->VBOs[i].key == 0 )
-			return qfalse;
-		
-		if ( shader->VBOs[i].key == VBOkey ) {
-			// move found key to front
-			vbo = shader->VBOs[i];
-			memmove( &(shader->VBOs[1]), &(shader->VBOs[0]), sizeof(vboInfo_t) * i );
-			shader->VBOs[0] = vbo;
-			return qtrue;
-		}
-	}
-	return qfalse;
-}
-
-
-static void newShaderVBO( shader_t *shader, int VBOkey )
-{
-	// discard last key
-	if ( shader->VBOs[MAX_VBOS_PER_SHADER - 1].key != 0 ) {
-		// free stored VBO and IBO
-		qglDeleteBuffersARB(1, &shader->VBOs[MAX_VBOS_PER_SHADER - 1].vbo);
-		qglDeleteBuffersARB(1, &shader->VBOs[MAX_VBOS_PER_SHADER - 1].ibo);
-	}
-	memmove( &(shader->VBOs[1]), &(shader->VBOs[0]), sizeof(vboInfo_t) * (MAX_VBOS_PER_SHADER - 1) );
-}
-
 #define	MAC_EVENT_PUMP_MSEC		5
 
 /*
@@ -600,12 +523,11 @@
 	int				entityNum, oldEntityNum;
 	int				dlighted, oldDlighted;
 	qboolean		depthRange, oldDepthRange, isCrosshair, wasCrosshair;
-	int				i, j;
+	int				i;
 	drawSurf_t		*drawSurf;
 	int				oldSort;
 	float			originalTime;
-	int sortMask = -1 << QSORT_ENTITYNUM_SHIFT; // mask out fog and dlight bits
-	
+
 	// save original time for entity shader offsets
 	originalTime = backEnd.refdef.floatTime;
 
@@ -625,23 +547,6 @@
 
 	backEnd.pc.c_surfaces += numDrawSurfs;
 
-	tess.indexPtr = tess.indexes;
-	tess.indexInc = sizeof(GLuint);
-	tess.xyzPtr = tess.xyz;
-	tess.xyzInc = sizeof(vec4_t);
-	tess.normalPtr = tess.normal;
-	tess.normalInc = sizeof(vec4_t);
-	tess.texCoordPtr = (vec2_t *)&(tess.texCoords[0][0]);
-	tess.texCoordInc = 2*sizeof(vec2_t);
-	tess.texCoord2Ptr = tess.texCoordPtr + 1;
-	tess.texCoord2Inc = 2*sizeof(vec2_t);
-	tess.vertexColorPtr = tess.vertexColors;
-	tess.vertexColorInc = sizeof(color4ub_t);
-	tess.vertexDlightBitPtr = tess.vertexDlightBits;
-	tess.vertexDlightBitInc = sizeof(int);
-	tess.maxIndexes = SHADER_MAX_INDEXES;
-	tess.maxVertexes = SHADER_MAX_VERTEXES;
-
 	for (i = 0, drawSurf = drawSurfs ; i < numDrawSurfs ; i++, drawSurf++) {
 		if ( drawSurf->sort == oldSort ) {
 			// fast path, same as previous sort
@@ -761,186 +666,8 @@
 			oldEntityNum = entityNum;
 		}
 
-		// look if we have a VBO for this shader/entity
-		int VBOkey = 0;
-		
-		if ( shader->useVBO && !dlighted && !fogNum ) {
-			if (entityNum == ENTITYNUM_WORLD) {
-				if ( tr.viewCluster >= 0 ) {
-					VBOkey = VBOKEY_VIS | (tr.viewCluster & VBOKEY_IDXMASK);
-				}
-			} else {
-				trRefEntity_t	*ent = backEnd.currentEntity;
-				if ( ent->e.reType == RT_MODEL ) {
-					model_t *model = R_GetModelByHandle( ent->e.hModel );
-					if ( model->type == MOD_BRUSH ) {
-						VBOkey = VBOKEY_MODEL | (ent->e.hModel & VBOKEY_IDXMASK);
-					} else if ( model->type == MOD_MESH &&
-						ent->e.frame == ent->e.oldframe ) {
-						// combine hModel and frame number into key
-						// allows 65536 models with 256 frames
-						VBOkey = VBOKEY_MD3 | (ent->e.hModel << 8) | ent->e.frame;
-					}
-				}
-			}
-		}
-		
-		if ( VBOkey > 0 ) {
-			if ( !findShaderVBO( shader, VBOkey ) ) {
-				// create new VBO
-				byte *vertexData, *indexData;
-				vboInfo_t *vbo;
-				
-				// count only
-				tess.indexPtr = NULL;
-				for ( j = 0; j < numDrawSurfs - i &&
-					((drawSurf+j)->sort & sortMask) == (oldSort & sortMask); j++ ) {
-					rb_surfaceTable[ *(drawSurf+j)->surface ]( (drawSurf+j)->surface );
-				}
-				
-				if (tess.numVertexes < 32 && tess.numIndexes < 32) {
-					// skip tiny VBOs
-					tess.numVertexes = tess.numIndexes = 0;
-					tess.indexPtr = tess.indexes;
-					tess.indexInc = sizeof(GLuint);
-					rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
-					continue;
-				}
-
-				newShaderVBO( shader, VBOkey );
-				vbo = &(shader->VBOs[0]);
-
-				// allocate VBOs
-				qglGenBuffersARB(1, &vbo->vbo);
-				qglGenBuffersARB(1, &vbo->ibo);
-				
-				GL_VBO( vbo->vbo, vbo->ibo );
-				vbo->vertexSize = sizeof(vec4_t);
-				if ( shader->needsST1 )
-					vbo->vertexSize += sizeof(vec2_t);
-				if ( shader->needsST2 )
-					vbo->vertexSize += sizeof(vec2_t);
-				if ( shader->needsNormal )
-					vbo->vertexSize += sizeof(vec3_t);
-				if ( shader->needsColor )
-					vbo->vertexSize += sizeof(color4ub_t);
-				vbo->vertexSize = (vbo->vertexSize + 31) & -32;
-
-				qglBufferDataARB(GL_ARRAY_BUFFER_ARB,
-						 tess.numVertexes * vbo->vertexSize,
-						 NULL, GL_STATIC_DRAW_ARB);
-				
-				if ( tess.numVertexes > 65536 )
- 					qglBufferDataARB(GL_ELEMENT_ARRAY_BUFFER_ARB,
-							 sizeof(GLuint) * tess.numIndexes,
-							 NULL, GL_STATIC_DRAW_ARB);
-				else
-					qglBufferDataARB(GL_ELEMENT_ARRAY_BUFFER_ARB,
-							 sizeof(GLushort) * tess.numIndexes,
-							 NULL, GL_STATIC_DRAW_ARB);
-				
-				vertexData = qglMapBufferARB(GL_ARRAY_BUFFER_ARB, GL_WRITE_ONLY_ARB);
-				indexData = qglMapBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, GL_WRITE_ONLY_ARB);
-				
-				// setup tess to write into VBO
-				tess.xyzPtr = (vec4_t *)(vertexData);
-				tess.xyzInc = VBO_inc(shader, vbo);
-				vertexData += sizeof(vec4_t);
-				
-				if ( shader->needsST1 ) {
-					tess.texCoordPtr = (vec2_t *)vertexData;
-					tess.texCoordInc = VBO_inc(shader, vbo);
-					vertexData += sizeof(vec2_t);
-				} else {
-					tess.texCoordPtr = (vec2_t *)&vec4Scratch;
-					tess.texCoordInc = 0;
-				}
-				
-				if ( shader->needsST2 ) {
-					tess.texCoord2Ptr = (vec2_t *)vertexData;
-					tess.texCoord2Inc = VBO_inc(shader, vbo);
-					vertexData += sizeof(vec2_t);
-				} else {
-					tess.texCoord2Ptr = (vec2_t *)&vec4Scratch;
-					tess.texCoord2Inc = 0;
-				}
-				
-				if ( shader->needsNormal ) {
-					tess.normalPtr = (vec4_t *)vertexData;
-					tess.normalInc = VBO_inc(shader,vbo);
-					vertexData += sizeof(vec3_t);
-				} else {
-					tess.normalPtr = &vec4Scratch;
-					tess.normalInc = 0;
-				}
-
-				if ( shader->needsColor ) {
-					tess.vertexColorPtr = (color4ub_t *)vertexData;
-					tess.vertexColorInc = VBO_inc(shader,vbo);
-					vertexData += sizeof(color4ub_t);
-				} else {
-					tess.vertexColorPtr = (color4ub_t *)&vec4Scratch;
-					tess.vertexColorInc = 0;
-				}
-
-				tess.vertexDlightBitPtr = (int *)&vec4Scratch;
-				tess.vertexDlightBitInc = 0;
-
-				tess.indexPtr = (GLuint *)(indexData);
-				tess.indexInc = tess.numVertexes > 65536 ? sizeof(GLuint) : sizeof(GLushort);
-				tess.maxIndexes = tess.numIndexes+1;
-				tess.maxVertexes = tess.numVertexes+1;
-
-				tess.numVertexes = tess.numIndexes = 0;
-
-				// ignore change of dlights/fog
-				while ( i < numDrawSurfs &&
-					(drawSurf->sort & sortMask) == (oldSort & sortMask) ) {
-					rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
-					i++, drawSurf++;
-				}
-				
-				qglUnmapBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB);
-				qglUnmapBufferARB(GL_ARRAY_BUFFER_ARB);
-
-				shader->VBOs[0].key = VBOkey;
-				shader->VBOs[0].numVertexes = tess.numVertexes;
-				shader->VBOs[0].numIndexes = tess.numIndexes;
-
-				// setup tess to write into memory
-				tess.indexPtr = tess.indexes;
-				tess.indexInc = sizeof(GLuint);
-				tess.xyzPtr = tess.xyz;
-				tess.xyzInc = sizeof(vec4_t);
-				tess.normalPtr = tess.normal;
-				tess.normalInc = sizeof(vec4_t);
-				tess.texCoordPtr = (vec2_t *)(&tess.texCoords[0][0]);
-				tess.texCoordInc = 2*sizeof(vec2_t);
-				tess.texCoord2Ptr = tess.texCoordPtr + 1;
-				tess.texCoord2Inc = 2*sizeof(vec2_t);
-				tess.vertexColorPtr = tess.vertexColors;
-				tess.vertexColorInc = sizeof(color4ub_t);
-				tess.vertexDlightBitPtr = tess.vertexDlightBits;
-				tess.vertexDlightBitInc = sizeof(int);
-				tess.maxIndexes = SHADER_MAX_INDEXES;
-				tess.maxVertexes = SHADER_MAX_VERTEXES;
-				tess.numIndexes = 0;
-				tess.numVertexes = 0;
-			} else {
-				// VBO exists, skip to next sort key
-				while ( i < numDrawSurfs && drawSurf->sort == oldSort ) {
-					i++;
-					drawSurf++;
-				}
-			}
-			i--; drawSurf--;
-			// add VBO to draw list
-			tess.renderVBO = &(shader->VBOs[0]);
-			continue;
-		} else {
-			// add the triangles for this surface
-			rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
-		}
+		// add the triangles for this surface
+		rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
 	}
 
 	backEnd.refdef.floatTime = originalTime;
@@ -950,8 +677,6 @@
 		RB_EndSurface();
 	}
 
-	GL_VBO( 0, 0 );
-
 	// go back to the world modelview matrix
 	qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
 	if ( depthRange ) {
diff -r 87f98d895296 -r 91f0a3d9f930 src/renderer/tr_bsp.c
--- a/src/renderer/tr_bsp.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/renderer/tr_bsp.c	Sat Jun 06 02:45:31 2009 +0800
@@ -39,7 +39,6 @@
 
 int			c_subdivisions;
 int			c_gridVerts;
-int			lightmapWidth, lightmapHeight;
 
 //===============================================================================
 
@@ -137,9 +136,8 @@
 static	void R_LoadLightmaps( lump_t *l ) {
 	byte		*buf, *buf_p;
 	int			len;
-	byte		*image;
-	int			i, j, k, x, y;
-	int		numLightmaps;
+	byte		image[LIGHTMAP_SIZE*LIGHTMAP_SIZE*4];
+	int			i, j;
 	float maxIntensity = 0;
 	double sumIntensity = 0;
 
@@ -154,7 +152,11 @@
 
 	// create all the lightmaps
 	tr.numLightmaps = len / (LIGHTMAP_SIZE * LIGHTMAP_SIZE * 3);
-	if ( tr.numLightmaps >= MAX_LIGHTMAPS ) { // 20051020 misantropia
+	if ( tr.numLightmaps == 1 ) {
+		//FIXME: HACK: maps with only one lightmap turn up fullbright for some reason.
+		//this avoids this, but isn't the correct solution.
+		tr.numLightmaps++;
+	} else if ( tr.numLightmaps >= MAX_LIGHTMAPS ) { // 20051020 misantropia
 		ri.Printf( PRINT_WARNING, "WARNING: number of lightmaps > MAX_LIGHTMAPS\n" );
 		tr.numLightmaps = MAX_LIGHTMAPS;
 	}
@@ -163,87 +165,49 @@
 	if ( r_vertexLight->integer || glConfig.hardwareType == GLHW_PERMEDIA2 ) {
 		return;
 	}
-	
-	// see how many lightmaps we can stuff into one texture
-	lightmapWidth = lightmapHeight = 1;
-	while ( lightmapWidth < glConfig.maxTextureSize &&
-		lightmapWidth * lightmapHeight < tr.numLightmaps ) {
-		lightmapWidth *= 2;
-		if ( lightmapWidth * lightmapHeight >= tr.numLightmaps )
-			break;
-		lightmapHeight *= 2;
-	}
-	image = Hunk_AllocateTempMemory( lightmapWidth * lightmapHeight *
-					 LIGHTMAP_SIZE * LIGHTMAP_SIZE * 4 );
 
-	// calculate number of resulting lightmap textures
-	numLightmaps = (tr.numLightmaps + lightmapWidth * lightmapHeight - 1)
-		/ (lightmapWidth * lightmapHeight);
-	
-	for ( i = 0 ; i < numLightmaps; i++ ) {
-		for ( y = 0; y < lightmapHeight; y++ ) {
-			if ( (i * lightmapHeight + y) * lightmapWidth >= tr.numLightmaps)
-				break;
-			
-			for ( x = 0; x < lightmapWidth; x++ ) {
-				if ( (i * lightmapHeight + y) * lightmapWidth + x >= tr.numLightmaps)
-					break;
-			
-				// expand the 24 bit on-disk to 32 bit
-				buf_p = buf + ((i*lightmapHeight + y) * lightmapWidth + x) * LIGHTMAP_SIZE*LIGHTMAP_SIZE * 3;
+	for ( i = 0 ; i < tr.numLightmaps ; i++ ) {
+		// expand the 24 bit on-disk to 32 bit
+		buf_p = buf + i * LIGHTMAP_SIZE*LIGHTMAP_SIZE * 3;
 
-				if ( r_lightmap->integer == 2 )
-				{	// color code by intensity as development tool	(FIXME: check range)
-					for ( j = 0; j < LIGHTMAP_SIZE ; j++ ) {
-						for ( k = 0; k < LIGHTMAP_SIZE; k++ ) {
-							float r = buf_p[(j * LIGHTMAP_SIZE + k)*3+0];
-							float g = buf_p[(j * LIGHTMAP_SIZE + k)*3+1];
-							float b = buf_p[(j * LIGHTMAP_SIZE + k)*3+2];
-							float intensity;
-							float out[3] = {0.0, 0.0, 0.0};
+		if ( r_lightmap->integer == 2 )
+		{	// color code by intensity as development tool	(FIXME: check range)
+			for ( j = 0; j < LIGHTMAP_SIZE * LIGHTMAP_SIZE; j++ )
+			{
+				float r = buf_p[j*3+0];
+				float g = buf_p[j*3+1];
+				float b = buf_p[j*3+2];
+				float intensity;
+				float out[3] = {0.0, 0.0, 0.0};
 
-							intensity = 0.33f * r + 0.685f * g + 0.063f * b;
+				intensity = 0.33f * r + 0.685f * g + 0.063f * b;
 
-							if ( intensity > 255 )
-								intensity = 1.0f;
-							else
-								intensity /= 255.0f;
+				if ( intensity > 255 )
+					intensity = 1.0f;
+				else
+					intensity /= 255.0f;
 
-							if ( intensity > maxIntensity )
-								maxIntensity = intensity;
+				if ( intensity > maxIntensity )
+					maxIntensity = intensity;
 
-							HSVtoRGB( intensity, 1.00, 0.50, out );
+				HSVtoRGB( intensity, 1.00, 0.50, out );
 
-							image[(((y * LIGHTMAP_SIZE + j) * lightmapWidth + x) * LIGHTMAP_SIZE + k)*4+0] = out[0] * 255;
-							image[(((y * LIGHTMAP_SIZE + j) * lightmapWidth + x) * LIGHTMAP_SIZE + k)*4+1] = out[1] * 255;
-							image[(((y * LIGHTMAP_SIZE + j) * lightmapWidth + x) * LIGHTMAP_SIZE + k)*4+2] = out[2] * 255;
-							image[(((y * LIGHTMAP_SIZE + j) * lightmapWidth + x) * LIGHTMAP_SIZE + k)*4+3] = 255;
+				image[j*4+0] = out[0] * 255;
+				image[j*4+1] = out[1] * 255;
+				image[j*4+2] = out[2] * 255;
+				image[j*4+3] = 255;
 
-							sumIntensity += intensity;
-						}
-					}
-				} else {
-					for ( j = 0; j < LIGHTMAP_SIZE ; j++ ) {
-						for ( k = 0; k < LIGHTMAP_SIZE; k++ ) {
-							R_ColorShiftLightingBytes( &buf_p[(j * LIGHTMAP_SIZE + k)*3], &image[(((y * LIGHTMAP_SIZE + j) * lightmapWidth + x) * LIGHTMAP_SIZE + k)*4] );
-							image[(((y * LIGHTMAP_SIZE + j) * lightmapWidth + x) * LIGHTMAP_SIZE + k)*4+3] = 255;
-						}
-					}
-				}
+				sumIntensity += intensity;
+			}
+		} else {
+			for ( j = 0 ; j < LIGHTMAP_SIZE * LIGHTMAP_SIZE; j++ ) {
+				R_ColorShiftLightingBytes( &buf_p[j*3], &image[j*4] );
+				image[j*4+3] = 255;
 			}
 		}
 		tr.lightmaps[i] = R_CreateImage( va("*lightmap%d",i), image, 
-						 LIGHTMAP_SIZE * lightmapWidth, LIGHTMAP_SIZE * lightmapHeight,
-						 qfalse, qfalse, GL_CLAMP_TO_EDGE );
-		ri.Printf( PRINT_DEVELOPER, "lightmaps[%i]=%i\n", i, tr.lightmaps[i]->texnum);
+			LIGHTMAP_SIZE, LIGHTMAP_SIZE, qfalse, qfalse, GL_CLAMP_TO_EDGE );
 	}
-	// dummy lightmap
-	tr.lightmaps[i] = R_CreateImage( va("*lightmap%d",i), image, 
-					 LIGHTMAP_SIZE, LIGHTMAP_SIZE,
-					 qfalse, qfalse, GL_CLAMP_TO_EDGE );
-	Hunk_FreeTempMemory( image );
-
-	tr.numLightmaps = i;
 
 	if ( r_lightmap->integer == 2 )	{
 		ri.Printf( PRINT_DEVELOPER, "Brightest lightmap value: %d\n", ( int ) ( maxIntensity * 255 ) );
@@ -344,14 +308,10 @@
 	int			i, j;
 	srfSurfaceFace_t	*cv;
 	int			numPoints, numIndexes;
-	int			lightmapNum, lightmapX, lightmapY;
+	int			lightmapNum;
 	int			sfaceSize, ofsIndexes;
 
 	lightmapNum = LittleLong( ds->lightmapNum );
-	lightmapX = lightmapNum & (lightmapWidth - 1);
-	lightmapNum /= lightmapWidth;
-	lightmapY = lightmapNum & (lightmapHeight - 1);
-	lightmapNum /= lightmapHeight;
 
 	// get fog volume
 	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
@@ -392,10 +352,6 @@
 			cv->points[i][5+j] = LittleFloat( verts[i].lightmap[j] );
 		}
 		R_ColorShiftLightingBytes( verts[i].color, (byte *)&cv->points[i][7] );
-
-		// adjust lightmap coords
-		cv->points[i][5] = (cv->points[i][5] + lightmapX) / lightmapWidth;
-		cv->points[i][6] = (cv->points[i][6] + lightmapY) / lightmapHeight;
 	}
 
 	indexes += LittleLong( ds->firstIndex );
@@ -425,16 +381,12 @@
 	int				i, j;
 	int				width, height, numPoints;
 	drawVert_t points[MAX_PATCH_SIZE*MAX_PATCH_SIZE];
-	int				lightmapNum, lightmapX, lightmapY;
+	int				lightmapNum;
 	vec3_t			bounds[2];
 	vec3_t			tmpVec;
 	static surfaceType_t	skipData = SF_SKIP;
 
 	lightmapNum = LittleLong( ds->lightmapNum );
-	lightmapX = lightmapNum & (lightmapWidth - 1);
-	lightmapNum /= lightmapWidth;
-	lightmapY = lightmapNum & (lightmapHeight - 1);
-	lightmapNum /= lightmapHeight;
 
 	// get fog volume
 	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
@@ -467,10 +419,6 @@
 			points[i].lightmap[j] = LittleFloat( verts[i].lightmap[j] );
 		}
 		R_ColorShiftLightingBytes( verts[i].color, points[i].color );
-
-		// adjust lightmap coords
-		points[i].lightmap[0] = (points[i].lightmap[0] + lightmapX) / lightmapWidth;
-		points[i].lightmap[1] = (points[i].lightmap[1] + lightmapY) / lightmapHeight;
 	}
 
 	// pre-tesseleate
diff -r 87f98d895296 -r 91f0a3d9f930 src/renderer/tr_image.c
--- a/src/renderer/tr_image.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/renderer/tr_image.c	Sat Jun 06 02:45:31 2009 +0800
@@ -504,13 +504,12 @@
 */
 extern qboolean charSet;
 static void Upload32( unsigned *data, 
-		      int width, int height, 
-		      qboolean mipmap, 
-		      qboolean picmip, 
-		      qboolean lightMap,
-		      int *format, 
-		      int *pUploadWidth, int *pUploadHeight,
-		      qboolean *hasAlpha )
+						  int width, int height, 
+						  qboolean mipmap, 
+						  qboolean picmip, 
+							qboolean lightMap,
+						  int *format, 
+						  int *pUploadWidth, int *pUploadHeight )
 {
 	int			samples;
 	unsigned	*scaledBuffer = NULL;
@@ -612,7 +611,6 @@
 		// select proper internal format
 		if ( samples == 3 )
 		{
-			*hasAlpha = qfalse;
 			if(r_greyscale->integer)
 			{
 				if(r_texturebits->integer == 16)
@@ -648,7 +646,6 @@
 		}
 		else if ( samples == 4 )
 		{
-			*hasAlpha = qtrue;
 			if(r_greyscale->integer)
 			{
 				if(r_texturebits->integer == 16)
@@ -818,13 +815,12 @@
 	GL_Bind(image);
 
 	Upload32( (unsigned *)pic, image->width, image->height, 
-		  image->mipmap,
-		  allowPicmip,
-		  isLightmap,
-		  &image->internalFormat,
-		  &image->uploadWidth,
-		  &image->uploadHeight,
-		  &image->hasAlpha );
+								image->mipmap,
+								allowPicmip,
+								isLightmap,
+								&image->internalFormat,
+								&image->uploadWidth,
+								&image->uploadHeight );
 
 	qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, glWrapClampMode );
 	qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, glWrapClampMode );
diff -r 87f98d895296 -r 91f0a3d9f930 src/renderer/tr_init.c
--- a/src/renderer/tr_init.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/renderer/tr_init.c	Sat Jun 06 02:45:31 2009 +0800
@@ -95,9 +95,6 @@
 cvar_t	*r_ext_texture_env_add;
 cvar_t	*r_ext_texture_filter_anisotropic;
 cvar_t	*r_ext_max_anisotropy;
-cvar_t	*r_ext_vertex_buffer_object;
-cvar_t	*r_ext_vertex_shader;
-cvar_t  *r_ext_framebuffer_object;
 
 cvar_t	*r_ignoreGLErrors;
 cvar_t	*r_logFile;
@@ -170,8 +167,6 @@
 //. next one for enable/disable cel bordering all together.
 cvar_t	*r_celoutline;
 
-cvar_t	*r_flush;
-
 cvar_t	*r_maxpolys;
 int		max_polys;
 cvar_t	*r_maxpolyverts;
@@ -921,9 +916,6 @@
 	r_ext_multitexture = ri.Cvar_Get( "r_ext_multitexture", "1", CVAR_ARCHIVE | CVAR_LATCH );
 	r_ext_compiled_vertex_array = ri.Cvar_Get( "r_ext_compiled_vertex_array", "1", CVAR_ARCHIVE | CVAR_LATCH);
 	r_ext_texture_env_add = ri.Cvar_Get( "r_ext_texture_env_add", "1", CVAR_ARCHIVE | CVAR_LATCH);
-	r_ext_vertex_buffer_object = ri.Cvar_Get( "r_ext_vertex_buffer_object", "1", CVAR_ARCHIVE | CVAR_LATCH);
-	r_ext_vertex_shader = ri.Cvar_Get( "r_ext_vertex_shader", "1", CVAR_ARCHIVE | CVAR_LATCH);
-	r_ext_framebuffer_object = ri.Cvar_Get( "r_ext_framebuffer_object", "1", CVAR_ARCHIVE | CVAR_LATCH);
 
 	r_picmip = ri.Cvar_Get ("r_picmip", GENERIC_HW_R_PICMIP_DEFAULT,
 			CVAR_ARCHIVE | CVAR_LATCH );
@@ -1068,8 +1060,6 @@
 	// cel outline option
 	r_celoutline = ri.Cvar_Get("r_celoutline","0", CVAR_ARCHIVE);
 
-	r_flush = ri.Cvar_Get("r_flush","0", 0);
-
 	// make sure all the commands added here are also
 	// removed in R_Shutdown
 	ri.Cmd_AddCommand( "imagelist", R_ImageList_f );
@@ -1206,24 +1196,6 @@
 		R_SyncRenderThread();
 		R_ShutdownCommandBuffers();
 		R_DeleteTextures();
-
-		if ( qglIsBufferARB && tr.numShaders ) {
-			int shader, vbo;
-			
-			GL_VBO( 0, 0 );
-
-			for ( shader = 0; shader < tr.numShaders; shader++ ) {
-				for ( vbo = 0; vbo < MAX_VBOS_PER_SHADER; vbo++ ) {
-					if ( !tr.shaders[shader]->VBOs[vbo].key )
-						break;
-					
-					if ( qglIsBufferARB( tr.shaders[shader]->VBOs[vbo].ibo ) )
-						qglDeleteBuffersARB( 1, &tr.shaders[shader]->VBOs[vbo].ibo );
-					if ( qglIsBufferARB( tr.shaders[shader]->VBOs[vbo].vbo ) )
-						qglDeleteBuffersARB( 1, &tr.shaders[shader]->VBOs[vbo].vbo );
-				}
-			}
-		}
 	}
 
 	R_DoneFreeType();
diff -r 87f98d895296 -r 91f0a3d9f930 src/renderer/tr_local.h
--- a/src/renderer/tr_local.h	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/renderer/tr_local.h	Sat Jun 06 02:45:31 2009 +0800
@@ -54,12 +54,6 @@
 //#define MAX_SHADER_STATES 2048
 #define MAX_STATES_PER_SHADER 32
 #define MAX_STATE_NAME 32
-#define MAX_VBOS_PER_SHADER 16
-
-#define NUM_TEXTURE_BUNDLES 4
-
-// add byte offset to pointer
-#define ptrPlusOffset(ptr, off) (typeof(ptr))((byte *)(ptr) + (off))
 
 // can't be increased without changing bit packing for drawsurfs
 
@@ -110,7 +104,6 @@
 
 	qboolean	mipmap;
 	qboolean	allowPicmip;
-	qboolean        hasAlpha;
 	int			wrapClampMode;		// GL_CLAMP_TO_EDGE or GL_REPEAT
 
 	struct image_s*	next;
@@ -304,9 +297,10 @@
 	qboolean		isLightmap;
 	qboolean		vertexLightmap;
 	qboolean		isVideoMap;
-	int		multitextureEnv;		// 0, GL_MODULATE, GL_ADD
 } textureBundle_t;
 
+#define NUM_TEXTURE_BUNDLES 2
+
 typedef struct {
 	qboolean		active;
 	
@@ -359,37 +353,6 @@
 } fogParms_t;
 
 
-typedef byte color4ub_t[4];
-
-#define VBOKEY_TYPEMASK	0x7f000000
-#define VBOKEY_IDXMASK	0x00ffffff
-#define VBOKEY_VIS   	0x01000000
-#define VBOKEY_MODEL 	0x02000000
-#define VBOKEY_MD3 	0x03000000
-
-typedef struct vboInfo_s {
-	int	key;
-	GLuint  vbo;
-	GLuint  ibo;
-	int	numIndexes;
-	int     numVertexes;
-	int     vertexSize;   // number of bytes of one vertex
-} vboInfo_t;
-
-/* calculate VBO offsets for coordinates, normals, etc.
- * all data is interleaved and padded to 32 bytes
- * worst case:  16 byte position + 8 byte texCoord1 + 8 byte texCoord2 +
- *              12 byte normal + 4 byte color = 64 bytes
- * common case: 16 byte position + 8 byte texCoord1 + 8 byte texCoord2 =
- *              32 bytes (lightmapped texture)
- */
-#define VBO_xyz(shader,vbo)	((byte *)NULL)
-#define VBO_tc1(shader,vbo)	(VBO_xyz(shader,vbo) + sizeof(vec4_t))
-#define VBO_tc2(shader,vbo)	(VBO_tc1(shader,vbo) + sizeof(vec2_t) * (shader)->needsST1)
-#define VBO_normals(shader,vbo)	(VBO_tc2(shader,vbo) + sizeof(vec2_t) * (shader)->needsST2)
-#define VBO_colors(shader,vbo)	(VBO_normals(shader,vbo) + sizeof(vec3_t) * (shader)->needsNormal)
-#define VBO_inc(shader,vbo)     ((vbo)->vertexSize)
-
 typedef struct shader_s {
 	char		name[MAX_QPATH];		// game path, including extension
 	int			lightmapIndex;			// for a shader to match, both name and lightmapIndex must match
@@ -418,6 +381,8 @@
 
 	float		portalRange;			// distance to fog out at
 
+	int			multitextureEnv;		// 0, GL_MODULATE, GL_ADD (FIXME: put in stage)
+
 	cullType_t	cullType;				// CT_FRONT_SIDED, CT_BACK_SIDED, or CT_TWO_SIDED
 	qboolean	polygonOffset;			// set for decals and other items that must be offset 
 	qboolean	noMipMaps;				// for console fonts, 2D elements, etc.
@@ -429,7 +394,6 @@
 	qboolean	needsST1;
 	qboolean	needsST2;
 	qboolean	needsColor;
-	qboolean        useVBO;
 
 	int			numDeforms;
 	deformStage_t	deforms[MAX_SHADER_DEFORMS];
@@ -451,9 +415,6 @@
   struct shader_s *remappedShader;                  // current shader this one is remapped too
 
   int shaderStates[MAX_STATES_PER_SHADER];          // index to valid shader states
-	vboInfo_t VBOs[MAX_VBOS_PER_SHADER];
-
-  GLuint	GLSLprogram;			    // GLSL shader program
 
 	struct	shader_s	*next;
 } shader_t;
@@ -676,11 +637,11 @@
 	int				*indexes;
 
 	int				numVerts;
-
 	drawVert_t		*verts;
 } srfTriangles_t;
 
-extern	void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])(surfaceType_t *);
+
+extern	void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])(void *);
 
 /*
 ==============================================================================
@@ -873,13 +834,12 @@
 
 // the renderer front end should never modify glstate_t
 typedef struct {
-	int			currenttextures[NUM_TEXTURE_BUNDLES];
+	int			currenttextures[2];
 	int			currenttmu;
 	qboolean	finishCalled;
-	int			texEnv[NUM_TEXTURE_BUNDLES];
+	int			texEnv[2];
 	int			faceCulling;
 	unsigned long	glStateBits;
-	GLuint		currentVBO, currentIBO;
 } glstate_t;
 
 
@@ -1106,9 +1066,6 @@
 
 extern cvar_t	*r_ext_texture_filter_anisotropic;
 extern cvar_t	*r_ext_max_anisotropy;
-extern cvar_t   *r_ext_vertex_buffer_object;
-extern cvar_t   *r_ext_vertex_shader;
-extern cvar_t   *r_ext_framebuffer_object;
 
 extern	cvar_t	*r_nobind;						// turns off binding to appropriate textures
 extern	cvar_t	*r_singleShader;				// make most world faces use default shader
@@ -1173,8 +1130,6 @@
 extern	cvar_t	*r_celshadalgo;					// Cell shading, chooses method: 0 = disabled, 1 = kuwahara, 2 = whiteTexture
 extern	cvar_t	*r_celoutline;						//. cel outline. 1 on, 0 off. (maybe other options later)
 
-extern	cvar_t	*r_flush;
-
 //====================================================================
 
 float R_NoiseGet4f( float x, float y, float z, float t );
@@ -1219,7 +1174,6 @@
 void	GL_TextureMode( const char *string );
 void	GL_CheckErrors( void );
 void	GL_State( unsigned long stateVector );
-void	GL_VBO( GLuint vbo, GLuint IBO );
 void	GL_TexEnv( int env );
 void	GL_Cull( int cullType );
 
@@ -1350,6 +1304,7 @@
 
 ====================================================================
 */
+typedef byte color4ub_t[4];
 
 typedef struct stageVars
 {
@@ -1357,7 +1312,6 @@
 	vec2_t		texcoords[NUM_TEXTURE_BUNDLES][SHADER_MAX_VERTEXES];
 } stageVars_t;
 
-extern vec4_t vec4Scratch;
 
 typedef struct shaderCommands_s 
 {
@@ -1367,29 +1321,19 @@
 	vec2_t		texCoords[SHADER_MAX_VERTEXES][2] ALIGNED(16);
 	color4ub_t	vertexColors[SHADER_MAX_VERTEXES] ALIGNED(16);
 	int			vertexDlightBits[SHADER_MAX_VERTEXES] ALIGNED(16);
-	glIndex_t	*indexPtr;
-	vec4_t		*xyzPtr;
-	vec4_t		*normalPtr;
-	vec2_t		*texCoordPtr, *texCoord2Ptr;
-	color4ub_t	*vertexColorPtr;
-	int		*vertexDlightBitPtr;
-	size_t		indexInc, xyzInc, normalInc, texCoordInc, texCoord2Inc,
-			vertexColorInc,	vertexDlightBitInc;
-	int		numIndexes;
-	int		numVertexes;
-	int		maxIndexes;
-	int		maxVertexes;
 
-	int		dlightBits;	// or together of all vertexDlightBits
 	stageVars_t	svars ALIGNED(16);
 
 	color4ub_t	constantColor255[SHADER_MAX_VERTEXES] ALIGNED(16);
 
-	vboInfo_t	*renderVBO;
+	shader_t	*shader;
+  float   shaderTime;
+	int			fogNum;
 
-	shader_t	*shader;
-	float			shaderTime;
-	int			fogNum;
+	int			dlightBits;	// or together of all vertexDlightBits
+
+	int			numIndexes;
+	int			numVertexes;
 
 	// info extracted from current shader
 	int			numPasses;
@@ -1403,7 +1347,7 @@
 void RB_BeginSurface(shader_t *shader, int fogNum );
 void RB_EndSurface(void);
 void RB_CheckOverflow( int verts, int indexes );
-#define RB_CHECKOVERFLOW(v,i) if (tess.numVertexes + (v) >= tess.maxVertexes || tess.numIndexes + (i) >= tess.maxIndexes ) {RB_CheckOverflow(v,i);}
+#define RB_CHECKOVERFLOW(v,i) if (tess.numVertexes + (v) >= SHADER_MAX_VERTEXES || tess.numIndexes + (i) >= SHADER_MAX_INDEXES ) {RB_CheckOverflow(v,i);}
 
 void RB_StageIteratorGeneric( void );
 void RB_StageIteratorSky( void );
@@ -1559,10 +1503,10 @@
 
 // void R_MakeAnimModel( model_t *model );      haven't seen this one really, so not needed I guess.
 void R_AddAnimSurfaces( trRefEntity_t *ent );
-void RB_SurfaceAnim( surfaceType_t *surfType );
+void RB_SurfaceAnim( md4Surface_t *surfType );
 #ifdef RAVENMD4
 void R_MDRAddAnimSurfaces( trRefEntity_t *ent );
-void RB_MDRSurfaceAnim( surfaceType_t *surface );
+void RB_MDRSurfaceAnim( md4Surface_t *surface );
 #endif
 
 /*
diff -r 87f98d895296 -r 91f0a3d9f930 src/renderer/tr_shade.c
--- a/src/renderer/tr_shade.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/renderer/tr_shade.c	Sat Jun 06 02:45:31 2009 +0800
@@ -164,7 +164,7 @@
 without compiled vertex arrays.
 ==================
 */
-static void R_DrawElements( int numIndexes, const void *indexes, GLuint end, GLenum type ) {
+static void R_DrawElements( int numIndexes, const glIndex_t *indexes ) {
 	int		primitives;
 
 	primitives = r_primitives->integer;
@@ -180,17 +180,10 @@
 
 
 	if ( primitives == 2 ) {
-		if ( qglDrawRangeElementsEXT )
-			qglDrawRangeElementsEXT( GL_TRIANGLES, 
-						 0, end,
-						 numIndexes,
-						 type,
-						 indexes );
-		else
-			qglDrawElements( GL_TRIANGLES,
-					 numIndexes,
-					 type,
-					 indexes );
+		qglDrawElements( GL_TRIANGLES, 
+						numIndexes,
+						GL_INDEX_TYPE,
+						indexes );
 		return;
 	}
 
@@ -208,7 +201,7 @@
 }
 
 //R_DRAWCEL
-static void R_DrawCel( int numIndexes, const void *indexes, GLuint end, GLenum type ) {
+static void R_DrawCel( int numIndexes, const glIndex_t *indexes ) {
 	int		primitives;
 	
 	if(
@@ -246,10 +239,7 @@
 	qglLineWidth( (float) r_celoutline->integer );	
 
 	if(primitives == 2) {
-		if ( qglDrawRangeElementsEXT )
-			qglDrawRangeElementsEXT( GL_TRIANGLES, 0, end, numIndexes, type, indexes );
-		else
-			qglDrawElements( GL_TRIANGLES, numIndexes, type, indexes );
+		qglDrawElements( GL_TRIANGLES, numIndexes, GL_INDEX_TYPE, indexes );
 	} else if(primitives == 1) {
 		R_DrawStripElements( numIndexes,  indexes, qglArrayElement );
 	} else if(primitives == 3) {
@@ -335,7 +325,7 @@
 }
 
 //DRAWCEL
-static void DrawCelVBO (vboInfo_t *VBO) {
+static void DrawCel (shaderCommands_t *input) {
 
 	GL_Bind( tr.whiteImage );
 	qglColor3f (1,1,1);
@@ -345,26 +335,14 @@
 	qglDisableClientState (GL_COLOR_ARRAY);
 	qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
 
-	R_DrawCel( VBO->numIndexes, NULL , VBO->numVertexes-1, VBO->numVertexes > 65536 ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT );
-}
-static void DrawCel ( void ) {
-
-	GL_Bind( tr.whiteImage );
-	qglColor3f (1,1,1);
-
-	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
-
-	qglDisableClientState (GL_COLOR_ARRAY);
-	qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
-
-	qglVertexPointer (3, GL_FLOAT, 16, tess.xyz);	// padded for SIMD
+	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);	// padded for SIMD
 
 	if (qglLockArraysEXT) {
-		qglLockArraysEXT(0, tess.numVertexes);
+		qglLockArraysEXT(0, input->numVertexes);
 		GLimp_LogComment( "glLockArraysEXT\n" );
 	}
 
-	R_DrawCel( tess.numIndexes, tess.indexes, tess.numVertexes-1, GL_UNSIGNED_INT );
+	R_DrawCel( input->numIndexes, input->indexes );
 
 	if (qglUnlockArraysEXT) {
 		qglUnlockArraysEXT();
@@ -380,7 +358,7 @@
 Draws triangle outlines for debugging
 ================
 */
-static void DrawTrisVBO (vboInfo_t *VBO) {
+static void DrawTris (shaderCommands_t *input) {
 	GL_Bind( tr.whiteImage );
 	qglColor3f (1,1,1);
 
@@ -390,39 +368,14 @@
 	qglDisableClientState (GL_COLOR_ARRAY);
 	qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
 
-	qglColor3f (0,0,1);
-
-	GL_VBO( VBO->vbo, VBO->ibo );
-
-	qglVertexPointer (3, GL_FLOAT, VBO_inc(tess.shader, VBO),
-			  VBO_xyz(tess.shader, VBO));
-
-	R_DrawElements( VBO->numIndexes, NULL, VBO->numVertexes-1, VBO->numVertexes > 65536 ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT );
-
-	qglDepthRange( 0, 1 );
-}
-static void DrawTris ( void ) {
-	GL_Bind( tr.whiteImage );
-	qglColor3f (1,1,1);
-
-	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
-	qglDepthRange( 0, 0 );
-
-	qglDisableClientState (GL_COLOR_ARRAY);
-	qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
-
-	qglColor3f (1,1,1);
-	
-	GL_VBO( 0, 0 );
-	
-	qglVertexPointer (3, GL_FLOAT, 16, tess.xyz);	// padded for SIMD
+	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);	// padded for SIMD
 
 	if (qglLockArraysEXT) {
-		qglLockArraysEXT(0, tess.numVertexes);
+		qglLockArraysEXT(0, input->numVertexes);
 		GLimp_LogComment( "glLockArraysEXT\n" );
 	}
 
-	R_DrawElements( tess.numIndexes, tess.indexes, tess.numVertexes-1, GL_UNSIGNED_INT );
+	R_DrawElements( input->numIndexes, input->indexes );
 
 	if (qglUnlockArraysEXT) {
 		qglUnlockArraysEXT();
@@ -439,7 +392,7 @@
 Draws vertex normals for debugging
 ================
 */
-static void DrawNormals ( void ) {
+static void DrawNormals (shaderCommands_t *input) {
 	int		i;
 	vec3_t	temp;
 
@@ -449,9 +402,9 @@
 	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
 
 	qglBegin (GL_LINES);
-	for (i = 0 ; i < tess.numVertexes ; i++) {
-		qglVertex3fv (tess.xyz[i]);
-		VectorMA (tess.xyz[i], 2, tess.normal[i], temp);
+	for (i = 0 ; i < input->numVertexes ; i++) {
+		qglVertex3fv (input->xyz[i]);
+		VectorMA (input->xyz[i], 2, input->normal[i], temp);
 		qglVertex3fv (temp);
 	}
 	qglEnd ();
@@ -474,7 +427,6 @@
 
 	tess.numIndexes = 0;
 	tess.numVertexes = 0;
-	tess.renderVBO = NULL;
 	tess.shader = state;
 	tess.fogNum = fogNum;
 	tess.dlightBits = 0;		// will be OR'd in by surface functions
@@ -502,7 +454,6 @@
 */
 static void DrawMultitextured( shaderCommands_t *input, int stage ) {
 	shaderStage_t	*pStage;
-	int		bundle;
 
 	pStage = tess.xstages[stage];
 
@@ -522,39 +473,31 @@
 	R_BindAnimatedImage( &pStage->bundle[0] );
 
 	//
-	// lightmap/secondary passes
+	// lightmap/secondary pass
 	//
-	for ( bundle = 1; bundle < glConfig.numTextureUnits; bundle++ ) {
-		if ( !pStage->bundle[bundle].multitextureEnv )
-			break;
-		
-		GL_SelectTexture( bundle );
-		qglEnable( GL_TEXTURE_2D );
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-		
-		if ( r_lightmap->integer ) {
-			GL_TexEnv( GL_REPLACE );
-		} else {
-			GL_TexEnv( pStage->bundle[bundle].multitextureEnv );
-		}
+	GL_SelectTexture( 1 );
+	qglEnable( GL_TEXTURE_2D );
+	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
 
-		qglTexCoordPointer( 2, GL_FLOAT, 0, input->svars.texcoords[bundle] );
-		
-		R_BindAnimatedImage( &pStage->bundle[bundle] );
+	if ( r_lightmap->integer ) {
+		GL_TexEnv( GL_REPLACE );
+	} else {
+		GL_TexEnv( tess.shader->multitextureEnv );
 	}
 
-	R_DrawElements( input->numIndexes, input->indexes, input->numVertexes-1, GL_UNSIGNED_INT );
+	qglTexCoordPointer( 2, GL_FLOAT, 0, input->svars.texcoords[1] );
+
+	R_BindAnimatedImage( &pStage->bundle[1] );
+
+	R_DrawElements( input->numIndexes, input->indexes );
 
 	//
-	// disable texturing on TEXTURE>=1, then select TEXTURE0
+	// disable texturing on TEXTURE1, then select TEXTURE0
 	//
-	--bundle;
-	while ( bundle > 0 ) {
 	//qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglDisable( GL_TEXTURE_2D );
-		bundle--;
-		GL_SelectTexture( bundle );
-	}
+	qglDisable( GL_TEXTURE_2D );
+
+	GL_SelectTexture( 0 );
 }
 
 
@@ -732,7 +675,7 @@
 		else {
 			GL_State( GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
 		}
-		R_DrawElements( numIndexes, hitIndexes, tess.numVertexes-1, GL_UNSIGNED_INT );
+		R_DrawElements( numIndexes, hitIndexes );
 		backEnd.pc.c_totalIndexes += numIndexes;
 		backEnd.pc.c_dlightIndexes += numIndexes;
 	}
@@ -877,7 +820,7 @@
 		else {
 			GL_State( GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
 		}
-		R_DrawElements( numIndexes, hitIndexes, tess.numVertexes-1, GL_UNSIGNED_INT );
+		R_DrawElements( numIndexes, hitIndexes );
 		backEnd.pc.c_totalIndexes += numIndexes;
 		backEnd.pc.c_dlightIndexes += numIndexes;
 	}
@@ -928,7 +871,7 @@
 		GL_State( GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA );
 	}
 
-	R_DrawElements( tess.numIndexes, tess.indexes, tess.numVertexes-1, GL_UNSIGNED_INT );
+	R_DrawElements( tess.numIndexes, tess.indexes );
 }
 
 /*
@@ -1241,214 +1184,6 @@
 /*
 ** RB_IterateStagesGeneric
 */
-static void RB_IterateStagesGenericVBO( vboInfo_t *VBO )
-{
-	int stage;
-	int bundle;
-
-	if ( tess.shader->needsNormal ) {
-		qglEnableClientState( GL_NORMAL_ARRAY );
-		qglNormalPointer( GL_FLOAT, VBO_inc(tess.shader, VBO),
-				  VBO_normals(tess.shader, VBO) );
-	}
-	if (qglLockArraysEXT)
-	{
-		qglLockArraysEXT(0, VBO->numVertexes);
-		GLimp_LogComment( "glLockArraysEXT\n" );
-	}
-	
-	for ( stage = 0; stage < MAX_SHADER_STAGES; stage++ )
-	{
-		shaderStage_t *pStage = tess.xstages[stage];
-		alphaGen_t     aGen;
-		colorGen_t     rgbGen;
-
-		if ( !pStage )
-		{
-			break;
-		}
-
-		GL_State( pStage->stateBits );
-		aGen = pStage->alphaGen;
-		rgbGen = pStage->rgbGen;
-
-		// hack to enable vertex lighting - AGEN_SKIP should be ditched imho
-		if ( aGen == AGEN_SKIP ) {
-			if ( rgbGen == CGEN_EXACT_VERTEX ||
-			     rgbGen == CGEN_VERTEX ) {
-				aGen = AGEN_VERTEX;
-			}
-		}
-		
-		if ( aGen == AGEN_VERTEX ) {
-			// implies rgbGen == CGEN_EXACT_VERTEX || rgbGen == CGEN_VERTEX
-			qglEnableClientState( GL_COLOR_ARRAY );
-			qglColorPointer( 4, GL_UNSIGNED_BYTE, VBO_inc(tess.shader, VBO),
-					 VBO_colors(tess.shader,VBO) );
-		} else {
-			byte alpha = 0;
-			qglDisableClientState( GL_COLOR_ARRAY );
-			switch( aGen ) {
-			case AGEN_IDENTITY:
-				alpha = 255;
-				break;
-			case AGEN_SKIP:
-				alpha = 255;
-				break;
-			case AGEN_ENTITY:
-				if ( backEnd.currentEntity )
-					alpha = backEnd.currentEntity->e.shaderRGBA[3];
-				break;
-			case AGEN_ONE_MINUS_ENTITY:
-				if ( backEnd.currentEntity )
-					alpha = 255 - backEnd.currentEntity->e.shaderRGBA[3];
-				break;
-			case AGEN_CONST:
-				alpha = pStage->constantColor[3];
-				break;
-			default:
-				// error ?
-				break;
-			}
-
-			switch( rgbGen ) {
-			case CGEN_IDENTITY_LIGHTING:
-				qglColor4ub( tr.identityLightByte,
-					     tr.identityLightByte,
-					     tr.identityLightByte,
-					     alpha );
-				break;
-			case CGEN_IDENTITY:
-				qglColor4ub( 255, 255, 255, alpha );
-				break;
-			case CGEN_ENTITY:
-				if ( backEnd.currentEntity )
-					qglColor4ub( backEnd.currentEntity->e.shaderRGBA[0],
-						     backEnd.currentEntity->e.shaderRGBA[1],
-						     backEnd.currentEntity->e.shaderRGBA[2],
-						     alpha );
-				break;
-			case CGEN_ONE_MINUS_ENTITY:
-				if ( backEnd.currentEntity )
-					qglColor4ub( 255 - backEnd.currentEntity->e.shaderRGBA[0],
-						     255 - backEnd.currentEntity->e.shaderRGBA[1],
-						     255 - backEnd.currentEntity->e.shaderRGBA[2],
-						     alpha );
-				break;
-			case CGEN_CONST:
-				qglColor4ub( pStage->constantColor[0],
-					     pStage->constantColor[1],
-					     pStage->constantColor[2],
-					     alpha );
-				break;
-			default:
-				// error ?
-				break;
-			}
-		}
-
-		//
-		// set state
-		//
-		if ( pStage->bundle[0].vertexLightmap && ( (r_vertexLight->integer && !r_uiFullScreen->integer) || glConfig.hardwareType == GLHW_PERMEDIA2 ) && r_lightmap->integer )
-		{
-			GL_Bind( tr.whiteImage );
-		}
-		else 
-			R_BindAnimatedImage( &pStage->bundle[0] );
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
-		switch ( pStage->bundle[0].tcGen ) {
-		case TCGEN_TEXTURE:
-			qglTexCoordPointer( 2, GL_FLOAT, VBO_inc(tess.shader, VBO),
-					    VBO_tc1(tess.shader, VBO) );
-			break;
-		case TCGEN_LIGHTMAP:
-			qglTexCoordPointer( 2, GL_FLOAT, VBO_inc(tess.shader, VBO),
-					    VBO_tc2(tess.shader, VBO) );
-			break;
-		default:
-			//error ?
-			break;
-		}
-		
-		//
-		// do multitexture
-		//
-		for ( bundle = 1; bundle < glConfig.numTextureUnits; bundle++ ) {
-			if ( !pStage->bundle[bundle].multitextureEnv )
-				break;
-
-			// this is an ugly hack to work around a GeForce driver
-			// bug with multitexture and clip planes
-			if ( backEnd.viewParms.isPortal ) {
-				qglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
-			}
-			
-			//
-			// lightmap/secondary pass
-			//
-			GL_SelectTexture( bundle );
-			qglEnable( GL_TEXTURE_2D );
-			qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-			switch ( pStage->bundle[bundle].tcGen ) {
-			case TCGEN_TEXTURE:
-				qglTexCoordPointer( 2, GL_FLOAT, VBO_inc(tess.shader, VBO),
-						    VBO_tc1(tess.shader, VBO) );
-				break;
-			case TCGEN_LIGHTMAP:
-				qglTexCoordPointer( 2, GL_FLOAT, VBO_inc(tess.shader, VBO),
-						    VBO_tc2(tess.shader, VBO) );
-				break;
-			default:
-				// error ?
-				break;
-			}
-			
-			if ( r_lightmap->integer ) {
-				GL_TexEnv( GL_REPLACE );
-			} else {
-				GL_TexEnv( pStage->bundle[bundle].multitextureEnv );
-			}
-			R_BindAnimatedImage( &pStage->bundle[bundle] );
-		}
-		
-		if ( qglDrawRangeElementsEXT )
-			qglDrawRangeElementsEXT( GL_TRIANGLES,
-						 0, VBO->numVertexes-1,
-						 VBO->numIndexes,
-						 VBO->numVertexes > 65536 ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT,
-						 NULL );
-		else
-			qglDrawElements( GL_TRIANGLES, VBO->numIndexes,
-					 GL_INDEX_TYPE, NULL );
-		
-		//
-		// disable texturing on TEXTURE1, then select TEXTURE0
-		//
-		bundle--;
-		while ( bundle > 0 ) {
-			qglDisable( GL_TEXTURE_COORD_ARRAY );
-			qglDisable( GL_TEXTURE_2D );
-			bundle--;
-			GL_SelectTexture( bundle );
-		}
-
-		// allow skipping out to show just lightmaps during development
-		if ( r_lightmap->integer && ( pStage->bundle[0].isLightmap || pStage->bundle[1].isLightmap || pStage->bundle[0].vertexLightmap ) )
-		{
-			break;
-		}
-	}
-
-	if (qglUnlockArraysEXT) 
-	{
-		qglUnlockArraysEXT();
-		GLimp_LogComment( "glUnlockArraysEXT\n" );
-	}
-	
-	if ( tess.shader->needsNormal )
-		qglDisableClientState( GL_NORMAL_ARRAY );
-}
 static void RB_IterateStagesGeneric( shaderCommands_t *input )
 {
 	int stage;
@@ -1500,7 +1235,7 @@
 			//
 			// draw
 			//
-			R_DrawElements( input->numIndexes, input->indexes, input->numVertexes-1, GL_UNSIGNED_INT );
+			R_DrawElements( input->numIndexes, input->indexes );
 		}
 		// allow skipping out to show just lightmaps during development
 		if ( r_lightmap->integer && ( pStage->bundle[0].isLightmap || pStage->bundle[1].isLightmap || pStage->bundle[0].vertexLightmap ) )
@@ -1547,99 +1282,80 @@
 	//. show me cel outlines.
 	//. there has to be a better place to put this.
 	if(r_celoutline->integer > 0) {
-		if ( tess.numIndexes > 0 )
-			DrawCel();
+		DrawCel(&tess);
 	}
 
-	if ( tess.renderVBO ) {
-		GL_VBO( tess.renderVBO->vbo, tess.renderVBO->ibo );
+	//
+	// if there is only a single pass then we can enable color
+	// and texture arrays before we compile, otherwise we need
+	// to avoid compiling those arrays since they will change
+	// during multipass rendering
+	//
+	if ( tess.numPasses > 1 || input->shader->multitextureEnv )
+	{
+		setArraysOnce = qfalse;
+		qglDisableClientState (GL_COLOR_ARRAY);
+		qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
+	}
+	else
+	{
+		setArraysOnce = qtrue;
 
-		qglVertexPointer (3, GL_FLOAT, VBO_inc(tess.shader, tess.renderVBO),
-				  VBO_xyz(tess.shader, tess.renderVBO));
+		qglEnableClientState( GL_COLOR_ARRAY);
+		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
 
-		if(r_celoutline->integer > 0) {
-			if ( tess.renderVBO )
-				DrawCelVBO( tess.renderVBO );
-		}
-
-		RB_IterateStagesGenericVBO( tess.renderVBO );
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
+		qglTexCoordPointer( 2, GL_FLOAT, 0, tess.svars.texcoords[0] );
 	}
 
-	if ( tess.numIndexes > 0 ) {
-		//
+	//
+	// lock XYZ
+	//
+	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);	// padded for SIMD
+	if (qglLockArraysEXT)
+	{
+		qglLockArraysEXT(0, input->numVertexes);
+		GLimp_LogComment( "glLockArraysEXT\n" );
+	}
 
-		GL_VBO( 0, 0 );
+	//
+	// enable color and texcoord arrays after the lock if necessary
+	//
+	if ( !setArraysOnce )
+	{
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+		qglEnableClientState( GL_COLOR_ARRAY );
+	}
 
-		// if there is only a single pass then we can enable color
-		// and texture arrays before we compile, otherwise we need
-		// to avoid compiling those arrays since they will change
-		// during multipass rendering
-		//
-		if ( tess.numPasses > 1 || (tess.numPasses > 0 && input->shader->stages[0]->bundle[1].multitextureEnv) )
-		{
-			setArraysOnce = qfalse;
-			qglDisableClientState (GL_COLOR_ARRAY);
-			qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
-		}
-		else
-		{
-			setArraysOnce = qtrue;
-			
-			qglEnableClientState( GL_COLOR_ARRAY);
-			qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
-			
-			qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
-			qglTexCoordPointer( 2, GL_FLOAT, 0, tess.svars.texcoords[0] );
-		}
-		
-		//
-		// lock XYZ
-		//
-		qglVertexPointer (3, GL_FLOAT, 16, input->xyz);	// padded for SIMD
-		if (qglLockArraysEXT)
-		{
-			qglLockArraysEXT(0, input->numVertexes);
-			GLimp_LogComment( "glLockArraysEXT\n" );
-		}
-		
-		//
-		// enable color and texcoord arrays after the lock if necessary
-		//
-		if ( !setArraysOnce )
-		{
-			qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-			qglEnableClientState( GL_COLOR_ARRAY );
-		}
-		
-		//
-		// call shader function
-		//
-		RB_IterateStagesGeneric( input );
-		
-		// 
-		// now do any dynamic lighting needed
-		//
-		if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE
-		     && !(tess.shader->surfaceFlags & (SURF_NODLIGHT | SURF_SKY) ) ) {
-			ProjectDlightTexture();
-		}
-		
-		//
-		// now do fog
-		//
-		if ( tess.fogNum && tess.shader->fogPass ) {
-			RB_FogPass();
-		}
-		
-		// 
-		// unlock arrays
-		//
-		if (qglUnlockArraysEXT) 
-		{
-			qglUnlockArraysEXT();
-			GLimp_LogComment( "glUnlockArraysEXT\n" );
-		}
+	//
+	// call shader function
+	//
+	RB_IterateStagesGeneric( input );
+
+	// 
+	// now do any dynamic lighting needed
+	//
+	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE
+		&& !(tess.shader->surfaceFlags & (SURF_NODLIGHT | SURF_SKY) ) ) {
+		ProjectDlightTexture();
 	}
+
+	//
+	// now do fog
+	//
+	if ( tess.fogNum && tess.shader->fogPass ) {
+		RB_FogPass();
+	}
+
+	// 
+	// unlock arrays
+	//
+	if (qglUnlockArraysEXT) 
+	{
+		qglUnlockArraysEXT();
+		GLimp_LogComment( "glUnlockArraysEXT\n" );
+	}
+
 	//
 	// reset polygon offset
 	//
@@ -1682,77 +1398,50 @@
 	//
 	GL_Cull( input->shader->cullType );
 
-	R_BindAnimatedImage( &tess.xstages[0]->bundle[0] );
-	GL_State( tess.xstages[0]->stateBits );
-
 	//
 	// set arrays and lock
 	//
-	if ( input->renderVBO ) {
-		GL_VBO( input->renderVBO->vbo, input->renderVBO->ibo );
+	qglEnableClientState( GL_COLOR_ARRAY);
+	qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
 
-		qglEnableClientState( GL_COLOR_ARRAY);
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
-		
-		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0,
-				 (byte *)NULL +
-				 input->renderVBO->numVertexes *
-				 (sizeof(vec4_t) + sizeof(vec4_t) + sizeof(vec2_t) + sizeof(vec2_t)) );
-		qglTexCoordPointer( 2, GL_FLOAT, 8, 
-				    (byte *)NULL +
-				    input->renderVBO->numVertexes *
-				    (sizeof(vec4_t) + sizeof(vec4_t)) );
-		qglVertexPointer (3, GL_FLOAT, 16, NULL);
-		
-		//
-		// call special shade routine
-		//
-		R_DrawElements( input->renderVBO->numIndexes, NULL, input->renderVBO->numVertexes-1, input->renderVBO->numVertexes > 65536 ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT );
+	qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
+	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][0] );
+	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);
+
+	if ( qglLockArraysEXT )
+	{
+		qglLockArraysEXT(0, input->numVertexes);
+		GLimp_LogComment( "glLockArraysEXT\n" );
 	}
-	if ( input->numIndexes > 0 ) {
-		GL_VBO( 0, 0 );
-		
-		qglEnableClientState( GL_COLOR_ARRAY);
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
-		
-		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
-		qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][0] );
-		qglVertexPointer (3, GL_FLOAT, 16, input->xyz);
-		
-		//
-		// lock arrays
-		//
-		if ( qglLockArraysEXT ) {
-			qglLockArraysEXT(0, input->numVertexes);
-			GLimp_LogComment( "glLockArraysEXT\n" );
-		}
-		
-		//
-		// call special shade routine
-		//
-		R_DrawElements( input->numIndexes, input->indexes, input->numVertexes-1, GL_UNSIGNED_INT );
 
-		// 
-		// now do any dynamic lighting needed
-		//
-		if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE ) {
-			ProjectDlightTexture();
-		}
-		
-		//
-		// now do fog
-		//
-		if ( tess.fogNum && tess.shader->fogPass ) {
-			RB_FogPass();
-		}
+	//
+	// call special shade routine
+	//
+	R_BindAnimatedImage( &tess.xstages[0]->bundle[0] );
+	GL_State( tess.xstages[0]->stateBits );
+	R_DrawElements( input->numIndexes, input->indexes );
 
-		//
-		// unlock arrays
-		//
-		if ( qglUnlockArraysEXT ) {
-			qglUnlockArraysEXT();
-			GLimp_LogComment( "glUnlockArraysEXT\n" );
-		}
+	// 
+	// now do any dynamic lighting needed
+	//
+	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE ) {
+		ProjectDlightTexture();
+	}
+
+	//
+	// now do fog
+	//
+	if ( tess.fogNum && tess.shader->fogPass ) {
+		RB_FogPass();
+	}
+
+	// 
+	// unlock arrays
+	//
+	if (qglUnlockArraysEXT) 
+	{
+		qglUnlockArraysEXT();
+		GLimp_LogComment( "glUnlockArraysEXT\n" );
 	}
 }
 
@@ -1777,7 +1466,11 @@
 	//
 	GL_Cull( input->shader->cullType );
 
+	//
+	// set color, pointers, and lock
+	//
 	GL_State( GLS_DEFAULT );
+	qglVertexPointer( 3, GL_FLOAT, 16, input->xyz );
 
 #ifdef REPLACE_MODE
 	qglDisableClientState( GL_COLOR_ARRAY );
@@ -1787,9 +1480,19 @@
 	qglEnableClientState( GL_COLOR_ARRAY );
 	qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.constantColor255 );
 #endif
+
+	//
+	// select base stage
+	//
 	GL_SelectTexture( 0 );
+
+	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
 	R_BindAnimatedImage( &tess.xstages[0]->bundle[0] );
-	
+	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][0] );
+
+	//
+	// configure second stage
+	//
 	GL_SelectTexture( 1 );
 	qglEnable( GL_TEXTURE_2D );
 	if ( r_lightmap->integer ) {
@@ -1798,117 +1501,51 @@
 		GL_TexEnv( GL_MODULATE );
 	}
 	R_BindAnimatedImage( &tess.xstages[0]->bundle[1] );
+	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][1] );
 
-	if ( tess.renderVBO ) {
-		GL_VBO( input->renderVBO->vbo, input->renderVBO->ibo );
-		//
-		// set color, pointers, and lock
-		//
-		qglVertexPointer( 3, GL_FLOAT, 16, NULL );
-		
-		//
-		// select base stage
-		//
-		GL_SelectTexture( 0 );
-		
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglTexCoordPointer( 2, GL_FLOAT, 8,
-				    (byte *)NULL +
-				    input->renderVBO->numVertexes *
-				    (sizeof(vec4_t) + sizeof(vec4_t)) );
-		
-		//
-		// configure second stage
-		//
-		GL_SelectTexture( 1 );
-		qglEnable( GL_TEXTURE_2D );
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglTexCoordPointer( 2, GL_FLOAT, 8,
-				    (byte *)NULL +
-				    input->renderVBO->numVertexes *
-				    (sizeof(vec4_t) + sizeof(vec4_t) + sizeof(vec2_t)) );
-		
-		R_DrawElements( input->renderVBO->numIndexes, NULL, input->renderVBO->numVertexes-1, input->renderVBO->numVertexes > 65536 ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT );
-		
-		//
-		// disable texturing on TEXTURE1, then select TEXTURE0
-		//
-		qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglDisable( GL_TEXTURE_2D );
+	//
+	// lock arrays
+	//
+	if ( qglLockArraysEXT ) {
+		qglLockArraysEXT(0, input->numVertexes);
+		GLimp_LogComment( "glLockArraysEXT\n" );
+	}
 
-		GL_SelectTexture( 0 );
+	R_DrawElements( input->numIndexes, input->indexes );
+
+	//
+	// disable texturing on TEXTURE1, then select TEXTURE0
+	//
+	qglDisable( GL_TEXTURE_2D );
+	qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
+
+	GL_SelectTexture( 0 );
 #ifdef REPLACE_MODE
-		GL_TexEnv( GL_MODULATE );
-		qglShadeModel( GL_SMOOTH );
+	GL_TexEnv( GL_MODULATE );
+	qglShadeModel( GL_SMOOTH );
 #endif
+
+	// 
+	// now do any dynamic lighting needed
+	//
+	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE ) {
+		ProjectDlightTexture();
 	}
-	if ( tess.numIndexes > 0 ) {
-		GL_VBO( 0, 0 );
 
-		//
-		// set color, pointers, and lock
-		//
-		qglVertexPointer( 3, GL_FLOAT, 16, input->xyz );
-		
-		//
-		// select base stage
-		//
-		GL_SelectTexture( 0 );
-		
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][0] );
-		
-		//
-		// configure second stage
-		//
-		GL_SelectTexture( 1 );
-		qglEnable( GL_TEXTURE_2D );
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][1] );
-		
-		//
-		// lock arrays
-		//
-		if ( qglLockArraysEXT ) {
-			qglLockArraysEXT(0, input->numVertexes);
-			GLimp_LogComment( "glLockArraysEXT\n" );
-		}
-		
-		R_DrawElements( input->numIndexes, input->indexes, input->numVertexes-1, GL_UNSIGNED_INT );
-		
-		//
-		// disable texturing on TEXTURE1, then select TEXTURE0
-		//
-		qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglDisable( GL_TEXTURE_2D );
-		
-		GL_SelectTexture( 0 );
-#ifdef REPLACE_MODE
-		GL_TexEnv( GL_MODULATE );
-		qglShadeModel( GL_SMOOTH );
-#endif
-		
-		// 
-		// now do any dynamic lighting needed
-		//
-		if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE ) {
-			ProjectDlightTexture();
-		}
-		
-		//
-		// now do fog
-		//
-		if ( tess.fogNum && tess.shader->fogPass ) {
-			RB_FogPass();
-		}
+	//
+	// now do fog
+	//
+	if ( tess.fogNum && tess.shader->fogPass ) {
+		RB_FogPass();
+	}
 
-		//
-		// unlock arrays
-		//
-		if ( qglUnlockArraysEXT ) {
-			qglUnlockArraysEXT();
-			GLimp_LogComment( "glUnlockArraysEXT\n" );
-		}
+	//
+	// unlock arrays
+	//
+	if ( qglUnlockArraysEXT ) {
+		qglUnlockArraysEXT();
+		GLimp_LogComment( "glUnlockArraysEXT\n" );
 	}
 }
 
@@ -1920,7 +1557,7 @@
 
 	input = &tess;
 
-	if (input->numIndexes == 0 && !input->renderVBO ) {
+	if (input->numIndexes == 0) {
 		return;
 	}
 
@@ -1958,21 +1595,13 @@
 	// draw debugging stuff
 	//
 	if ( r_showtris->integer ) {
-		if ( input->renderVBO )
-			DrawTrisVBO (input->renderVBO);
-		if ( input->numIndexes > 0 )
-			DrawTris ();
+		DrawTris (input);
 	}
 	if ( r_shownormals->integer ) {
-		DrawNormals ();
+		DrawNormals (input);
 	}
-	if ( r_flush->integer ) {
-		qglFlush();
-	}
-
 	// clear shader so we can tell we don't have any unclosed surfaces
 	tess.numIndexes = 0;
-	tess.renderVBO = NULL;
 
 	GLimp_LogComment( "----------\n" );
 }
diff -r 87f98d895296 -r 91f0a3d9f930 src/renderer/tr_shader.c
--- a/src/renderer/tr_shader.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/renderer/tr_shader.c	Sat Jun 06 02:45:31 2009 +0800
@@ -835,10 +835,7 @@
 			}
 			else if ( !Q_stricmp( token, "identityLighting" ) )
 			{
-				if ( r_overBrightBits->integer == 0 )
-					stage->rgbGen = CGEN_IDENTITY;
-				else
-					stage->rgbGen = CGEN_IDENTITY_LIGHTING;
+				stage->rgbGen = CGEN_IDENTITY_LIGHTING;
 			}
 			else if ( !Q_stricmp( token, "entity" ) )
 			{
@@ -1013,35 +1010,6 @@
 		}
 	}
 
-	// I assume DST_ALPHA is always 1, so I just replace it with GL_ONE
-	if ( blendSrcBits == GLS_SRCBLEND_DST_ALPHA )
-		blendSrcBits = GLS_SRCBLEND_ONE;
-	else if ( blendSrcBits == GLS_SRCBLEND_ONE_MINUS_DST_ALPHA )
-		blendSrcBits = GLS_SRCBLEND_ZERO;
-
-	if ( blendDstBits == GLS_DSTBLEND_DST_ALPHA )
-		blendDstBits = GLS_DSTBLEND_ONE;
-	else if ( blendDstBits == GLS_DSTBLEND_ONE_MINUS_DST_ALPHA )
-		blendDstBits = GLS_DSTBLEND_ZERO;
-
-	// If the image has no (real) alpha channel, we can do the same
-	// for SRC_ALPHA
-	if ( !stage->bundle[0].image[0]->hasAlpha &&
-	     stage->alphaGen == AGEN_IDENTITY) {
-		if ( blendSrcBits == GLS_SRCBLEND_SRC_ALPHA )
-			blendSrcBits = GLS_SRCBLEND_ONE;
-		else if ( blendSrcBits == GLS_SRCBLEND_ONE_MINUS_SRC_ALPHA )
-			blendSrcBits = GLS_SRCBLEND_ZERO;
-		
-		if ( blendDstBits == GLS_DSTBLEND_SRC_ALPHA )
-			blendDstBits = GLS_DSTBLEND_ONE;
-		else if ( blendDstBits == GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA )
-			blendDstBits = GLS_DSTBLEND_ZERO;
-
-		// also alphaFunc makes no sense without alpha
-		atestBits = 0;
-	}
-
 	//
 	// if cgen isn't explicitly specified, use either identity or identitylighting
 	//
@@ -1055,6 +1023,7 @@
 		}
 	}
 
+
 	//
 	// implicitly assume that a GL_ONE GL_ZERO blend mask disables blending
 	//
@@ -1066,7 +1035,7 @@
 	}
 
 	// decide which agens we can skip
-	if ( stage->alphaGen == AGEN_IDENTITY ) {
+	if ( stage->alphaGen == CGEN_IDENTITY ) {
 		if ( stage->rgbGen == CGEN_IDENTITY
 			|| stage->rgbGen == CGEN_LIGHTING_DIFFUSE ) {
 			stage->alphaGen = AGEN_SKIP;
@@ -1665,11 +1634,6 @@
 */
 static void ComputeStageIteratorFunc( void )
 {
-	int stage;
-	int units = glConfig.numTextureUnits;
-
-	if (!units) units = 1;
-	
 	shader.optimalStageIteratorFunc = RB_StageIteratorGeneric;
 
 	//
@@ -1681,153 +1645,6 @@
 		goto done;
 	}
 
-	shader.needsNormal = qfalse;
-	shader.needsST1 = qfalse;
-	shader.needsST2 = qfalse;
-	shader.needsColor = qfalse;
-	shader.useVBO = qfalse;
-	
-	if ( glConfig.vertexBufferObjects ) {
-		shader.useVBO = qtrue;
-	}
-	
-	// check all deformation stages
-	for ( stage = 0; stage < shader.numDeforms; stage ++ ) {
-		switch ( shader.deforms[stage].deformation ) {
-		case DEFORM_NONE:
-			break;
-		case DEFORM_WAVE:
-		case DEFORM_NORMALS:
-		case DEFORM_BULGE:
-			shader.needsNormal = qtrue;
-			shader.useVBO = qfalse;
-			break;
-		case DEFORM_MOVE:
-		case DEFORM_PROJECTION_SHADOW:
-		case DEFORM_AUTOSPRITE:
-		case DEFORM_AUTOSPRITE2:
-		case DEFORM_TEXT0:
-		case DEFORM_TEXT1:
-		case DEFORM_TEXT2:
-		case DEFORM_TEXT3:
-		case DEFORM_TEXT4:
-		case DEFORM_TEXT5:
-		case DEFORM_TEXT6:
-		case DEFORM_TEXT7:
-			shader.useVBO = qfalse;
-			break;
-		}
-	}
-	
-	// check all shader stages
-	for ( stage = 0; stage < MAX_SHADER_STAGES; stage++ )
-	{
-		shaderStage_t *pStage = &stages[stage];
-		int           bundle;
-		
-		if ( !pStage->active )
-		{
-			break;
-		}
-		
-		switch ( pStage->rgbGen ) {
-		case CGEN_IDENTITY_LIGHTING:
-		case CGEN_IDENTITY:
-		case CGEN_ENTITY:
-		case CGEN_ONE_MINUS_ENTITY:
-		case CGEN_CONST:
-			// constant color, VBO possible
-			break;
-		case CGEN_EXACT_VERTEX:
-		case CGEN_VERTEX:
-			// vertex colors, VBO possible
-			shader.needsColor = qtrue;
-			break;
-		case CGEN_LIGHTING_DIFFUSE:
-			// normals needed, no VBO possible
-			shader.needsNormal = qtrue;
-			shader.useVBO = qfalse;
-			break;
-		case CGEN_ONE_MINUS_VERTEX:
-			// vertex colors needed, no VBO
-			shader.needsColor = qtrue;
-			shader.useVBO = qfalse;
-			break;
-		case CGEN_BAD:
-		case CGEN_WAVEFORM:
-		case CGEN_FOG:
-			// no vertex colors needed, no VBO
-			shader.useVBO = qfalse;
-			break;
-		}
-
-		switch ( pStage->alphaGen ) {
-		case AGEN_SKIP:
-			break;
-		case AGEN_IDENTITY:
-		case AGEN_ENTITY:
-		case AGEN_ONE_MINUS_ENTITY:
-		case AGEN_CONST:
-			if ( pStage->rgbGen == CGEN_VERTEX ||
-			     pStage->rgbGen == CGEN_EXACT_VERTEX ) {
-				// cannot combine const alpha with vertex color
-				shader.useVBO = qfalse;
-			}
-			break;
-		case AGEN_VERTEX:
-			shader.needsColor = qtrue;
-			if ( pStage->rgbGen != CGEN_VERTEX &&
-			     pStage->rgbGen != CGEN_EXACT_VERTEX ) {
-				// cannot combine vertex alpha with const color
-				shader.useVBO = qfalse;
-			}
-			break;
-		case AGEN_ONE_MINUS_VERTEX:
-			shader.useVBO = qfalse;
-			shader.needsColor = qtrue;
-			break;
-		case AGEN_LIGHTING_SPECULAR:
-		case AGEN_PORTAL:
-			shader.useVBO = qfalse;
-			shader.needsNormal = qtrue;
-			break;
-		case AGEN_WAVEFORM:
-			shader.useVBO = qfalse;
-			break;
-		}
-		
-		for ( bundle = 0; bundle < units; bundle++ ) {
-			if ( bundle > 0 && !pStage->bundle[bundle].multitextureEnv )
-				break;
-			
-			switch ( pStage->bundle[bundle].tcGen ) {
-			case TCGEN_BAD:
-				break;
-			case TCGEN_IDENTITY:
-			case TCGEN_VECTOR:
-			case TCGEN_FOG:
-				shader.useVBO = qfalse;
-				break;
-			case TCGEN_LIGHTMAP:
-				shader.needsST2 = qtrue;
-				break;
-			case TCGEN_TEXTURE:
-				shader.needsST1 = qtrue;
-				break;
-			case TCGEN_ENVIRONMENT_MAPPED:
-				shader.needsNormal = qtrue;
-				shader.useVBO = qfalse;
-				break;
-			}
-			if ( pStage->bundle[bundle].numTexMods > 0 )
-				shader.useVBO = qfalse;
-		}
-	}
-
-	// no VBOs for 0-stage shaders (fog)
-	if ( stage == 0 )
-		shader.useVBO = qfalse;
-
 	if ( r_ignoreFastPath->integer )
 	{
 		return;
@@ -1846,7 +1663,7 @@
 				{
 					if ( !shader.polygonOffset )
 					{
-						if ( !stages[0].bundle[1].multitextureEnv )
+						if ( !shader.multitextureEnv )
 						{
 							if ( !shader.numDeforms )
 							{
@@ -1874,7 +1691,7 @@
 				{
 					if ( !shader.numDeforms )
 					{
-						if ( stages[0].bundle[1].multitextureEnv )
+						if ( shader.multitextureEnv )
 						{
 							shader.optimalStageIteratorFunc = RB_StageIteratorLightmappedMultitexture;
 							goto done;
@@ -1932,171 +1749,117 @@
 ================
 CollapseMultitexture
 
-Attempt to combine several stages into a single multitexture stage
+Attempt to combine two stages into a single multitexture stage
 FIXME: I think modulated add + modulated add collapses incorrectly
 =================
 */
-static int CollapseMultitexture( void ) {
-	int stage, bundle;
+static qboolean CollapseMultitexture( void ) {
 	int abits, bbits;
 	int i;
 	textureBundle_t tmpBundle;
 
-	stage = 0;
-	bundle = 0;
+	if ( !qglActiveTextureARB ) {
+		return qfalse;
+	}
 
-	while( stages[stage].active ) {
-		if ( bundle + 1 >= glConfig.numTextureUnits ) {
-			// can't add next stage, no more texture units
-			stage++;
-			bundle = 0;
-			continue;
+	// make sure both stages are active
+	if ( !stages[0].active || !stages[1].active ) {
+		return qfalse;
+	}
+
+	// on voodoo2, don't combine different tmus
+	if ( glConfig.driverType == GLDRV_VOODOO ) {
+		if ( stages[0].bundle[0].image[0]->TMU ==
+			 stages[1].bundle[0].image[0]->TMU ) {
+			return qfalse;
 		}
-		
-		// make sure both stages are active
-		if ( !stages[stage + 1].active ) {
-			// can't add next stage, it doesn't exist
-			stage++;
-			bundle = 0;
-			continue;
+	}
+
+	abits = stages[0].stateBits;
+	bbits = stages[1].stateBits;
+
+	// make sure that both stages have identical state other than blend modes
+	if ( ( abits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) !=
+		( bbits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) ) {
+		return qfalse;
+	}
+
+	abits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+	bbits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+
+	// search for a valid multitexture blend function
+	for ( i = 0; collapse[i].blendA != -1 ; i++ ) {
+		if ( abits == collapse[i].blendA
+			&& bbits == collapse[i].blendB ) {
+			break;
 		}
+	}
 
-		// on voodoo2, don't combine different tmus
-		if ( glConfig.driverType == GLDRV_VOODOO ) {
-			if ( stages[stage].bundle[0].image[0]->TMU ==
-			     stages[stage + 1].bundle[0].image[0]->TMU ) {
-				stage++;
-				bundle = 0;
-				continue;
-			}
+	// nothing found
+	if ( collapse[i].blendA == -1 ) {
+		return qfalse;
+	}
+
+	// GL_ADD is a separate extension
+	if ( collapse[i].multitextureEnv == GL_ADD && !glConfig.textureEnvAddAvailable ) {
+		return qfalse;
+	}
+
+	// make sure waveforms have identical parameters
+	if ( ( stages[0].rgbGen != stages[1].rgbGen ) ||
+		( stages[0].alphaGen != stages[1].alphaGen ) )  {
+		return qfalse;
+	}
+
+	// an add collapse can only have identity colors
+	if ( collapse[i].multitextureEnv == GL_ADD && stages[0].rgbGen != CGEN_IDENTITY ) {
+		return qfalse;
+	}
+
+	if ( stages[0].rgbGen == CGEN_WAVEFORM )
+	{
+		if ( memcmp( &stages[0].rgbWave,
+					 &stages[1].rgbWave,
+					 sizeof( stages[0].rgbWave ) ) )
+		{
+			return qfalse;
 		}
+	}
+	if ( stages[0].alphaGen == CGEN_WAVEFORM )
+	{
+		if ( memcmp( &stages[0].alphaWave,
+					 &stages[1].alphaWave,
+					 sizeof( stages[0].alphaWave ) ) )
+		{
+			return qfalse;
+		}
+	}
 
-		abits = stages[stage].stateBits;
-		bbits = stages[stage + 1].stateBits;
-		/*
-		// can't combine if the second stage has an alpha test
-		if ( bbits & GLS_ATEST_BITS ) {
-			stage++;
-			bundle = 0;
-			continue;
-		}
 
-		// can combine alphafunc only if depthwrite is enabled and
-		// the second stage has depthfunc equal
-		if ( abits & GLS_ATEST_BITS ) {
-			if (!((abits & GLS_DEPTHMASK_TRUE) &&
-			      (bbits & GLS_DEPTHFUNC_EQUAL)) ) {
-				stage++;
-				bundle = 0;
-				continue;
-			}
-		} else {
-			if ( (abits & GLS_DEPTHFUNC_EQUAL) !=
-			     (bbits & GLS_DEPTHFUNC_EQUAL) ) {
-				stage++;
-				bundle = 0;
-				continue;
-			}
-		}
-		*/
-		// make sure that both stages have identical state other than blend modes
-		if ( ( abits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) !=
-		     ( bbits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) ) {
-			stage++;
-			bundle = 0;
-			continue;
-		}
-		
-		abits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
-		bbits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
-		
-		// search for a valid multitexture blend function
-		for ( i = 0; collapse[i].blendA != -1 ; i++ ) {
-			if ( abits == collapse[i].blendA
-			     && bbits == collapse[i].blendB ) {
-				break;
-			}
-		}
-		
-		// nothing found
-		if ( collapse[i].blendA == -1 ) {
-			stage++;
-			bundle = 0;
-			continue;
-		}
-		
-		// GL_ADD is a separate extension
-		if ( collapse[i].multitextureEnv == GL_ADD && !glConfig.textureEnvAddAvailable ) {
-			stage++;
-			bundle = 0;
-			continue;
-		}
-		
-		// make sure waveforms have identical parameters
-		if ( ( stages[stage].rgbGen != stages[stage + 1].rgbGen ) ||
-		     ( stages[stage].alphaGen != stages[stage + 1].alphaGen ) )  {
-			stage++;
-			bundle = 0;
-			continue;
-		}
-		
-		// an add collapse can only have identity colors
-		if ( collapse[i].multitextureEnv == GL_ADD && stages[stage].rgbGen != CGEN_IDENTITY ) {
-			stage++;
-			bundle = 0;
-			continue;
-		}
-		
-		if ( stages[stage].rgbGen == CGEN_WAVEFORM )
-		{
-			if ( memcmp( &stages[stage].rgbWave,
-				     &stages[stage + 1].rgbWave,
-				     sizeof( stages[stage].rgbWave ) ) )
-			{
-				stage++;
-				bundle = 0;
-				continue;
-			}
-		}
-		if ( stages[stage].alphaGen == CGEN_WAVEFORM )
-		{
-			if ( memcmp( &stages[stage].alphaWave,
-				     &stages[stage + 1].alphaWave,
-				     sizeof( stages[stage].alphaWave ) ) )
-			{
-				stage++;
-				bundle = 0;
-				continue;
-			}
-		}
-		
-		
-		// make sure that lightmaps are in bundle 1 for 3dfx
-		if ( bundle == 0 && stages[stage].bundle[0].isLightmap )
-		{
-			tmpBundle = stages[stage].bundle[0];
-			stages[stage].bundle[0] = stages[stage + 1].bundle[0];
-			stages[stage].bundle[1] = tmpBundle;
-		}
-		else
-		{
-			stages[stage].bundle[bundle + 1] = stages[stage + 1].bundle[0];
-		}
-		
-		// set the new blend state bits
-		stages[stage].bundle[bundle + 1].multitextureEnv = collapse[i].multitextureEnv;
-		stages[stage].stateBits &= ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
-		stages[stage].stateBits |= collapse[i].multitextureBlend;
+	// make sure that lightmaps are in bundle 1 for 3dfx
+	if ( stages[0].bundle[0].isLightmap )
+	{
+		tmpBundle = stages[0].bundle[0];
+		stages[0].bundle[0] = stages[1].bundle[0];
+		stages[0].bundle[1] = tmpBundle;
+	}
+	else
+	{
+		stages[0].bundle[1] = stages[1].bundle[0];
+	}
 
-		bundle++;
+	// set the new blend state bits
+	shader.multitextureEnv = collapse[i].multitextureEnv;
+	stages[0].stateBits &= ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+	stages[0].stateBits |= collapse[i].multitextureBlend;
 
-		//
-		// move down subsequent shaders
-		//
-		memmove( &stages[stage + 1], &stages[stage + 2], sizeof( stages[0] ) * ( MAX_SHADER_STAGES - stage - 2 ) );
-		Com_Memset( &stages[MAX_SHADER_STAGES-1], 0, sizeof( stages[0] ) );
-	}
-	return stage;
+	//
+	// move down subsequent shaders
+	//
+	memmove( &stages[1], &stages[2], sizeof( stages[0] ) * ( MAX_SHADER_STAGES - 2 ) );
+	Com_Memset( &stages[MAX_SHADER_STAGES-1], 0, sizeof( stages[0] ) );
+
+	return qtrue;
 }
 
 /*
@@ -2514,8 +2277,8 @@
 	//
 	// look for multitexture potential
 	//
-	if ( stage > 1 ) {
-		stage = CollapseMultitexture();
+	if ( stage > 1 && CollapseMultitexture() ) {
+		stage--;
 	}
 
 	if ( shader.lightmapIndex >= 0 && !hasLightmapStage ) {
@@ -2572,7 +2335,7 @@
 			return p;
 		}
 	}
-#if 0
+
 	p = s_shaderText;
 
 	if ( !p ) {
@@ -2594,7 +2357,7 @@
 			SkipBracedSection( &p );
 		}
 	}
-#endif
+
 	return NULL;
 }
 
@@ -2726,7 +2489,6 @@
 	shader.needsST1 = qtrue;
 	shader.needsST2 = qtrue;
 	shader.needsColor = qtrue;
-	shader.useVBO = qfalse;
 
 	//
 	// attempt to define shader from an explicit parameter file
@@ -2898,7 +2660,6 @@
 	shader.needsST1 = qtrue;
 	shader.needsST2 = qtrue;
 	shader.needsColor = qtrue;
-	shader.useVBO = qfalse;
 
 	//
 	// create the default shading commands
@@ -3131,7 +2892,7 @@
 ===============
 */
 void	R_ShaderList_f (void) {
-	int			i, j, k;
+	int			i;
 	int			count;
 	shader_t	*shader;
 
@@ -3152,6 +2913,15 @@
 		} else {
 			ri.Printf (PRINT_ALL, "  ");
 		}
+		if ( shader->multitextureEnv == GL_ADD ) {
+			ri.Printf( PRINT_ALL, "MT(a) " );
+		} else if ( shader->multitextureEnv == GL_MODULATE ) {
+			ri.Printf( PRINT_ALL, "MT(m) " );
+		} else if ( shader->multitextureEnv == GL_DECAL ) {
+			ri.Printf( PRINT_ALL, "MT(d) " );
+		} else {
+			ri.Printf( PRINT_ALL, "      " );
+		}
 		if ( shader->explicitlyDefined ) {
 			ri.Printf( PRINT_ALL, "E " );
 		} else {
@@ -3175,21 +2945,6 @@
 		} else {
 			ri.Printf (PRINT_ALL,  ": %s\n", shader->name);
 		}
-		for ( j = 0; j < shader->numUnfoggedPasses; j++ ) {
-			shaderStage_t *stage = shader->stages[j];
-			
-			if ( !stage->active )
-				break;
-
-			ri.Printf (PRINT_DEVELOPER, " %d\n" );
-			
-			for ( k = 0; i < NUM_TEXTURE_BUNDLES; k++ ) {
-				if ( !stage->bundle[k].image[0] )
-					break;
-
-				ri.Printf (PRINT_DEVELOPER, "  %s\n", stage->bundle[k].image[0]->imgName );
-			}
-		}
 		count++;
 	}
 	ri.Printf (PRINT_ALL, "%i total shaders\n", count);
diff -r 87f98d895296 -r 91f0a3d9f930 src/renderer/tr_surface.c
--- a/src/renderer/tr_surface.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/renderer/tr_surface.c	Sat Jun 06 02:45:31 2009 +0800
@@ -45,7 +45,6 @@
 
 
 //============================================================================
-vec4_t vec4Scratch ALIGNED((16));
 
 
 /*
@@ -54,8 +53,8 @@
 ==============
 */
 void RB_CheckOverflow( int verts, int indexes ) {
-	if (tess.numVertexes + verts < tess.maxVertexes
-	    && tess.numIndexes + indexes < tess.maxVertexes) {
+	if (tess.numVertexes + verts < SHADER_MAX_VERTEXES
+		&& tess.numIndexes + indexes < SHADER_MAX_INDEXES) {
 		return;
 	}
 
@@ -194,61 +193,29 @@
 RB_SurfacePolychain
 =============
 */
-void RB_SurfacePolychain( surfaceType_t *surface ) {
-	srfPoly_t *p = (srfPoly_t *)surface;
+void RB_SurfacePolychain( srfPoly_t *p ) {
 	int		i;
 	int		numv;
-	GLuint		*indexPtr;
-	GLushort	*indexPtrShort;
-	vec4_t		*xyzPtr, *normalPtr;
-	vec2_t		*texCoordPtr;
-	color4ub_t	*vertexColorPtr;
-
-	if ( !tess.indexPtr ) {
-		tess.numVertexes += p->numVerts;
-		tess.numIndexes  += 3*(p->numVerts - 2);
-		return;
-	}
 
 	RB_CHECKOVERFLOW( p->numVerts, 3*(p->numVerts - 2) );
 
-	indexPtr = ptrPlusOffset(tess.indexPtr, tess.indexInc * tess.numIndexes);
-	xyzPtr = ptrPlusOffset(tess.xyzPtr, tess.xyzInc * tess.numVertexes);
-	normalPtr = ptrPlusOffset(tess.normalPtr, tess.normalInc * tess.numVertexes);
-	texCoordPtr = ptrPlusOffset(tess.texCoordPtr, tess.texCoordInc * tess.numVertexes);
-	vertexColorPtr = ptrPlusOffset(tess.vertexColorPtr, tess.vertexColorInc * tess.numVertexes);
-
 	// fan triangles into the tess array
 	numv = tess.numVertexes;
 	for ( i = 0; i < p->numVerts; i++ ) {
-		VectorCopy ( p->verts[i].xyz, *(vec3_t *)xyzPtr );
-		xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
-		Vector2Copy( p->verts[i].st,  *texCoordPtr );
-		texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
-		*(int *)vertexColorPtr = *(int *)p->verts[ i ].modulate;
-		vertexColorPtr = ptrPlusOffset(vertexColorPtr, tess.vertexColorInc);
+		VectorCopy( p->verts[i].xyz, tess.xyz[numv] );
+		tess.texCoords[numv][0][0] = p->verts[i].st[0];
+		tess.texCoords[numv][0][1] = p->verts[i].st[1];
+		*(int *)&tess.vertexColors[numv] = *(int *)p->verts[ i ].modulate;
 
 		numv++;
 	}
 
 	// generate fan indexes into the tess array
-	if ( tess.indexInc == sizeof(GLushort) ) {
-		indexPtrShort = (GLushort *)indexPtr;
-		for ( i = 0; i < p->numVerts-2; i++ ) {
-			indexPtrShort[0] = (GLushort)(tess.numVertexes);
-			indexPtrShort[1] = (GLushort)(tess.numVertexes + i + 1);
-			indexPtrShort[2] = (GLushort)(tess.numVertexes + i + 2);
-			indexPtrShort += 3;
-			tess.numIndexes += 3;
-		}
-	} else {
-		for ( i = 0; i < p->numVerts-2; i++ ) {
-			indexPtr[0] = tess.numVertexes;
-			indexPtr[1] = tess.numVertexes + i + 1;
-			indexPtr[2] = tess.numVertexes + i + 2;
-			indexPtr += 3;
-			tess.numIndexes += 3;
-		}
+	for ( i = 0; i < p->numVerts-2; i++ ) {
+		tess.indexes[tess.numIndexes + 0] = tess.numVertexes;
+		tess.indexes[tess.numIndexes + 1] = tess.numVertexes + i + 1;
+		tess.indexes[tess.numIndexes + 2] = tess.numVertexes + i + 2;
+		tess.numIndexes += 3;
 	}
 
 	tess.numVertexes = numv;
@@ -260,75 +227,55 @@
 RB_SurfaceTriangles
 =============
 */
-void RB_SurfaceTriangles( surfaceType_t *surface ) {
-	srfTriangles_t *srf = (srfTriangles_t *)surface;
+void RB_SurfaceTriangles( srfTriangles_t *srf ) {
 	int			i;
 	drawVert_t	*dv;
+	float		*xyz, *normal, *texCoords;
+	byte		*color;
 	int			dlightBits;
-	GLuint		*indexPtr;
-	GLushort	*indexPtrShort;
-	vec4_t		*xyzPtr, *normalPtr;
-	vec2_t		*texCoordPtr, *texCoord2Ptr;
-	color4ub_t	*vertexColorPtr;
-	int		*vertexDlightBitPtr;
+	qboolean	needsNormal;
 
 	dlightBits = srf->dlightBits[backEnd.smpFrame];
 	tess.dlightBits |= dlightBits;
 
-	if ( !tess.indexPtr ) {
-		tess.numVertexes += srf->numVerts;
-		tess.numIndexes  += srf->numIndexes;
-		return;
-	}
+	RB_CHECKOVERFLOW( srf->numVerts, srf->numIndexes );
 
-	RB_CHECKOVERFLOW( srf->numVerts, srf->numIndexes );
-	
-	indexPtr = ptrPlusOffset(tess.indexPtr, tess.indexInc * tess.numIndexes);
-	xyzPtr = ptrPlusOffset(tess.xyzPtr, tess.xyzInc * tess.numVertexes);
-	normalPtr = ptrPlusOffset(tess.normalPtr, tess.normalInc * tess.numVertexes);
-	texCoordPtr = ptrPlusOffset(tess.texCoordPtr, tess.texCoordInc * tess.numVertexes);
-	texCoord2Ptr = ptrPlusOffset(tess.texCoord2Ptr, tess.texCoord2Inc * tess.numVertexes);
-	vertexColorPtr = ptrPlusOffset(tess.vertexColorPtr, tess.vertexColorInc * tess.numVertexes);
-	vertexDlightBitPtr = ptrPlusOffset(tess.vertexDlightBitPtr, tess.vertexDlightBitInc * tess.numVertexes);
-
-	if ( tess.indexInc == sizeof(GLushort) ) {
-		indexPtrShort = (GLushort *)indexPtr;
-		for ( i = 0 ; i < srf->numIndexes ; i += 3 ) {
-			indexPtrShort[ i + 0 ] = (GLushort)(tess.numVertexes + srf->indexes[ i + 0 ]);
-			indexPtrShort[ i + 1 ] = (GLushort)(tess.numVertexes + srf->indexes[ i + 1 ]);
-			indexPtrShort[ i + 2 ] = (GLushort)(tess.numVertexes + srf->indexes[ i + 2 ]);
-		}
-	} else {
-		for ( i = 0 ; i < srf->numIndexes ; i += 3 ) {
-			indexPtr[ i + 0 ] = tess.numVertexes + srf->indexes[ i + 0 ];
-			indexPtr[ i + 1 ] = tess.numVertexes + srf->indexes[ i + 1 ];
-			indexPtr[ i + 2 ] = tess.numVertexes + srf->indexes[ i + 2 ];
-		}
+	for ( i = 0 ; i < srf->numIndexes ; i += 3 ) {
+		tess.indexes[ tess.numIndexes + i + 0 ] = tess.numVertexes + srf->indexes[ i + 0 ];
+		tess.indexes[ tess.numIndexes + i + 1 ] = tess.numVertexes + srf->indexes[ i + 1 ];
+		tess.indexes[ tess.numIndexes + i + 2 ] = tess.numVertexes + srf->indexes[ i + 2 ];
 	}
 	tess.numIndexes += srf->numIndexes;
-	
+
 	dv = srf->verts;
-	
-	for ( i = 0 ; i < srf->numVerts ; i++, dv++ ) {
-		VectorCopy( dv->xyz, *(vec3_t *)xyzPtr );
-		xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
-	  
-		VectorCopy( dv->normal, *(vec3_t *)normalPtr );
-		normalPtr = ptrPlusOffset(normalPtr, tess.normalInc);
-	  
-		Vector2Copy( dv->st,       *texCoordPtr );
-		texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
+	xyz = tess.xyz[ tess.numVertexes ];
+	normal = tess.normal[ tess.numVertexes ];
+	texCoords = tess.texCoords[ tess.numVertexes ][0];
+	color = tess.vertexColors[ tess.numVertexes ];
+	needsNormal = tess.shader->needsNormal;
 
-		Vector2Copy( dv->lightmap, *texCoord2Ptr );
-		texCoord2Ptr = ptrPlusOffset(texCoord2Ptr, tess.texCoord2Inc);
-	  
-		*(int *)vertexColorPtr = *(int *)dv->color;
-		vertexColorPtr = ptrPlusOffset(vertexColorPtr, tess.vertexColorInc);
+	for ( i = 0 ; i < srf->numVerts ; i++, dv++, xyz += 4, normal += 4, texCoords += 4, color += 4 ) {
+		xyz[0] = dv->xyz[0];
+		xyz[1] = dv->xyz[1];
+		xyz[2] = dv->xyz[2];
+
+		if ( needsNormal ) {
+			normal[0] = dv->normal[0];
+			normal[1] = dv->normal[1];
+			normal[2] = dv->normal[2];
+		}
+
+		texCoords[0] = dv->st[0];
+		texCoords[1] = dv->st[1];
+
+		texCoords[2] = dv->lightmap[0];
+		texCoords[3] = dv->lightmap[1];
+
+		*(int *)color = *(int *)dv->color;
 	}
 
 	for ( i = 0 ; i < srf->numVerts ; i++ ) {
-		*vertexDlightBitPtr = dlightBits;
-		vertexDlightBitPtr = ptrPlusOffset(vertexDlightBitPtr, tess.vertexDlightBitInc);
+		tess.vertexDlightBits[ tess.numVertexes + i] = dlightBits;
 	}
 
 	tess.numVertexes += srf->numVerts;
@@ -691,7 +638,6 @@
 {
 	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
 	float	*outXyz, *outNormal;
-	size_t	 incXyz, incNormal;
 	float	oldXyzScale ALIGNED(16);
 	float   newXyzScale ALIGNED(16);
 	float	oldNormalScale ALIGNED(16);
@@ -700,10 +646,8 @@
 	unsigned lat, lng;
 	int		numVerts;
 
-	outXyz = (float *)ptrPlusOffset(tess.xyzPtr, tess.numVertexes * tess.xyzInc);
-	outNormal = (float *)ptrPlusOffset(tess.normalPtr, tess.numVertexes * tess.normalInc);
-	incXyz = tess.xyzInc;
-	incNormal = tess.normalInc;
+	outXyz = tess.xyz[tess.numVertexes];
+	outNormal = tess.normal[tess.numVertexes];
 
 	newXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
 		+ (backEnd.currentEntity->e.frame * surf->numVerts * 4);
@@ -736,8 +680,7 @@
 		//
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
 			newXyz += 4, newNormals += 4,
-		       outXyz = ptrPlusOffset(outXYZ, incXyz),
-		       outNormal = ptrPlusOffset(outNormal, incNormal) )
+			outXyz += 4, outNormal += 4)
 		{
 			newNormalsLoadPermute = vec_lvsl(0,newXyz);
 			newNormalsStorePermute = vec_lvsr(0,outXyz);
@@ -782,8 +725,7 @@
 
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
 			oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
-		       outXyz = ptrPlusOffset(outXyz, incXyz),
-		       outNormal = ptrPlusOffset(outNormal, incNormal) )
+			outXyz += 4, outNormal += 4) 
 		{
 			vec3_t uncompressedOldNormal, uncompressedNewNormal;
 
@@ -816,7 +758,7 @@
 
 //			VectorNormalize (outNormal);
 		}
-    	VectorArrayNormalize((vec4_t *)tess->normalPtr + tess.numVertexes, numVerts);
+    	VectorArrayNormalize((vec4_t *)tess.normal[tess.numVertexes], numVerts);
    	}
 }
 #endif
@@ -826,7 +768,6 @@
 {
 	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
 	float	*outXyz, *outNormal;
-	size_t	 incXyz, incNormal;
 	float    oldXyzScale;
 	float    newXyzScale;
 	float    oldNormalScale;
@@ -835,10 +776,8 @@
 	unsigned lat, lng;
 	int	 numVerts;
 
-	outXyz = (float *)ptrPlusOffset(tess.xyzPtr, tess.numVertexes * tess.xyzInc);
-	outNormal = (float *)ptrPlusOffset(tess.normalPtr, tess.numVertexes * tess.normalInc);
-	incXyz = tess.xyzInc;
-	incNormal = tess.normalInc;
+	outXyz = tess.xyz[tess.numVertexes];
+	outNormal = tess.normal[tess.numVertexes];
 
 	newXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
 		+ (backEnd.currentEntity->e.frame * surf->numVerts * 4);
@@ -860,8 +799,7 @@
 		//
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
 			newXyz += 4, newNormals += 4,
-		       outXyz = ptrPlusOffset(outXyz, incXyz),
-		       outNormal = ptrPlusOffset(outNormal, incNormal) )
+			outXyz += 4, outNormal += 4) 
 		{
 			newNormalsVec = v8sLoadU(newXyz);
 			v8s_to_v4i(newNormalsVec, newNormalsIntVec, dummy);
@@ -899,8 +837,7 @@
 
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
 			oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
-		       outXyz = ptrPlusOffset(outXyz, incXyz),
-		       outNormal = ptrPlusOffset(outNormal, incNormal) )
+			outXyz += 4, outNormal += 4) 
 		{
 			vec3_t uncompressedOldNormal, uncompressedNewNormal;
 
@@ -933,8 +870,7 @@
 
 //			VectorNormalize (outNormal);
 		}
-		if ( tess.normalPtr )
-			VectorArrayNormalize(tess.normalPtr + tess.numVertexes, numVerts);
+    	VectorArrayNormalize((vec4_t *)tess.normal[tess.numVertexes], numVerts);
    	}
 }
 #endif
@@ -943,17 +879,14 @@
 {
 	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
 	float	*outXyz, *outNormal;
-	size_t	 incXyz, incNormal;
 	float	oldXyzScale, newXyzScale;
 	float	oldNormalScale, newNormalScale;
 	int		vertNum;
 	unsigned lat, lng;
 	int		numVerts;
 
-	outXyz = (float *)ptrPlusOffset(tess.xyzPtr, tess.numVertexes * tess.xyzInc);
-	outNormal = (float *)ptrPlusOffset(tess.normalPtr, tess.numVertexes * tess.normalInc);
-	incXyz = tess.xyzInc;
-	incNormal = tess.normalInc;
+	outXyz = tess.xyz[tess.numVertexes];
+	outNormal = tess.normal[tess.numVertexes];
 
 	newXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
 		+ (backEnd.currentEntity->e.frame * surf->numVerts * 4);
@@ -970,8 +903,7 @@
 		//
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
 			newXyz += 4, newNormals += 4,
-		       outXyz = ptrPlusOffset(outXyz, incXyz),
-		       outNormal = ptrPlusOffset(outNormal, incNormal) )
+			outXyz += 4, outNormal += 4) 
 		{
 
 			outXyz[0] = newXyz[0] * newXyzScale;
@@ -1004,8 +936,7 @@
 
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
 			oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
-		       outXyz = ptrPlusOffset(outXyz, incXyz),
-		       outNormal = ptrPlusOffset(outNormal, incNormal) )
+			outXyz += 4, outNormal += 4) 
 		{
 			vec3_t uncompressedOldNormal, uncompressedNewNormal;
 
@@ -1038,8 +969,7 @@
 
 //			VectorNormalize (outNormal);
 		}
-		if ( tess.normalPtr )
-			VectorArrayNormalize(tess.normalPtr + tess.numVertexes, numVerts);
+    	VectorArrayNormalize((vec4_t *)tess.normal[tess.numVertexes], numVerts);
    	}
 }
 
@@ -1058,7 +988,6 @@
 	int				indexes;
 	int				Bob, Doug;
 	int				numVerts;
-	vec2_t		*texCoordPtr;
 
 	if (  backEnd.currentEntity->e.oldframe == backEnd.currentEntity->e.frame ) {
 		backlerp = 0;
@@ -1066,12 +995,6 @@
 		backlerp = backEnd.currentEntity->e.backlerp;
 	}
 
-	if ( !tess.indexPtr ) {
-		tess.numVertexes += surface->numVerts;
-		tess.numIndexes  += 3*surface->numTriangles;
-		return;
-	}
-
 	RB_CHECKOVERFLOW( surface->numVerts, surface->numTriangles*3 );
 
 	LerpMeshVertexes_altivec (surface, backlerp);
@@ -1086,13 +1009,11 @@
 	tess.numIndexes += indexes;
 
 	texCoords = (float *) ((byte *)surface + surface->ofsSt);
-	texCoordPtr = ptrPlusOffset(tess.texCoordPtr, Doug * tess.texCoordInc);
 
 	numVerts = surface->numVerts;
 	for ( j = 0; j < numVerts; j++ ) {
-		(*texCoordPtr)[0] = texCoords[j*2+0];
-		(*texCoordPtr)[1] = texCoords[j*2+1];
-		texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
+		tess.texCoords[Doug + j][0][0] = texCoords[j*2+0];
+		tess.texCoords[Doug + j][0][1] = texCoords[j*2+1];
 		// FIXME: fill in lightmapST for completeness?
 	}
 
@@ -1110,7 +1031,6 @@
 	int				indexes;
 	int				Bob, Doug;
 	int				numVerts;
-	vec2_t		*texCoordPtr;
 
 	if (  backEnd.currentEntity->e.oldframe == backEnd.currentEntity->e.frame ) {
 		backlerp = 0;
@@ -1118,12 +1038,6 @@
 		backlerp = backEnd.currentEntity->e.backlerp;
 	}
 
-	if ( !tess.indexPtr ) {
-		tess.numVertexes += surface->numVerts;
-		tess.numIndexes  += 3*surface->numTriangles;
-		return;
-	}
-
 	RB_CHECKOVERFLOW( surface->numVerts, surface->numTriangles*3 );
 
 	LerpMeshVertexes_sse2 (surface, backlerp);
@@ -1133,24 +1047,16 @@
 	Bob = tess.numIndexes;
 	Doug = tess.numVertexes;
 	
-	if ( tess.indexInc == sizeof(GLushort) ) {
-		GLushort *indexPtrShort = (GLushort *)(tess.indexPtr);
-		CopyArrayAndAddConstantShort_sse2(indexPtrShort + Bob, triangles,
-						  Doug, indexes);
-	} else {
-		CopyArrayAndAddConstant_sse2(tess.indexPtr + Bob, triangles,
-					     Doug, indexes);
-	}
+	CopyArrayAndAddConstant_sse2(&tess.indexes[Bob], triangles,
+				     Doug, indexes);
 	tess.numIndexes += indexes;
 
 	texCoords = (float *) ((byte *)surface + surface->ofsSt);
-	texCoordPtr = ptrPlusOffset(tess.texCoordPtr, Doug * tess.texCoordInc);
 
 	numVerts = surface->numVerts;
 	for ( j = 0; j < numVerts; j++ ) {
-		(*texCoordPtr)[0] = texCoords[j*2+0];
-		(*texCoordPtr)[1] = texCoords[j*2+1];
-		texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
+		tess.texCoords[Doug + j][0][0] = texCoords[j*2+0];
+		tess.texCoords[Doug + j][0][1] = texCoords[j*2+1];
 		// FIXME: fill in lightmapST for completeness?
 	}
 
@@ -1167,7 +1073,6 @@
 	int				indexes;
 	int				Bob, Doug;
 	int				numVerts;
-	vec2_t		*texCoordPtr;
 
 	if (  backEnd.currentEntity->e.oldframe == backEnd.currentEntity->e.frame ) {
 		backlerp = 0;
@@ -1175,12 +1080,6 @@
 		backlerp = backEnd.currentEntity->e.backlerp;
 	}
 
-	if ( !tess.indexPtr ) {
-		tess.numVertexes += surface->numVerts;
-		tess.numIndexes  += 3*surface->numTriangles;
-		return;
-	}
-
 	RB_CHECKOVERFLOW( surface->numVerts, surface->numTriangles*3 );
 
 	LerpMeshVertexes_scalar (surface, backlerp);
@@ -1189,27 +1088,17 @@
 	indexes = surface->numTriangles * 3;
 	Bob = tess.numIndexes;
 	Doug = tess.numVertexes;
-
-	if ( tess.indexInc == sizeof(GLushort) ) {
-		GLushort *indexPtrShort = (GLushort *)tess.indexPtr;
-		for (j = 0 ; j < indexes ; j++) {
-			indexPtrShort[Bob + j] = (GLushort)(Doug + triangles[j]);
-		}
-	} else {
-		for (j = 0 ; j < indexes ; j++) {
-			tess.indexPtr[Bob + j] = Doug + triangles[j];
-		}
+	for (j = 0 ; j < indexes ; j++) {
+		tess.indexes[Bob + j] = Doug + triangles[j];
 	}
 	tess.numIndexes += indexes;
 
 	texCoords = (float *) ((byte *)surface + surface->ofsSt);
-	texCoordPtr = tess.texCoordPtr + Doug * tess.texCoordInc;
 
 	numVerts = surface->numVerts;
 	for ( j = 0; j < numVerts; j++ ) {
-		(*texCoordPtr)[0] = texCoords[j*2+0];
-		(*texCoordPtr)[1] = texCoords[j*2+1];
-		texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
+		tess.texCoords[Doug + j][0][0] = texCoords[j*2+0];
+		tess.texCoords[Doug + j][0][1] = texCoords[j*2+1];
 		// FIXME: fill in lightmapST for completeness?
 	}
 
@@ -1217,8 +1106,7 @@
 
 }
 
-void RB_SurfaceMesh( surfaceType_t *surf) {
-	md3Surface_t *surface = (md3Surface_t *)surf;
+void RB_SurfaceMesh(md3Surface_t *surface) {
 #if idppc_altivec
   if (com_altivec->integer) {
     RB_SurfaceMesh_altivec( surface );
@@ -1245,21 +1133,12 @@
 	int		 i;
 	unsigned	*indices, *tessIndexes;
 	float		*v;
+	int		 ndx;
 	int		 Bob;
 	v4i              Mask1, Mask2, dataVec, nextVec;
 	int		 numPoints;
 	int		 dlightBits;
-	vec4_t		*xyzPtr, *normalPtr;
-	vec2_t		*texCoordPtr, *texCoord2Ptr;
-	color4ub_t	*vertexColorPtr;
-	int		*vertexDlightBitPtr;
 	
-	if ( !tess.indexPtr ) {
-		tess.numVertexes += surf->numPoints;
-		tess.numIndexes  += surf->numIndices;
-		return;
-	}
-
 	RB_CHECKOVERFLOW( surf->numPoints, surf->numIndices );
 	
 	dlightBits = surf->dlightBits[backEnd.smpFrame];
@@ -1268,135 +1147,54 @@
 	indices = ( unsigned * ) ( ( ( char  * ) surf ) + surf->ofsIndices );
 	
 	Bob = tess.numVertexes;
-	tessIndexes = ptrPlusOffset(tess.indexPtr, tess.indexInc * tess.numIndexes);
+	tessIndexes = tess.indexes + tess.numIndexes;
 	
-	if ( tess.indexInc == sizeof(GLushort) ) {
-		GLushort *indexPtrShort = (GLushort *)tessIndexes;
-		CopyArrayAndAddConstantShort_sse2(indexPtrShort, indices, Bob, surf->numIndices);
-	} else {
-		CopyArrayAndAddConstant_sse2(tessIndexes, indices, Bob, surf->numIndices);
-	}
+	CopyArrayAndAddConstant_sse2(tessIndexes, indices, Bob, surf->numIndices);
 	tess.numIndexes += surf->numIndices;
 	
 	v = surf->points[0];
 	
+	ndx = tess.numVertexes;
+	
 	numPoints = surf->numPoints;
-
-	xyzPtr = ptrPlusOffset(tess.xyzPtr, tess.xyzInc * tess.numVertexes);
-	normalPtr = ptrPlusOffset(tess.normalPtr, tess.normalInc * tess.numVertexes);
-	texCoordPtr = ptrPlusOffset(tess.texCoordPtr, tess.texCoordInc * tess.numVertexes);
-	texCoord2Ptr = ptrPlusOffset(tess.texCoord2Ptr, tess.texCoord2Inc * tess.numVertexes);
-	vertexColorPtr = ptrPlusOffset(tess.vertexColorPtr, tess.vertexColorInc * tess.numVertexes);
-	vertexDlightBitPtr = ptrPlusOffset(tess.vertexDlightBitPtr, tess.vertexDlightBitInc * tess.numVertexes);
 	
-	if ( tess.normalInc > 0 ) {
+	if ( tess.shader->needsNormal ) {
 		v4i normalVec = v4iLoadU((int *)surf->plane.normal);
-		for ( i = 0; i < numPoints; i++ ) {
-			v4iStoreA((int *)normalPtr, normalVec);
-			normalPtr = ptrPlusOffset(normalPtr, tess.normalInc);
+		for ( i = 0, ndx = tess.numVertexes; i < numPoints; i++, ndx++ ) {
+			v4iStoreA((int *)&(tess.normal[ndx]), normalVec);
 		}
 	}
-
-	if ( tess.texCoordInc > 0 && tess.texCoord2Inc > 0 ) {
-		/* the SSE code assumes that texture coords are always
-		   interleaved, because it uses only 1 v4fStore !! */
-		Mask1 = v4iInit(0, 0, 0, -1);
-		Mask2 = v4iInit(-1, -1, -1, 0);
-		for ( i = 0, v = surf->points[0]; i < numPoints; i++, v += VERTEXSIZE ) {
-			dataVec = v4iLoadU((int *)v);
-			nextVec = v4iLoadU((int *)(v + 4));
-			
-			v4iStoreA((int *)xyzPtr, dataVec);
-			xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
-			dataVec = v4iOr(v4iAnd(Mask1, dataVec), v4iAnd(Mask2, nextVec));
-			dataVec = _mm_shuffle_epi32(dataVec, 0x93);
-			v4iStoreA((int *)texCoordPtr, dataVec);
-			texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
-			
-			nextVec = _mm_shuffle_epi32(nextVec, 0xff);
-			*(unsigned int *)vertexColorPtr = _mm_cvtsi128_si32(nextVec);
-			vertexColorPtr = ptrPlusOffset(vertexColorPtr, tess.vertexColorInc);
-			
-			*vertexDlightBitPtr = dlightBits;
-			vertexDlightBitPtr = ptrPlusOffset(vertexDlightBitPtr, tess.vertexDlightBitInc);
-		}
-	} else if ( tess.texCoordInc > 0 ) {
-		Mask1 = v4iInit(0, 0, 0, -1);
-		Mask2 = v4iInit(-1, -1, -1, 0);
-		for ( i = 0, v = surf->points[0]; i < numPoints; i++, v += VERTEXSIZE ) {
-			dataVec = v4iLoadU((int *)v);
-			nextVec = v4iLoadU((int *)(v + 4));
-			
-			v4iStoreA((int *)xyzPtr, dataVec);
-			xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
-			dataVec = v4iOr(v4iAnd(Mask1, dataVec), v4iAnd(Mask2, nextVec));
-			dataVec = _mm_shuffle_epi32(dataVec, 0x93);
-			v4iStoreLoA((int *)texCoordPtr, dataVec);
-			texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
-			
-			nextVec = _mm_shuffle_epi32(nextVec, 0xff);
-			*(unsigned int *)vertexColorPtr = _mm_cvtsi128_si32(nextVec);
-			vertexColorPtr = ptrPlusOffset(vertexColorPtr, tess.vertexColorInc);
-			
-			*vertexDlightBitPtr = dlightBits;
-			vertexDlightBitPtr = ptrPlusOffset(vertexDlightBitPtr, tess.vertexDlightBitInc);
-		}
-	} else if ( tess.texCoord2Inc > 0 ) {
-		for ( i = 0, v = surf->points[0]; i < numPoints; i++, v += VERTEXSIZE ) {
-			dataVec = v4iLoadU((int *)v);
-			nextVec = v4iLoadU((int *)(v + 4));
-			
-			v4iStoreA((int *)xyzPtr, dataVec);
-			xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
-			dataVec = _mm_shuffle_epi32(nextVec, 0x39);
-			v4iStoreLoA((int *)texCoordPtr, dataVec);
-			texCoord2Ptr = ptrPlusOffset(texCoord2Ptr, tess.texCoord2Inc);
-			
-			nextVec = _mm_shuffle_epi32(nextVec, 0xff);
-			*(unsigned int *)vertexColorPtr = _mm_cvtsi128_si32(nextVec);
-			vertexColorPtr = ptrPlusOffset(vertexColorPtr, tess.vertexColorInc);
-			
-			*vertexDlightBitPtr = dlightBits;
-			vertexDlightBitPtr = ptrPlusOffset(vertexDlightBitPtr, tess.vertexDlightBitInc);
-		}
-	} else {
-		for ( i = 0, v = surf->points[0]; i < numPoints; i++, v += VERTEXSIZE ) {
-			dataVec = v4iLoadU((int *)v);
-			nextVec = v4iLoadU((int *)(v + 4));
-			
-			v4iStoreA((int *)xyzPtr, dataVec);
-			xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
-			
-			nextVec = _mm_shuffle_epi32(nextVec, 0xff);
-			*(unsigned int *)vertexColorPtr = _mm_cvtsi128_si32(nextVec);
-			vertexColorPtr = ptrPlusOffset(vertexColorPtr, tess.vertexColorInc);
-			
-			*vertexDlightBitPtr = dlightBits;
-			vertexDlightBitPtr = ptrPlusOffset(vertexDlightBitPtr, tess.vertexDlightBitInc);
-		}
+	
+	Mask1 = v4iInit(0, 0, 0, -1);
+	Mask2 = v4iInit(-1, -1, -1, 0);
+	for ( i = 0, v = surf->points[0], ndx = tess.numVertexes; i < numPoints; i++, v += VERTEXSIZE, ndx++ ) {
+		dataVec = v4iLoadU((int *)v);
+		nextVec = v4iLoadU((int *)(v + 4));
+		
+		v4iStoreA((int *)&(tess.xyz[ndx]), dataVec);
+		dataVec = v4iOr(v4iAnd(Mask1, dataVec), v4iAnd(Mask2, nextVec));
+		dataVec = _mm_shuffle_epi32(dataVec, 0x93);
+		v4iStoreA((int *)&(tess.texCoords[ndx][0][0]), dataVec);
+		
+		nextVec = _mm_shuffle_epi32(nextVec, 0xff);
+		* ( unsigned int * ) &tess.vertexColors[ndx] = _mm_cvtsi128_si32(nextVec);
+		tess.vertexDlightBits[ndx] = dlightBits;
 	}
 	
+	
 	tess.numVertexes += surf->numPoints;
 }
 #endif
+
 static ID_INLINE void RB_SurfaceFace_scalar( srfSurfaceFace_t *surf ) {
 	int			i;
 	unsigned	*indices, *tessIndexes;
 	float		*v;
 	float		*normal;
+	int			ndx;
 	int			Bob;
 	int			numPoints;
 	int			dlightBits;
-	vec4_t		*xyzPtr, *normalPtr;
-	vec2_t		*texCoordPtr, *texCoord2Ptr;
-	color4ub_t	*vertexColorPtr;
-	int		*vertexDlightBitPtr;
-
-	if ( !tess.indexPtr ) {
-		tess.numVertexes += surf->numPoints;
-		tess.numIndexes  += surf->numIndices;
-		return;
-	}
 
 	RB_CHECKOVERFLOW( surf->numPoints, surf->numIndices );
 
@@ -1406,57 +1204,41 @@
 	indices = ( unsigned * ) ( ( ( char  * ) surf ) + surf->ofsIndices );
 
 	Bob = tess.numVertexes;
-	tessIndexes = ptrPlusOffset(tess.indexPtr, tess.indexInc * tess.numIndexes);
-	if ( tess.indexInc == sizeof(GLushort) ) {
-		GLushort *indexPtrShort = (GLushort *)tessIndexes;
-		for ( i = surf->numIndices-1 ; i >= 0  ; i-- ) {
-			indexPtrShort[i] = (GLushort)(indices[i] + Bob);
-		}
-	} else {
-		for ( i = surf->numIndices-1 ; i >= 0  ; i-- ) {
-			tessIndexes[i] = indices[i] + Bob;
-		}
+	tessIndexes = tess.indexes + tess.numIndexes;
+	for ( i = surf->numIndices-1 ; i >= 0  ; i-- ) {
+		tessIndexes[i] = indices[i] + Bob;
 	}
 
 	tess.numIndexes += surf->numIndices;
 
 	v = surf->points[0];
 
+	ndx = tess.numVertexes;
+
 	numPoints = surf->numPoints;
 
-	xyzPtr = ptrPlusOffset(tess.xyzPtr, tess.xyzInc * tess.numVertexes);
-	normalPtr = ptrPlusOffset(tess.normalPtr, tess.normalInc * tess.numVertexes);
-	texCoordPtr = ptrPlusOffset(tess.texCoordPtr, tess.texCoordInc * tess.numVertexes);
-	texCoord2Ptr = ptrPlusOffset(tess.texCoord2Ptr, tess.texCoord2Inc * tess.numVertexes);
-	vertexColorPtr = ptrPlusOffset(tess.vertexColorPtr, tess.vertexColorInc * tess.numVertexes);
-	vertexDlightBitPtr = ptrPlusOffset(tess.vertexDlightBitPtr, tess.vertexDlightBitInc * tess.numVertexes);
-
-	if ( tess.normalInc > 0 ) {
+	if ( tess.shader->needsNormal ) {
 		normal = surf->plane.normal;
-		for ( i = 0; i < numPoints; i++ ) {
-			VectorCopy( normal, *(vec3_t *)normalPtr );
-			normalPtr = ptrPlusOffset(normalPtr, tess.normalInc);
+		for ( i = 0, ndx = tess.numVertexes; i < numPoints; i++, ndx++ ) {
+			VectorCopy( normal, tess.normal[ndx] );
 		}
 	}
 
-	for ( i = 0, v = surf->points[0]; i < numPoints; i++, v += VERTEXSIZE ) {
-		VectorCopy ( v, *(vec3_t *)xyzPtr);
-		xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
-		Vector2Copy( v+3, *texCoordPtr );
-		texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
-		Vector2Copy( v+5, *texCoord2Ptr );
-		texCoord2Ptr = ptrPlusOffset(texCoord2Ptr, tess.texCoord2Inc);
-		*(unsigned int *)vertexColorPtr = *(unsigned int *)&v[7];
-		vertexColorPtr = ptrPlusOffset(vertexColorPtr, tess.vertexColorInc);
-		*vertexDlightBitPtr = dlightBits;
-		vertexDlightBitPtr = ptrPlusOffset(vertexDlightBitPtr, tess.vertexDlightBitInc);
+	for ( i = 0, v = surf->points[0], ndx = tess.numVertexes; i < numPoints; i++, v += VERTEXSIZE, ndx++ ) {
+		VectorCopy( v, tess.xyz[ndx]);
+		tess.texCoords[ndx][0][0] = v[3];
+		tess.texCoords[ndx][0][1] = v[4];
+		tess.texCoords[ndx][1][0] = v[5];
+		tess.texCoords[ndx][1][1] = v[6];
+		* ( unsigned int * ) &tess.vertexColors[ndx] = * ( unsigned int * ) &v[7];
+		tess.vertexDlightBits[ndx] = dlightBits;
 	}
 
+
 	tess.numVertexes += surf->numPoints;
 }
 
-void RB_SurfaceFace( surfaceType_t *surface ) {
-	srfSurfaceFace_t *surf = (srfSurfaceFace_t *)surface;
+void RB_SurfaceFace( srfSurfaceFace_t *surf ) {
 #if id386_sse >= 2
 	if (com_sse->integer >= 2) {
 		RB_SurfaceFace_sse2( surf );
@@ -1504,13 +1286,12 @@
 Just copy the grid of points and triangulate
 =============
 */
-void RB_SurfaceGrid( surfaceType_t *surface ) {
-	srfGridMesh_t *cv = (srfGridMesh_t *)surface;
+void RB_SurfaceGrid( srfGridMesh_t *cv ) {
 	int		i, j;
-	vec4_t	*xyzPtr;
-	vec2_t	*texCoordPtr, *texCoord2Ptr;
-	vec4_t	*normalPtr;
-	color4ub_t	*colorPtr;
+	float	*xyz;
+	float	*texCoords;
+	float	*normal;
+	unsigned char *color;
 	drawVert_t	*dv;
 	int		rows, irows, vrows;
 	int		used;
@@ -1521,6 +1302,7 @@
 	int		numVertexes;
 	int		dlightBits;
 	int		*vDlightBits;
+	qboolean	needsNormal;
 
 	dlightBits = cv->dlightBits[backEnd.smpFrame];
 	tess.dlightBits |= dlightBits;
@@ -1553,70 +1335,66 @@
 	lodHeight++;
 
 
-	if ( !tess.indexPtr ) {
-		tess.numVertexes += lodWidth * lodHeight;
-		tess.numIndexes  += 6 * (lodWidth - 1) * (lodHeight - 1);
-		return;
-	}
-
 	// very large grids may have more points or indexes than can be fit
 	// in the tess structure, so we may have to issue it in multiple passes
 
 	used = 0;
 	rows = 0;
 	while ( used < lodHeight - 1 ) {
-		if ( tess.xyzPtr == &tess.xyz[0] ) {
-			// see how many rows of both verts and indexes we can add without overflowing
-			do {
-				vrows = ( SHADER_MAX_VERTEXES - tess.numVertexes ) / lodWidth;
-				irows = ( SHADER_MAX_INDEXES - tess.numIndexes ) / ( lodWidth * 6 );
-				
-				// if we don't have enough space for at least one strip, flush the buffer
-				if ( vrows < 2 || irows < 1 ) {
-					RB_EndSurface();
-					RB_BeginSurface(tess.shader, tess.fogNum );
-				} else {
-					break;
-				}
-			} while ( 1 );
-			
-			rows = irows;
-			if ( vrows < irows + 1 ) {
-				rows = vrows - 1;
+		// see how many rows of both verts and indexes we can add without overflowing
+		do {
+			vrows = ( SHADER_MAX_VERTEXES - tess.numVertexes ) / lodWidth;
+			irows = ( SHADER_MAX_INDEXES - tess.numIndexes ) / ( lodWidth * 6 );
+
+			// if we don't have enough space for at least one strip, flush the buffer
+			if ( vrows < 2 || irows < 1 ) {
+				RB_EndSurface();
+				RB_BeginSurface(tess.shader, tess.fogNum );
+			} else {
+				break;
 			}
-			if ( used + rows > lodHeight ) {
-				rows = lodHeight - used;
-			}
-		} else {
-			rows = lodHeight;
+		} while ( 1 );
+		
+		rows = irows;
+		if ( vrows < irows + 1 ) {
+			rows = vrows - 1;
+		}
+		if ( used + rows > lodHeight ) {
+			rows = lodHeight - used;
 		}
 
 		numVertexes = tess.numVertexes;
 
-		xyzPtr = ptrPlusOffset(tess.xyzPtr, tess.xyzInc * numVertexes);
-		normalPtr = ptrPlusOffset(tess.normalPtr, tess.normalInc * numVertexes);
-		texCoordPtr = ptrPlusOffset(tess.texCoordPtr, tess.texCoordInc * numVertexes);
-		texCoord2Ptr = ptrPlusOffset(tess.texCoord2Ptr, tess.texCoord2Inc * numVertexes);
-		colorPtr = ptrPlusOffset(tess.vertexColorPtr, tess.vertexColorInc * numVertexes);
-		vDlightBits = ptrPlusOffset(tess.vertexDlightBitPtr, tess.vertexDlightBitInc * numVertexes);
+		xyz = tess.xyz[numVertexes];
+		normal = tess.normal[numVertexes];
+		texCoords = tess.texCoords[numVertexes][0];
+		color = ( unsigned char * ) &tess.vertexColors[numVertexes];
+		vDlightBits = &tess.vertexDlightBits[numVertexes];
+		needsNormal = tess.shader->needsNormal;
 
 		for ( i = 0 ; i < rows ; i++ ) {
 			for ( j = 0 ; j < lodWidth ; j++ ) {
 				dv = cv->verts + heightTable[ used + i ] * cv->width
 					+ widthTable[ j ];
 
-				VectorCopy( dv->xyz, *(vec3_t *)xyzPtr );
-				xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
-				Vector2Copy ( dv->st, *texCoordPtr );
-				texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
-				Vector2Copy ( dv->lightmap, *texCoord2Ptr );
-				texCoord2Ptr = ptrPlusOffset(texCoord2Ptr, tess.texCoord2Inc);
-				VectorCopy( dv->normal, *(vec3_t *)normalPtr );
-				normalPtr = ptrPlusOffset(normalPtr, tess.normalInc);
-				*(unsigned int *)colorPtr = *(unsigned int *)dv->color;
-				colorPtr = ptrPlusOffset(colorPtr, tess.vertexColorInc);
-				*vDlightBits = dlightBits;
-				vDlightBits = ptrPlusOffset(vDlightBits, tess.vertexDlightBitInc);
+				xyz[0] = dv->xyz[0];
+				xyz[1] = dv->xyz[1];
+				xyz[2] = dv->xyz[2];
+				texCoords[0] = dv->st[0];
+				texCoords[1] = dv->st[1];
+				texCoords[2] = dv->lightmap[0];
+				texCoords[3] = dv->lightmap[1];
+				if ( needsNormal ) {
+					normal[0] = dv->normal[0];
+					normal[1] = dv->normal[1];
+					normal[2] = dv->normal[2];
+				}
+				* ( unsigned int * ) color = * ( unsigned int * ) dv->color;
+				*vDlightBits++ = dlightBits;
+				xyz += 4;
+				normal += 4;
+				texCoords += 4;
+				color += 4;
 			}
 		}
 
@@ -1629,51 +1407,27 @@
 			h = rows - 1;
 			w = lodWidth - 1;
 			numIndexes = tess.numIndexes;
+			for (i = 0 ; i < h ; i++) {
+				for (j = 0 ; j < w ; j++) {
+					int		v1, v2, v3, v4;
+			
+					// vertex order to be reckognized as tristrips
+					v1 = numVertexes + i*lodWidth + j + 1;
+					v2 = v1 - 1;
+					v3 = v2 + lodWidth;
+					v4 = v3 + 1;
 
-			if ( tess.indexInc == sizeof(GLushort) ) {
-				GLushort *indexPtrShort = (GLushort *)tess.indexPtr;
-				for (i = 0 ; i < h ; i++) {
-					for (j = 0 ; j < w ; j++) {
-						int		v1, v2, v3, v4;
-						
-						// vertex order to be reckognized as tristrips
-						v1 = numVertexes + i*lodWidth + j + 1;
-						v2 = v1 - 1;
-						v3 = v2 + lodWidth;
-						v4 = v3 + 1;
-						
-						indexPtrShort[numIndexes] = v2;
-						indexPtrShort[numIndexes+1] = v3;
-						indexPtrShort[numIndexes+2] = v1;
-						
-						indexPtrShort[numIndexes+3] = v1;
-						indexPtrShort[numIndexes+4] = v3;
-						indexPtrShort[numIndexes+5] = v4;
-						numIndexes += 6;
-					}
-				}
-			} else {
-				for (i = 0 ; i < h ; i++) {
-					for (j = 0 ; j < w ; j++) {
-						int		v1, v2, v3, v4;
-						
-						// vertex order to be reckognized as tristrips
-						v1 = numVertexes + i*lodWidth + j + 1;
-						v2 = v1 - 1;
-						v3 = v2 + lodWidth;
-						v4 = v3 + 1;
-						
-						tess.indexPtr[numIndexes] = v2;
-						tess.indexPtr[numIndexes+1] = v3;
-						tess.indexPtr[numIndexes+2] = v1;
-						
-						tess.indexPtr[numIndexes+3] = v1;
-						tess.indexPtr[numIndexes+4] = v3;
-						tess.indexPtr[numIndexes+5] = v4;
-						numIndexes += 6;
-					}
+					tess.indexes[numIndexes] = v2;
+					tess.indexes[numIndexes+1] = v3;
+					tess.indexes[numIndexes+2] = v1;
+					
+					tess.indexes[numIndexes+3] = v1;
+					tess.indexes[numIndexes+4] = v3;
+					tess.indexes[numIndexes+5] = v4;
+					numIndexes += 6;
 				}
 			}
+
 			tess.numIndexes = numIndexes;
 		}
 
@@ -1753,38 +1507,35 @@
 	ri.Printf( PRINT_ALL, "Bad surface tesselated.\n" );
 }
 
-void RB_SurfaceFlare( surfaceType_t *surface )
+void RB_SurfaceFlare(srfFlare_t *surf)
 {
-	srfFlare_t *surf = (srfFlare_t *)surface;
-
 	if (r_flares->integer)
 		RB_AddFlare(surf, tess.fogNum, surf->origin, surf->color, surf->normal);
 }
 
-void RB_SurfaceDisplayList( surfaceType_t *surface ) {
-	srfDisplayList_t *surf = (srfDisplayList_t *)surface;
+void RB_SurfaceDisplayList( srfDisplayList_t *surf ) {
 	// all apropriate state must be set in RB_BeginSurface
 	// this isn't implemented yet...
 	qglCallList( surf->listNum );
 }
 
-void RB_SurfaceSkip( surfaceType_t *surf ) {
+void RB_SurfaceSkip( void *surf ) {
 }
 
 
-void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])( surfaceType_t * ) = {
-	RB_SurfaceBad,			// SF_BAD, 
-	RB_SurfaceSkip,			// SF_SKIP, 
-	RB_SurfaceFace,			// SF_FACE,
-	RB_SurfaceGrid,			// SF_GRID,
-	RB_SurfaceTriangles,		// SF_TRIANGLES,
-	RB_SurfacePolychain,		// SF_POLY,
-	RB_SurfaceMesh,			// SF_MD3,
-	RB_SurfaceAnim,			// SF_MD4,
+void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])( void *) = {
+	(void(*)(void*))RB_SurfaceBad,			// SF_BAD, 
+	(void(*)(void*))RB_SurfaceSkip,			// SF_SKIP, 
+	(void(*)(void*))RB_SurfaceFace,			// SF_FACE,
+	(void(*)(void*))RB_SurfaceGrid,			// SF_GRID,
+	(void(*)(void*))RB_SurfaceTriangles,		// SF_TRIANGLES,
+	(void(*)(void*))RB_SurfacePolychain,		// SF_POLY,
+	(void(*)(void*))RB_SurfaceMesh,			// SF_MD3,
+	(void(*)(void*))RB_SurfaceAnim,			// SF_MD4,
 #ifdef RAVENMD4
-	RB_MDRSurfaceAnim,		// SF_MDR,
+	(void(*)(void*))RB_MDRSurfaceAnim,		// SF_MDR,
 #endif
-	RB_SurfaceFlare,		// SF_FLARE,
-	RB_SurfaceEntity,		// SF_ENTITY
-	RB_SurfaceDisplayList		// SF_DISPLAY_LIST
+	(void(*)(void*))RB_SurfaceFlare,		// SF_FLARE,
+	(void(*)(void*))RB_SurfaceEntity,		// SF_ENTITY
+	(void(*)(void*))RB_SurfaceDisplayList		// SF_DISPLAY_LIST
 };
diff -r 87f98d895296 -r 91f0a3d9f930 src/renderer/tr_types.h
--- a/src/renderer/tr_types.h	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/renderer/tr_types.h	Sat Jun 06 02:45:31 2009 +0800
@@ -212,8 +212,6 @@
 
 	qboolean				textureFilterAnisotropic;
 	int							maxAnisotropy;
-	qboolean                                vertexBufferObjects;
-	qboolean				vertexShaders;
                 
 } glconfig_t;
 
diff -r 87f98d895296 -r 91f0a3d9f930 src/renderer/tr_world.c
--- a/src/renderer/tr_world.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/renderer/tr_world.c	Sat Jun 06 02:45:31 2009 +0800
@@ -166,11 +166,6 @@
 	int			i;
 	dlight_t	*dl;
 
-	if ( !dlightBits ) {
-		face->dlightBits[ tr.smpFrame ] = dlightBits;
-		return dlightBits;
-	}
-
 	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
 		if ( ! ( dlightBits & ( 1 << i ) ) ) {
 			continue;
@@ -195,11 +190,6 @@
 	int			i;
 	dlight_t	*dl;
 
-	if ( !dlightBits ) {
-		grid->dlightBits[ tr.smpFrame ] = dlightBits;
-		return dlightBits;
-	}
-
 	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
 		if ( ! ( dlightBits & ( 1 << i ) ) ) {
 			continue;
@@ -226,6 +216,10 @@
 
 
 static int R_DlightTrisurf( srfTriangles_t *surf, int dlightBits ) {
+	// FIXME: more dlight culling to trisurfs...
+	surf->dlightBits[ tr.smpFrame ] = dlightBits;
+	return dlightBits;
+#if 0
 	int			i;
 	dlight_t	*dl;
 
@@ -234,12 +228,12 @@
 			continue;
 		}
 		dl = &tr.refdef.dlights[i];
-		if ( dl->origin[0] - dl->radius > surf->bounds[1][0]
-			|| dl->origin[0] + dl->radius < surf->bounds[0][0]
-			|| dl->origin[1] - dl->radius > surf->bounds[1][1]
-			|| dl->origin[1] + dl->radius < surf->bounds[0][1]
-			|| dl->origin[2] - dl->radius > surf->bounds[1][2]
-			|| dl->origin[2] + dl->radius < surf->bounds[0][2] ) {
+		if ( dl->origin[0] - dl->radius > grid->meshBounds[1][0]
+			|| dl->origin[0] + dl->radius < grid->meshBounds[0][0]
+			|| dl->origin[1] - dl->radius > grid->meshBounds[1][1]
+			|| dl->origin[1] + dl->radius < grid->meshBounds[0][1]
+			|| dl->origin[2] - dl->radius > grid->meshBounds[1][2]
+			|| dl->origin[2] + dl->radius < grid->meshBounds[0][2] ) {
 			// dlight doesn't reach the bounds
 			dlightBits &= ~( 1 << i );
 		}
@@ -249,8 +243,9 @@
 		tr.pc.c_dlightSurfacesCulled++;
 	}
 
-	surf->dlightBits[ tr.smpFrame ] = dlightBits;
+	grid->dlightBits[ tr.smpFrame ] = dlightBits;
 	return dlightBits;
+#endif
 }
 
 /*
@@ -296,14 +291,15 @@
 	// FIXME: bmodel fog?
 
 	// try to cull before dlighting or adding
-	if ( !qglBindBufferARB &&
-	     R_CullSurface( surf->data, surf->shader ) ) {
+	if ( R_CullSurface( surf->data, surf->shader ) ) {
 		return;
 	}
 
 	// check for dlighting
-	dlightBits = R_DlightSurface( surf, dlightBits );
-	dlightBits = ( dlightBits != 0 );
+	if ( dlightBits ) {
+		dlightBits = R_DlightSurface( surf, dlightBits );
+		dlightBits = ( dlightBits != 0 );
+	}
 
 	R_AddDrawSurf( surf->data, surf->shader, surf->fogIndex, dlightBits );
 }
@@ -371,7 +367,7 @@
 		// if the bounding volume is outside the frustum, nothing
 		// inside can be visible OPTIMIZE: don't do this all the way to leafs?
 
-		if ( !r_nocull->integer && !qglBindBufferARB ) {
+		if ( !r_nocull->integer ) {
 			int		r;
 
 			if ( planeBits & 1 ) {
@@ -627,8 +623,7 @@
 		}
 
 		// check for door connection
-		if ( !qglBindBufferARB &&
-		    (tr.refdef.areamask[leaf->area>>3] & (1<<(leaf->area&7)) ) ) {
+		if ( (tr.refdef.areamask[leaf->area>>3] & (1<<(leaf->area&7)) ) ) {
 			continue;		// not visible
 		}
 
diff -r 87f98d895296 -r 91f0a3d9f930 src/sdl/sdl_glimp.c
--- a/src/sdl/sdl_glimp.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/sdl/sdl_glimp.c	Sat Jun 06 02:45:31 2009 +0800
@@ -22,11 +22,9 @@
 
 #include <SDL.h>
 
-#ifdef SMP
-#	include <SDL_thread.h>
-#	ifdef SDL_VIDEO_DRIVER_X11
-#		include <X11/Xlib.h>
-#	endif
+#include <SDL_thread.h>
+#ifdef SDL_VIDEO_DRIVER_X11
+#	include <X11/Xlib.h>
 #endif
 
 #include <stdarg.h>
@@ -52,7 +50,6 @@
 	opengl_context = CGLGetCurrentContext();
 }
 
-#ifdef SMP
 static void GLimp_SetCurrentContext(qboolean enable)
 {
 	if(enable)
@@ -60,7 +57,6 @@
 	else
 		CGLSetCurrentContext(NULL);
 }
-#endif
 #elif SDL_VIDEO_DRIVER_X11
 #include <GL/glx.h>
 typedef struct
@@ -80,7 +76,6 @@
 	opengl_context.drawable = glXGetCurrentDrawable();
 }
 
-#ifdef SMP
 static void GLimp_SetCurrentContext(qboolean enable)
 {
 	if(enable)
@@ -88,7 +83,6 @@
 	else
 		glXMakeCurrent(opengl_context.dpy, None, NULL);
 }
-#endif
 #elif WIN32
 typedef struct
 {
@@ -114,7 +108,6 @@
 	opengl_context.hGLRC = info.hglrc;
 }
 
-#ifdef SMP
 static void GLimp_SetCurrentContext(qboolean enable)
 {
 	if(enable)
@@ -122,13 +115,10 @@
 	else
 		wglMakeCurrent(opengl_context.hDC, NULL);
 }
-#endif
 #else
 static void GLimp_GetCurrentContext(void) {}
-#ifdef SMP
 static void GLimp_SetCurrentContext(qboolean enable) {}
 #endif
-#endif
 
 typedef enum
 {
@@ -146,8 +136,6 @@
 cvar_t *r_allowSoftwareGL; // Don't abort out if a hardware visual can't be obtained
 cvar_t *r_sdlDriver;
 
-void (APIENTRYP qglDrawRangeElementsEXT) (GLenum mode, GLsizei count, GLuint start, GLuint end, GLenum type, const GLvoid *indices);
-
 void (APIENTRYP qglActiveTextureARB) (GLenum texture);
 void (APIENTRYP qglClientActiveTextureARB) (GLenum texture);
 void (APIENTRYP qglMultiTexCoord2fARB) (GLenum target, GLfloat s, GLfloat t);
@@ -155,148 +143,6 @@
 void (APIENTRYP qglLockArraysEXT) (GLint first, GLsizei count);
 void (APIENTRYP qglUnlockArraysEXT) (void);
 
-void (APIENTRYP qglBindBufferARB) (GLenum target, GLuint buffer);
-void (APIENTRYP qglDeleteBuffersARB) (GLsizei n, const GLuint *buffers);
-void (APIENTRYP qglGenBuffersARB) (GLsizei n, GLuint *buffers);
-GLboolean (APIENTRYP qglIsBufferARB) (GLuint buffer);
-void (APIENTRYP qglBufferDataARB) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
-void (APIENTRYP qglBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
-void (APIENTRYP qglGetBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
-GLvoid *(APIENTRYP qglMapBufferARB) (GLenum target, GLenum access);
-GLboolean (APIENTRYP qglUnmapBufferARB) (GLenum target);
-void (APIENTRYP qglGetBufferParameterivARB) (GLenum target, GLenum pname, GLint *params);
-void (APIENTRYP qglGetBufferPointervARB) (GLenum target, GLenum pname, GLvoid **params);
-
-// GL_ARB_shader_objects
-GLvoid (APIENTRYP qglDeleteObjectARB) (GLhandleARB obj);
-GLhandleARB (APIENTRYP qglGetHandleARB) (GLenum pname);
-GLvoid (APIENTRYP qglDetachObjectARB) (GLhandleARB containerObj, GLhandleARB attachedObj);
-GLhandleARB (APIENTRYP qglCreateShaderObjectARB) (GLenum shaderType);
-GLvoid (APIENTRYP qglShaderSourceARB) (GLhandleARB shaderObj, GLsizei count, const GLcharARB **string,
-				       const GLint *length);
-GLvoid (APIENTRYP qglCompileShaderARB) (GLhandleARB shaderObj);
-GLhandleARB (APIENTRYP qglCreateProgramObjectARB) (void);
-GLvoid (APIENTRYP qglAttachObjectARB) (GLhandleARB containerObj, GLhandleARB obj);
-GLvoid (APIENTRYP qglLinkProgramARB) (GLhandleARB programObj);
-GLvoid (APIENTRYP qglUseProgramObjectARB) (GLhandleARB programObj);
-GLvoid (APIENTRYP qglValidateProgramARB) (GLhandleARB programObj);
-GLvoid (APIENTRYP qglUniform1fARB) (GLint location, GLfloat v0);
-GLvoid (APIENTRYP qglUniform2fARB) (GLint location, GLfloat v0, GLfloat v1);
-GLvoid (APIENTRYP qglUniform3fARB) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
-GLvoid (APIENTRYP qglUniform4fARB) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
-GLvoid (APIENTRYP qglUniform1iARB) (GLint location, GLint v0);
-GLvoid (APIENTRYP qglUniform2iARB) (GLint location, GLint v0, GLint v1);
-GLvoid (APIENTRYP qglUniform3iARB) (GLint location, GLint v0, GLint v1, GLint v2);
-GLvoid (APIENTRYP qglUniform4iARB) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
-GLvoid (APIENTRYP qglUniform1fvARB) (GLint location, GLsizei count, const GLfloat *value);
-GLvoid (APIENTRYP qglUniform2fvARB) (GLint location, GLsizei count, const GLfloat *value);
-GLvoid (APIENTRYP qglUniform3fvARB) (GLint location, GLsizei count, const GLfloat *value);
-GLvoid (APIENTRYP qglUniform4fvARB) (GLint location, GLsizei count, const GLfloat *value);
-GLvoid (APIENTRYP qglUniform1ivARB) (GLint location, GLsizei count, const GLint *value);
-GLvoid (APIENTRYP qglUniform2ivARB) (GLint location, GLsizei count, const GLint *value);
-GLvoid (APIENTRYP qglUniform3ivARB) (GLint location, GLsizei count, const GLint *value);
-GLvoid (APIENTRYP qglUniform4ivARB) (GLint location, GLsizei count, const GLint *value);
-GLvoid (APIENTRYP qglUniformMatrix2fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
-GLvoid (APIENTRYP qglUniformMatrix3fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
-GLvoid (APIENTRYP qglUniformMatrix4fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
-GLvoid (APIENTRYP qglGetObjectParameterfvARB) (GLhandleARB obj, GLenum pname, GLfloat *params);
-GLvoid (APIENTRYP qglGetObjectParameterivARB) (GLhandleARB obj, GLenum pname, GLint *params);
-GLvoid (APIENTRYP qglGetInfoLogARB) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
-GLvoid (APIENTRYP qglGetAttachedObjectsARB) (GLhandleARB containerObj, GLsizei maxCount, GLsizei *count,
-					     GLhandleARB *obj);
-GLint (APIENTRYP qglGetUniformLocationARB) (GLhandleARB programObj, const GLcharARB *name);
-GLvoid (APIENTRYP qglGetActiveUniformARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
-					   GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
-GLvoid (APIENTRYP qglGetUniformfvARB) (GLhandleARB programObj, GLint location, GLfloat *params);
-GLvoid (APIENTRYP qglGetUniformivARB) (GLhandleARB programObj, GLint location, GLint *params);
-GLvoid (APIENTRYP qglGetShaderSourceARB) (GLhandleARB obj, GLsizei maxLength, GLsizei *length,
-					  GLcharARB *source);
-
-// GL_ARB_vertex_shader
-GLvoid (APIENTRYP qglVertexAttrib1fARB) (GLuint index, GLfloat v0);
-GLvoid (APIENTRYP qglVertexAttrib1sARB) (GLuint index, GLshort v0);
-GLvoid (APIENTRYP qglVertexAttrib1dARB) (GLuint index, GLdouble v0);
-GLvoid (APIENTRYP qglVertexAttrib2fARB) (GLuint index, GLfloat v0, GLfloat v1);
-GLvoid (APIENTRYP qglVertexAttrib2sARB) (GLuint index, GLshort v0, GLshort v1);
-GLvoid (APIENTRYP qglVertexAttrib2dARB) (GLuint index, GLdouble v0, GLdouble v1);
-GLvoid (APIENTRYP qglVertexAttrib3fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2);
-GLvoid (APIENTRYP qglVertexAttrib3sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2);
-GLvoid (APIENTRYP qglVertexAttrib3dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
-GLvoid (APIENTRYP qglVertexAttrib4fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
-GLvoid (APIENTRYP qglVertexAttrib4sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3);
-GLvoid (APIENTRYP qglVertexAttrib4dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
-GLvoid (APIENTRYP qglVertexAttrib4NubARB) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
-GLvoid (APIENTRYP qglVertexAttrib1fvARB) (GLuint index, GLfloat *v);
-GLvoid (APIENTRYP qglVertexAttrib1svARB) (GLuint index, GLshort *v);
-GLvoid (APIENTRYP qglVertexAttrib1dvARB) (GLuint index, GLdouble *v);
-GLvoid (APIENTRYP qglVertexAttrib2fvARB) (GLuint index, GLfloat *v);
-GLvoid (APIENTRYP qglVertexAttrib2svARB) (GLuint index, GLshort *v);
-GLvoid (APIENTRYP qglVertexAttrib2dvARB) (GLuint index, GLdouble *v);
-GLvoid (APIENTRYP qglVertexAttrib3fvARB) (GLuint index, GLfloat *v);
-GLvoid (APIENTRYP qglVertexAttrib3svARB) (GLuint index, GLshort *v);
-GLvoid (APIENTRYP qglVertexAttrib3dvARB) (GLuint index, GLdouble *v);
-GLvoid (APIENTRYP qglVertexAttrib4fvARB) (GLuint index, GLfloat *v);
-GLvoid (APIENTRYP qglVertexAttrib4svARB) (GLuint index, GLshort *v);
-GLvoid (APIENTRYP qglVertexAttrib4dvARB) (GLuint index, GLdouble *v);
-GLvoid (APIENTRYP qglVertexAttrib4ivARB) (GLuint index, GLint *v);
-GLvoid (APIENTRYP qglVertexAttrib4bvARB) (GLuint index, GLbyte *v);
-GLvoid (APIENTRYP qglVertexAttrib4ubvARB) (GLuint index, GLubyte *v);
-GLvoid (APIENTRYP qglVertexAttrib4usvARB) (GLuint index, GLushort *v);
-GLvoid (APIENTRYP qglVertexAttrib4uivARB) (GLuint index, GLuint *v);
-GLvoid (APIENTRYP qglVertexAttrib4NbvARB) (GLuint index, const GLbyte *v);
-GLvoid (APIENTRYP qglVertexAttrib4NsvARB) (GLuint index, const GLshort *v);
-GLvoid (APIENTRYP qglVertexAttrib4NivARB) (GLuint index, const GLint *v);
-GLvoid (APIENTRYP qglVertexAttrib4NubvARB) (GLuint index, const GLubyte *v);
-GLvoid (APIENTRYP qglVertexAttrib4NusvARB) (GLuint index, const GLushort *v);
-GLvoid (APIENTRYP qglVertexAttrib4NuivARB) (GLuint index, const GLuint *v);
-GLvoid (APIENTRYP qglVertexAttribPointerARB) (GLuint index, GLint size, GLenum type, GLboolean normalized,
-					      GLsizei stride, const GLvoid *pointer);
-GLvoid (APIENTRYP qglEnableVertexAttribArrayARB) (GLuint index);
-GLvoid (APIENTRYP qglDisableVertexAttribArrayARB) (GLuint index);
-GLvoid (APIENTRYP qglBindAttribLocationARB) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
-GLvoid (APIENTRYP qglGetActiveAttribARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
-					  GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
-GLint (APIENTRYP qglGetAttribLocationARB) (GLhandleARB programObj, const GLcharARB *name);
-GLvoid (APIENTRYP qglGetVertexAttribdvARB) (GLuint index, GLenum pname, GLdouble *params);
-GLvoid (APIENTRYP qglGetVertexAttribfvARB) (GLuint index, GLenum pname, GLfloat *params);
-GLvoid (APIENTRYP qglGetVertexAttribivARB) (GLuint index, GLenum pname, GLint *params);
-GLvoid (APIENTRYP qglGetVertexAttribPointervARB) (GLuint index, GLenum pname, GLvoid **pointer);
-
-// GL_ARB_framebuffer_object
-GLboolean (APIENTRYP qglIsRenderbuffer) (GLuint renderbuffer);
-GLvoid (APIENTRYP qglBindRenderbuffer) (GLenum target, GLuint renderbuffer);
-GLvoid (APIENTRYP qglDeleteRenderbuffers) (GLsizei n, const GLuint *renderbuffers);
-GLvoid (APIENTRYP qglGenRenderbuffers) (GLsizei n, GLuint *renderbuffers);
-GLvoid (APIENTRYP qglRenderbufferStorage) (GLenum target, GLenum internalformat,
-					   GLsizei width, GLsizei height);
-GLvoid (APIENTRYP qglRenderbufferStorageMultisample) (GLenum target, GLsizei samples,
-						      GLenum internalformat,
-						      GLsizei width, GLsizei height);
-GLvoid (APIENTRYP qglGetRenderbufferParameteriv) (GLenum target, GLenum pname, GLint *params);
-GLboolean (APIENTRYP qglIsFramebuffer) (GLuint framebuffer);
-GLvoid (APIENTRYP qglBindFramebuffer) (GLenum target, GLuint framebuffer);
-GLvoid (APIENTRYP qglDeleteFramebuffers) (GLsizei n, const GLuint *framebuffers);
-GLvoid (APIENTRYP qglGenFramebuffers) (GLsizei n, GLuint *framebuffers);
-GLenum (APIENTRYP qglCheckFramebufferStatus) (GLenum target);
-GLvoid (APIENTRYP qglFramebufferTexture1D) (GLenum target, GLenum attachment,
-					    GLenum textarget, GLuint texture, GLint level);
-GLvoid (APIENTRYP qglFramebufferTexture2D) (GLenum target, GLenum attachment,
-					    GLenum textarget, GLuint texture, GLint level);
-GLvoid (APIENTRYP qglFramebufferTexture3D) (GLenum target, GLenum attachment,
-					    GLenum textarget, GLuint texture,
-					    GLint level, GLint layer);
-GLvoid (APIENTRYP qglFramebufferTextureLayer) (GLenum target, GLenum attachment,
-					       GLuint texture, GLint level, GLint layer);
-GLvoid (APIENTRYP qglFramebufferRenderbuffer) (GLenum target, GLenum attachment,
-					       GLenum renderbuffertarget, GLuint renderbuffer);
-GLvoid (APIENTRYP qglGetFramebufferAttachmentParameteriv) (GLenum target, GLenum attachment,
-							   GLenum pname, GLint *params);
-GLvoid (APIENTRYP qglBlitFramebuffer) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
-				       GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
-				       GLbitfield mask, GLenum filter);
-GLvoid (APIENTRYP qglGenerateMipmap) (GLenum target);
-
-
 /*
 ===============
 GLimp_Shutdown
@@ -738,12 +584,6 @@
 
 	ri.Printf( PRINT_DEVELOPER, "Initializing OpenGL extensions\n" );
 
-	// GL_EXT_draw_range_elements
-	if ( GLimp_HaveExtension( "GL_EXT_draw_range_elements" ) )
-	{
-		qglDrawRangeElementsEXT = SDL_GL_GetProcAddress( "glDrawRangeElementsEXT" );
-	}
-
 	glConfig.textureCompression = TC_NONE;
 
 	// GL_EXT_texture_compression_s3tc
@@ -824,14 +664,9 @@
 				GLint glint = 0;
 				qglGetIntegerv( GL_MAX_TEXTURE_UNITS_ARB, &glint );
 				glConfig.numTextureUnits = (int) glint;
-				if ( glConfig.numTextureUnits > NUM_TEXTURE_BUNDLES )
-					glConfig.numTextureUnits = NUM_TEXTURE_BUNDLES;
-				if ( r_ext_multitexture->integer > 1 &&
-				     glConfig.numTextureUnits > r_ext_multitexture->integer )
-					glConfig.numTextureUnits = r_ext_multitexture->integer;
 				if ( glConfig.numTextureUnits > 1 )
 				{
-					ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_multitexture (%d of %d units)\n", glConfig.numTextureUnits, glint );
+					ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_multitexture\n" );
 				}
 				else
 				{
@@ -852,45 +687,6 @@
 		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_multitexture not found\n" );
 	}
 
-	glConfig.vertexBufferObjects = qfalse;
-	qglBindBufferARB = NULL;
-	qglDeleteBuffersARB = NULL;
-	qglGenBuffersARB = NULL;
-	qglIsBufferARB = NULL;
-	qglBufferDataARB = NULL;
-	qglBufferSubDataARB = NULL;
-	qglGetBufferSubDataARB = NULL;
-	qglMapBufferARB = NULL;
-	qglUnmapBufferARB = NULL;
-	qglGetBufferParameterivARB = NULL;
-	qglGetBufferPointervARB = NULL;
-	if ( GLimp_HaveExtension( "GL_ARB_vertex_buffer_object" ) )
-	{
-		if ( r_ext_vertex_buffer_object->integer ) {
-			qglBindBufferARB = (void (APIENTRYP)(GLenum, GLuint)) SDL_GL_GetProcAddress("glBindBufferARB");
-			qglDeleteBuffersARB = (void (APIENTRYP)(GLsizei, const GLuint *)) SDL_GL_GetProcAddress("glDeleteBuffersARB");
-			qglGenBuffersARB = (void (APIENTRYP)(GLsizei, GLuint *)) SDL_GL_GetProcAddress("glGenBuffersARB");
-			qglIsBufferARB = (GLboolean (APIENTRYP)(GLuint)) SDL_GL_GetProcAddress("glIsBufferARB");
-			qglBufferDataARB = (void (APIENTRYP)(GLenum, GLsizeiptrARB, const GLvoid *, GLenum)) SDL_GL_GetProcAddress("glBufferDataARB");
-			qglBufferSubDataARB = (void (APIENTRYP)(GLenum, GLintptrARB, GLsizeiptrARB, const GLvoid *)) SDL_GL_GetProcAddress("glBufferSubDataARB");
-			qglGetBufferSubDataARB = (void (APIENTRYP)(GLenum, GLintptrARB, GLsizeiptrARB, GLvoid *)) SDL_GL_GetProcAddress("glGetBufferSubDataARB");
-			qglMapBufferARB = (GLvoid *(APIENTRYP)(GLenum, GLenum)) SDL_GL_GetProcAddress("glMapBufferARB");
-			qglUnmapBufferARB = (GLboolean (APIENTRYP)(GLenum)) SDL_GL_GetProcAddress("glUnmapBufferARB");
-			qglGetBufferParameterivARB = (void (APIENTRYP)(GLenum, GLenum, GLint *)) SDL_GL_GetProcAddress("glGetBufferParameterivARB");
-			qglGetBufferPointervARB = (void (APIENTRYP)(GLenum, GLenum, GLvoid **)) SDL_GL_GetProcAddress("glGetBufferPointervARB");
-			glConfig.vertexBufferObjects = qtrue;
-			ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_vertex_buffer_object\n" );
-		}
-		else
-		{
-			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_vertex_buffer_object\n" );
-		}
-	}
-	else
-	{
-		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_vertex_buffer_object not found\n" );
-	}
-
 	// GL_EXT_compiled_vertex_array
 	if ( GLimp_HaveExtension( "GL_EXT_compiled_vertex_array" ) )
 	{
@@ -938,171 +734,6 @@
 	{
 		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture_filter_anisotropic not found\n" );
 	}
-
-	glConfig.vertexShaders = qfalse;
-	if ( GLimp_HaveExtension( "GL_ARB_shader_objects" )
-	     && GLimp_HaveExtension( "GL_ARB_fragment_shader" )
-	     && GLimp_HaveExtension( "GL_ARB_vertex_shader" )
-	     && GLimp_HaveExtension( "GL_ARB_shading_language_100" ) )
-	{
-		if ( r_ext_vertex_shader->integer ) {
-		  ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_vertex_shader\n" );
-		  
-		  qglDeleteObjectARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glDeleteObjectARB");
-		  qglGetHandleARB = (GLhandleARB (APIENTRYP)(GLenum)) SDL_GL_GetProcAddress("glGetHandleARB");
-		  qglDetachObjectARB = (GLvoid (APIENTRYP)(GLhandleARB, GLhandleARB)) SDL_GL_GetProcAddress("glDetachObjectARB");
-		  qglCreateShaderObjectARB = (GLhandleARB (APIENTRYP)(GLenum)) SDL_GL_GetProcAddress("glCreateShaderObjectARB");
-		  qglShaderSourceARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, const GLcharARB **,
-							   const GLint *)) SDL_GL_GetProcAddress("glShaderSourceARB");
-		  qglCompileShaderARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glCompileShaderARB");
-		  qglCreateProgramObjectARB = (GLhandleARB (APIENTRYP)(void)) SDL_GL_GetProcAddress("glCreateProgramObjectARB");
-		  qglAttachObjectARB = (GLvoid (APIENTRYP)(GLhandleARB, GLhandleARB)) SDL_GL_GetProcAddress("glAttachObjectARB");
-		  qglLinkProgramARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glLinkProgramARB");
-		  qglUseProgramObjectARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glUseProgramObjectARB");
-		  qglValidateProgramARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glValidateProgramARB");
-		  qglUniform1fARB = (GLvoid (APIENTRYP)(GLint, GLfloat)) SDL_GL_GetProcAddress("glUniform1fARB");
-		  qglUniform2fARB = (GLvoid (APIENTRYP)(GLint, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform2fARB");
-		  qglUniform3fARB = (GLvoid (APIENTRYP)(GLint, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform3fARB");
-		  qglUniform4fARB = (GLvoid (APIENTRYP)(GLint, GLfloat, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform4fARB");
-		  qglUniform1iARB = (GLvoid (APIENTRYP)(GLint, GLint)) SDL_GL_GetProcAddress("glUniform1iARB");
-		  qglUniform2iARB = (GLvoid (APIENTRYP)(GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform2iARB");
-		  qglUniform3iARB = (GLvoid (APIENTRYP)(GLint, GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform3iARB");
-		  qglUniform4iARB = (GLvoid (APIENTRYP)(GLint, GLint, GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform4iARB");
-		  qglUniform1fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform1fvARB");
-		  qglUniform2fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform2fvARB");
-		  qglUniform3fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform3fvARB");
-		  qglUniform4fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform4fvARB");
-		  qglUniform1ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform1viARB");
-		  qglUniform2ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform2ivARB");
-		  qglUniform3ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform3ivARB");
-		  qglUniform4ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform4ivARB");
-		  qglUniformMatrix2fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv2ARB");
-		  qglUniformMatrix3fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv3ARB");
-		  qglUniformMatrix4fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv4ARB");
-		  qglGetObjectParameterfvARB = (GLvoid (APIENTRYP)(GLhandleARB, GLenum, GLfloat *)) SDL_GL_GetProcAddress("glGetObjectParameterfvARB");
-		  qglGetObjectParameterivARB = (GLvoid (APIENTRYP)(GLhandleARB, GLenum, GLint *)) SDL_GL_GetProcAddress("glGetObjectParameterivARB");
-		  qglGetInfoLogARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, GLsizei *, GLcharARB *)) SDL_GL_GetProcAddress("glGetInfoLogARB");
-		  qglGetAttachedObjectsARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, GLsizei *, GLhandleARB *)) SDL_GL_GetProcAddress("glGetAttachedObjectsARB");
-		  qglGetUniformLocationARB = (GLint (APIENTRYP)(GLhandleARB, const GLcharARB *)) SDL_GL_GetProcAddress("glGetUniformLocationARB");
-		  qglGetActiveUniformARB = (GLvoid (APIENTRYP)(GLhandleARB, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLcharARB *)) SDL_GL_GetProcAddress("glGetActiveUniformARB");
-		  qglGetUniformfvARB = (GLvoid (APIENTRYP)(GLhandleARB, GLint, GLfloat *)) SDL_GL_GetProcAddress("glGetUniformfvARB");
-		  qglGetUniformivARB = (GLvoid (APIENTRYP)(GLhandleARB, GLint, GLint *)) SDL_GL_GetProcAddress("glGetUniformivARB");
-		  qglGetShaderSourceARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, GLsizei *, GLcharARB *)) SDL_GL_GetProcAddress("glGetShaderSourceARB");
-
-		  qglVertexAttrib1fARB = (GLvoid (APIENTRYP)(GLuint, GLfloat)) SDL_GL_GetProcAddress("glVertexAttrib1fARB");
-		  qglVertexAttrib1sARB = (GLvoid (APIENTRYP)(GLuint, GLshort)) SDL_GL_GetProcAddress("glVertexAttrib1sARB");
-		  qglVertexAttrib1dARB = (GLvoid (APIENTRYP)(GLuint, GLdouble)) SDL_GL_GetProcAddress("glVertexAttrib1dARB");
-		  qglVertexAttrib2fARB = (GLvoid (APIENTRYP)(GLuint, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glVertexAttrib2fARB");
-		  qglVertexAttrib2sARB = (GLvoid (APIENTRYP)(GLuint, GLshort, GLshort)) SDL_GL_GetProcAddress("glVertexAttrib2sARB");
-		  qglVertexAttrib2dARB = (GLvoid (APIENTRYP)(GLuint, GLdouble, GLdouble)) SDL_GL_GetProcAddress("glVertexAttrib2dARB");
-		  qglVertexAttrib3fARB = (GLvoid (APIENTRYP)(GLuint, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glVertexAttrib3fARB");
-		  qglVertexAttrib3sARB = (GLvoid (APIENTRYP)(GLuint, GLshort, GLshort, GLshort)) SDL_GL_GetProcAddress("glVertexAttrib3sARB");
-		  qglVertexAttrib3dARB = (GLvoid (APIENTRYP)(GLuint, GLdouble, GLdouble, GLdouble)) SDL_GL_GetProcAddress("glVertexAttrib3dARB");
-		  qglVertexAttrib4fARB = (GLvoid (APIENTRYP)(GLuint, GLfloat, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glVertexAttrib4fARB");
-		  qglVertexAttrib4sARB = (GLvoid (APIENTRYP)(GLuint, GLshort, GLshort, GLshort, GLshort)) SDL_GL_GetProcAddress("glVertexAttrib4sARB");
-		  qglVertexAttrib4dARB = (GLvoid (APIENTRYP)(GLuint, GLdouble, GLdouble, GLdouble, GLdouble)) SDL_GL_GetProcAddress("glVertexAttrib4dARB");
-		  qglVertexAttrib4NubARB = (GLvoid (APIENTRYP)(GLuint, GLubyte, GLubyte, GLubyte, GLubyte)) SDL_GL_GetProcAddress("glVertexAttrib4NubARB");
-		  qglVertexAttrib1fvARB = (GLvoid (APIENTRYP)(GLuint, GLfloat *)) SDL_GL_GetProcAddress("glVertexAttrib1fvARB");
-		  qglVertexAttrib1svARB = (GLvoid (APIENTRYP)(GLuint, GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib1svARB");
-		  qglVertexAttrib1dvARB = (GLvoid (APIENTRYP)(GLuint, GLdouble *)) SDL_GL_GetProcAddress("glVertexAttrib1dvARB");
-		  qglVertexAttrib2fvARB = (GLvoid (APIENTRYP)(GLuint, GLfloat *)) SDL_GL_GetProcAddress("glVertexAttrib2fvARB");
-		  qglVertexAttrib2svARB = (GLvoid (APIENTRYP)(GLuint, GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib2svARB");
-		  qglVertexAttrib2dvARB = (GLvoid (APIENTRYP)(GLuint, GLdouble *)) SDL_GL_GetProcAddress("glVertexAttrib2dvARB");
-		  qglVertexAttrib3fvARB = (GLvoid (APIENTRYP)(GLuint, GLfloat *)) SDL_GL_GetProcAddress("glVertexAttrib3fvARB");
-		  qglVertexAttrib3svARB = (GLvoid (APIENTRYP)(GLuint, GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib3svARB");
-		  qglVertexAttrib3dvARB = (GLvoid (APIENTRYP)(GLuint, GLdouble *)) SDL_GL_GetProcAddress("glVertexAttrib3dvARB");
-		  qglVertexAttrib4fvARB = (GLvoid (APIENTRYP)(GLuint, GLfloat *)) SDL_GL_GetProcAddress("glVertexAttrib4fvARB");
-		  qglVertexAttrib4svARB = (GLvoid (APIENTRYP)(GLuint, GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib4svARB");
-		  qglVertexAttrib4dvARB = (GLvoid (APIENTRYP)(GLuint, GLdouble *)) SDL_GL_GetProcAddress("glVertexAttrib4dvARB");
-		  qglVertexAttrib4ivARB = (GLvoid (APIENTRYP)(GLuint, GLint *)) SDL_GL_GetProcAddress("glVertexAttrib4ivARB");
-		  qglVertexAttrib4bvARB = (GLvoid (APIENTRYP)(GLuint, GLbyte *)) SDL_GL_GetProcAddress("glVertexAttrib4bvARB");
-		  qglVertexAttrib4ubvARB = (GLvoid (APIENTRYP)(GLuint, GLubyte *)) SDL_GL_GetProcAddress("glVertexAttrib4ubvARB");
-		  qglVertexAttrib4usvARB = (GLvoid (APIENTRYP)(GLuint, GLushort *)) SDL_GL_GetProcAddress("glVertexAttrib4usvARB");
-		  qglVertexAttrib4uivARB = (GLvoid (APIENTRYP)(GLuint, GLuint *)) SDL_GL_GetProcAddress("glVertexAttrib4uivARB");
-		  qglVertexAttrib4NbvARB = (GLvoid (APIENTRYP)(GLuint, const GLbyte *)) SDL_GL_GetProcAddress("glVertexAttrib4NbvARB");
-		  qglVertexAttrib4NsvARB = (GLvoid (APIENTRYP)(GLuint, const GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib4NsvARB");
-		  qglVertexAttrib4NivARB = (GLvoid (APIENTRYP)(GLuint, const GLint *)) SDL_GL_GetProcAddress("glVertexAttrib4NivARB");
-		  qglVertexAttrib4NubvARB = (GLvoid (APIENTRYP)(GLuint, const GLubyte *)) SDL_GL_GetProcAddress("glVertexAttrib4NubvARB");
-		  qglVertexAttrib4NusvARB = (GLvoid (APIENTRYP)(GLuint, const GLushort *)) SDL_GL_GetProcAddress("glVertexAttrib4NusvARB");
-		  qglVertexAttrib4NuivARB = (GLvoid (APIENTRYP)(GLuint, const GLuint *)) SDL_GL_GetProcAddress("glVertexAttrib4NuivARB");
-		  qglVertexAttribPointerARB = (GLvoid (APIENTRYP)(GLuint, GLint, GLenum, GLboolean, GLsizei, const GLvoid *)) SDL_GL_GetProcAddress("glVertexAttribPointerARB");
-		  qglEnableVertexAttribArrayARB = (GLvoid (APIENTRYP)(GLuint)) SDL_GL_GetProcAddress("glEnableVertexAttribArrayARB");
-		  qglDisableVertexAttribArrayARB = (GLvoid (APIENTRYP)(GLuint)) SDL_GL_GetProcAddress("glDisableVertexAttribArrayARB");
-		  qglBindAttribLocationARB = (GLvoid (APIENTRYP)(GLhandleARB, GLuint, const GLcharARB *)) SDL_GL_GetProcAddress("glBindAttribLocationARB");
-		  qglGetActiveAttribARB = (GLvoid (APIENTRYP)(GLhandleARB, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLcharARB *)) SDL_GL_GetProcAddress("glGetActiveAttribARB");
-		  qglGetAttribLocationARB = (GLint (APIENTRYP)(GLhandleARB, const GLcharARB *)) SDL_GL_GetProcAddress("glGetAttribLocationARB");
-		  qglGetVertexAttribdvARB = (GLvoid (APIENTRYP)(GLuint, GLenum, GLdouble *)) SDL_GL_GetProcAddress("glGetVertexAttribdvARB");
-		  qglGetVertexAttribfvARB = (GLvoid (APIENTRYP)(GLuint, GLenum, GLfloat *)) SDL_GL_GetProcAddress("glGetVertexAttribfvARB");
-		  qglGetVertexAttribivARB = (GLvoid (APIENTRYP)(GLuint, GLenum, GLint *)) SDL_GL_GetProcAddress("glGetVertexAAttribivARB");
-		  qglGetVertexAttribPointervARB = (GLvoid (APIENTRYP)(GLuint, GLenum, GLvoid **)) SDL_GL_GetProcAddress("glGetVertexAttribPointervARB");
-
-		  glConfig.vertexShaders = qtrue;
-		}
-		else
-		{
-			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_vertex_shader\n" );
-		}
-	}
-	else
-	{
-		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_vertex_shader\n" );
-	}
-
-	if ( GLimp_HaveExtension( "GL_ARB_framebuffer_object" ) )
-	{
-		if ( r_ext_framebuffer_object->integer ) {
-		  ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_framebuffer_object\n" );
-		  
-		  qglDeleteObjectARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glDeleteObjectARB");
-		  qglGetHandleARB = (GLhandleARB (APIENTRYP)(GLenum)) SDL_GL_GetProcAddress("glGetHandleARB");
-		  qglDetachObjectARB = (GLvoid (APIENTRYP)(GLhandleARB, GLhandleARB)) SDL_GL_GetProcAddress("glDetachObjectARB");
-		  qglCreateShaderObjectARB = (GLhandleARB (APIENTRYP)(GLenum)) SDL_GL_GetProcAddress("glCreateShaderObjectARB");
-		  qglShaderSourceARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, const GLcharARB **,
-							   const GLint *)) SDL_GL_GetProcAddress("glShaderSourceARB");
-		  qglCompileShaderARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glCompileShaderARB");
-		  qglCreateProgramObjectARB = (GLhandleARB (APIENTRYP)(void)) SDL_GL_GetProcAddress("glCreateProgramObjectARB");
-		  qglAttachObjectARB = (GLvoid (APIENTRYP)(GLhandleARB, GLhandleARB)) SDL_GL_GetProcAddress("glAttachObjectARB");
-		  qglLinkProgramARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glLinkProgramARB");
-		  qglUseProgramObjectARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glUseProgramObjectARB");
-		  qglValidateProgramARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glValidateProgramARB");
-		  qglUniform1fARB = (GLvoid (APIENTRYP)(GLint, GLfloat)) SDL_GL_GetProcAddress("glUniform1fARB");
-		  qglUniform2fARB = (GLvoid (APIENTRYP)(GLint, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform2fARB");
-		  qglUniform3fARB = (GLvoid (APIENTRYP)(GLint, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform3fARB");
-		  qglUniform4fARB = (GLvoid (APIENTRYP)(GLint, GLfloat, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform4fARB");
-		  qglUniform1iARB = (GLvoid (APIENTRYP)(GLint, GLint)) SDL_GL_GetProcAddress("glUniform1iARB");
-		  qglUniform2iARB = (GLvoid (APIENTRYP)(GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform2iARB");
-		  qglUniform3iARB = (GLvoid (APIENTRYP)(GLint, GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform3iARB");
-		  qglUniform4iARB = (GLvoid (APIENTRYP)(GLint, GLint, GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform4iARB");
-		  qglUniform1fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform1fvARB");
-		  qglUniform2fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform2fvARB");
-		  qglUniform3fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform3fvARB");
-		  qglUniform4fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform4fvARB");
-		  qglUniform1ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform1viARB");
-		  qglUniform2ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform2ivARB");
-		  qglUniform3ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform3ivARB");
-		  qglUniform4ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform4ivARB");
-		  qglUniformMatrix2fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv2ARB");
-		  qglUniformMatrix3fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv3ARB");
-		  qglUniformMatrix4fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv4ARB");
-		  qglGetObjectParameterfvARB = (GLvoid (APIENTRYP)(GLhandleARB, GLenum, GLfloat *)) SDL_GL_GetProcAddress("glGetObjectParameterfvARB");
-		  qglGetObjectParameterivARB = (GLvoid (APIENTRYP)(GLhandleARB, GLenum, GLint *)) SDL_GL_GetProcAddress("glGetObjectParameterivARB");
-		  qglGetInfoLogARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, GLsizei *, GLcharARB *)) SDL_GL_GetProcAddress("glGetInfoLogARB");
-		  qglGetAttachedObjectsARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, GLsizei *, GLhandleARB *)) SDL_GL_GetProcAddress("glGetAttachedObjectsARB");
-		  qglGetUniformLocationARB = (GLint (APIENTRYP)(GLhandleARB, const GLcharARB *)) SDL_GL_GetProcAddress("glGetUniformLocationARB");
-		  qglGetActiveUniformARB = (GLvoid (APIENTRYP)(GLhandleARB, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLcharARB *)) SDL_GL_GetProcAddress("glGetActiveUniformARB");
-		  qglGetUniformfvARB = (GLvoid (APIENTRYP)(GLhandleARB, GLint, GLfloat *)) SDL_GL_GetProcAddress("glGetUniformfvARB");
-		  qglGetUniformivARB = (GLvoid (APIENTRYP)(GLhandleARB, GLint, GLint *)) SDL_GL_GetProcAddress("glGetUniformivARB");
-		  qglGetShaderSourceARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, GLsizei *, GLcharARB *)) SDL_GL_GetProcAddress("glGetShaderSourceARB");
-		}
-		else
-		{
-			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_framebuffer_object\n" );
-		}
-	}
-	else
-	{
-		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_framebuffer_object\n" );
-	}
 }
 
 /*
@@ -1122,7 +753,7 @@
 
 	Sys_GLimpInit( );
 
-#if defined(SMP) && defined(SDL_VIDEO_DRIVER_X11)
+#ifdef SDL_VIDEO_DRIVER_X11
 	XInitThreads( );
 #endif
 
@@ -1253,7 +884,6 @@
 
 
 
-#ifdef SMP
 /*
 ===========================================================
 
@@ -1465,31 +1095,3 @@
 	}
 	SDL_UnlockMutex(smpMutex);
 }
-
-#else
-
-// No SMP - stubs
-void GLimp_RenderThreadWrapper( void *arg )
-{
-}
-
-qboolean GLimp_SpawnRenderThread( void (*function)( void ) )
-{
-	ri.Printf( PRINT_WARNING, "ERROR: SMP support was disabled at compile time\n");
-	return qfalse;
-}
-
-void *GLimp_RendererSleep( void )
-{
-	return NULL;
-}
-
-void GLimp_FrontEndSleep( void )
-{
-}
-
-void GLimp_WakeRenderer( void *data )
-{
-}
-
-#endif
diff -r 87f98d895296 -r 91f0a3d9f930 src/sdl/sdl_input.c
--- a/src/sdl/sdl_input.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/sdl/sdl_input.c	Sat Jun 06 02:45:31 2009 +0800
@@ -315,6 +315,9 @@
 	{
 		unsigned char ch = (unsigned char)keysym->unicode & 0xFF;
 
+		if( ch >= '0' && ch <= '9' )
+			*key = ch;
+
 		switch( ch )
 		{
 			case 127: // ASCII delete
diff -r 87f98d895296 -r 91f0a3d9f930 src/server/server.h
--- a/src/server/server.h	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/server/server.h	Sat Jun 06 02:45:31 2009 +0800
@@ -276,6 +276,7 @@
 extern	cvar_t	*sv_demoState;
 extern	cvar_t	*sv_autoDemo;
 extern	cvar_t	*sv_pure;
+extern	cvar_t	*sv_rateOverride;
 
 #ifdef USE_VOIP
 extern	cvar_t	*sv_voip;
diff -r 87f98d895296 -r 91f0a3d9f930 src/server/sv_client.c
--- a/src/server/sv_client.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/server/sv_client.c	Sat Jun 06 02:45:31 2009 +0800
@@ -898,6 +898,8 @@
 	// internet public server, assume they don't need a rate choke
 	if ( Sys_IsLANAddress( cl->netchan.remoteAddress ) && com_dedicated->integer != 2 && sv_lanForceRate->integer == 1) {
 		cl->rate = 99999;	// lans should not rate limit
+	} else if ( sv_rateOverride->integer ) {
+		cl->rate = sv_rateOverride->integer;
 	} else {
 		val = Info_ValueForKey (cl->userinfo, "rate");
 		if (strlen(val)) {
diff -r 87f98d895296 -r 91f0a3d9f930 src/server/sv_init.c
--- a/src/server/sv_init.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/server/sv_init.c	Sat Jun 06 02:45:31 2009 +0800
@@ -370,7 +370,7 @@
 ================
 SV_TouchCGame
 
-  touch the cgame.vm so that a pure client can load it if it's in a seperate pk3
+Touch the cgame.qvm and ui.qvm so that a pure client can load it if it's in a seperate pk3, and so it gets on the download list
 ================
 */
 void SV_TouchCGame(void) {
@@ -379,6 +379,15 @@
 	FS_FOpenFileRead( "vm/cgame.qvm", &f, qfalse );
 	if ( f ) {
 		FS_FCloseFile( f );
+	} else if ( sv_pure->integer ) {
+		Com_Printf( "WARNING: No cgame.qvm found on pure server\n" );
+	}
+
+	FS_FOpenFileRead( "vm/ui.qvm", &f, qfalse );
+	if ( f ) {
+		FS_FCloseFile( f );
+	} else if ( sv_pure->integer ) {
+		Com_Printf( "WARNING: No ui.qvm found on pure server\n" );
 	}
 }
 
@@ -530,8 +539,8 @@
 
 	// the server sends these to the clients so they will only
 	// load pk3s also loaded at the server
-	Cvar_Set( "sv_paks", FS_LoadedPakChecksums() );
-	Cvar_Set( "sv_pakNames", FS_LoadedPakNames() );
+	Cvar_Set( "sv_paks", sv_pure->integer ? FS_LoadedPakChecksums() : "" );
+	Cvar_Set( "sv_pakNames", sv_pure->integer ? FS_LoadedPakNames() : "" );
 
 	// the server sends these to the clients so they can figure
 	// out which pk3s should be auto-downloaded
@@ -602,6 +611,7 @@
 	// systeminfo
 	Cvar_Get ("sv_cheats", "1", CVAR_SYSTEMINFO | CVAR_ROM );
 	sv_pure = Cvar_Get ("sv_pure", "0", CVAR_SYSTEMINFO );
+	sv_rateOverride = Cvar_Get ("sv_rateOverride", "50000", 0 );
 	sv_serverid = Cvar_Get ("sv_serverid", "0", CVAR_SYSTEMINFO | CVAR_ROM );
 #ifdef USE_VOIP
 	sv_voip = Cvar_Get ("sv_voip", "1", CVAR_SYSTEMINFO | CVAR_LATCH);
diff -r 87f98d895296 -r 91f0a3d9f930 src/server/sv_main.c
--- a/src/server/sv_main.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/server/sv_main.c	Sat Jun 06 02:45:31 2009 +0800
@@ -59,6 +59,7 @@
 cvar_t	*sv_demoState;
 cvar_t	*sv_autoDemo;
 cvar_t	*sv_pure;
+cvar_t	*sv_rateOverride;
 
 /*
 =============================================================================
diff -r 87f98d895296 -r 91f0a3d9f930 src/server/sv_world.c
--- a/src/server/sv_world.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/server/sv_world.c	Sat Jun 06 02:45:31 2009 +0800
@@ -24,11 +24,6 @@
 
 #include "server.h"
 
-#if id386_sse >= 1
-#include "../qcommon/qsse.h"
-clipHandle_t CM_TempBoxModel_sse( v4f mins, v4f maxs, int capsule );
-#endif
-
 /*
 ================
 SV_ClipHandleForEntity
@@ -45,20 +40,10 @@
 	}
 	if ( ent->r.svFlags & SVF_CAPSULE ) {
 		// create a temp capsule from bounding box sizes
-#if id386_sse >= 1
-		if ( com_sse->integer >= 1 ) {
-			return CM_TempBoxModel_sse( vec3Load(ent->r.mins), vec3Load(ent->r.maxs), qtrue );
-		}
-#endif
 		return CM_TempBoxModel( ent->r.mins, ent->r.maxs, qtrue );
 	}
-	
+
 	// create a temp tree from bounding box sizes
-#if id386_sse >= 1
-	if ( com_sse->integer >= 1 ) {
-		return CM_TempBoxModel_sse( vec3Load(ent->r.mins), vec3Load(ent->r.maxs),  qfalse );
-	}
-#endif
 	return CM_TempBoxModel( ent->r.mins, ent->r.maxs, qfalse );
 }
 
diff -r 87f98d895296 -r 91f0a3d9f930 src/sys/con_curses.c
--- a/src/sys/con_curses.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/sys/con_curses.c	Sat Jun 06 02:45:31 2009 +0800
@@ -286,6 +286,7 @@
 	}
 
 	endwin();
+	curses_on = qfalse;
 }
 
 /*
diff -r 87f98d895296 -r 91f0a3d9f930 src/sys/con_tty.c
--- a/src/sys/con_tty.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/sys/con_tty.c	Sat Jun 06 02:45:31 2009 +0800
@@ -178,6 +178,7 @@
 
   // Restore blocking to stdin reads
   fcntl( 0, F_SETFL, fcntl( 0, F_GETFL, 0 ) & ~O_NONBLOCK );
+  ttycon_on = qfalse;
 }
 
 /*
diff -r 87f98d895296 -r 91f0a3d9f930 src/sys/con_win32.c
--- a/src/sys/con_win32.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/sys/con_win32.c	Sat Jun 06 02:45:31 2009 +0800
@@ -120,6 +120,10 @@
 */
 void CON_Shutdown( void )
 {
+	static qboolean shutdown = qfalse;
+	if (shutdown)
+		return;
+	shutdown = qtrue;
 	SetConsoleMode( qconsole_hin, qconsole_orig_mode );
 	SetConsoleCursorInfo( qconsole_hout, &qconsole_orig_cursorinfo );
 	CloseHandle( qconsole_hout );
diff -r 87f98d895296 -r 91f0a3d9f930 src/sys/sys_unix.c
--- a/src/sys/sys_unix.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/sys/sys_unix.c	Sat Jun 06 02:45:31 2009 +0800
@@ -54,17 +54,9 @@
 		{
 			Q_strncpyz( homePath, p, sizeof( homePath ) );
 #ifdef MACOS_X
-#if USE_OLD_HOMEPATH
 			Q_strcat( homePath, sizeof( homePath ), "/Library/Application Support/Tremulous" );
 #else
-			Q_strcat( homePath, sizeof( homePath ), "/Library/Application Support/Tremfusion" );
-#endif
-#else
-#if USE_OLD_HOMEPATH
 			Q_strcat( homePath, sizeof( homePath ), "/.tremulous" );
-#else
-			Q_strcat( homePath, sizeof( homePath ), "/.tremfusion" );
-#endif
 #endif
 		}
 	}
@@ -528,6 +520,9 @@
 	fileHandle_t f;
 	const char *fileName = "crashlog.txt";
 
+	// Shut down now so that the curses console doesn't clear the screen when it's really shut down
+	CON_Shutdown( );
+
 	Sys_Print( va( "%s\n", error ) );
 
 	// Write console log to file and to stderr
diff -r 87f98d895296 -r 91f0a3d9f930 src/sys/sys_win32.c
--- a/src/sys/sys_win32.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/sys/sys_win32.c	Sat Jun 06 02:45:31 2009 +0800
@@ -70,29 +70,15 @@
 	
 	if( !*homePath )
 	{
-#if USE_OLD_HOMEPATH
 		if( !SUCCEEDED( SHGetFolderPath( NULL, CSIDL_APPDATA,
 						NULL, 0, szPath ) ) )
-#else
-		if( !SUCCEEDED( SHGetFolderPath( NULL, CSIDL_PERSONAL,
-						NULL, 0, szPath ) ) )
-#endif
 		{
-#if USE_OLD_HOMEPATH
 			Com_Printf("Unable to find CSIDL_APPDATA\n");
-#else
-			Com_Printf("Unable to find CSIDL_PERSONAL\n");
-#endif
 			return NULL;
 		}
 		Q_strncpyz( homePath, szPath, sizeof( homePath ) );
-#if USE_OLD_HOMEPATH
 		Q_strcat( homePath, sizeof( homePath ), "\\Tremulous" );
-#else
-		Q_strcat( homePath, sizeof( homePath ), "\\My Games\\Tremfusion" );
-#endif
 
-#if USE_OLD_HOMEPATH
 		if( !SUCCEEDED( SHGetFolderPath( NULL, CSIDL_LOCAL_APPDATA,
 						NULL, 0, szPath ) ) )
 		{
@@ -102,9 +88,6 @@
 		Q_strncpyz( homePathOld, szPath, sizeof( homePath ) );
 		Q_strcat( homePathOld, sizeof( homePathOld ), "\\Tremulous" );
 		*path2 = homePathOld;
-#else
-		*path2 = NULL;
-#endif
 	}
 
 	return homePath;
diff -r 87f98d895296 -r 91f0a3d9f930 src/ui/ui_local.h
--- a/src/ui/ui_local.h	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/ui/ui_local.h	Sat Jun 06 02:45:31 2009 +0800
@@ -107,13 +107,6 @@
   int    nextSortTime;
   qhandle_t currentServerPreview;
   int    currentServerCinematic;
-  int    motdLen;
-  int    motdWidth;
-  int    motdPaintX;
-  int    motdPaintX2;
-  int    motdOffset;
-  int    motdTime;
-  char  motd[MAX_STRING_CHARS];
 }
 serverStatus_t;
 
diff -r 87f98d895296 -r 91f0a3d9f930 src/ui/ui_main.c
--- a/src/ui/ui_main.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/ui/ui_main.c	Sat Jun 06 02:45:31 2009 +0800
@@ -888,7 +888,7 @@
 */
 static void UI_BuildServerDisplayList( qboolean force )
 {
-  int i, count, clients, maxClients, ping, len, visible;
+  int i, count, clients, maxClients, ping, visible;
   char info[MAX_STRING_CHARS];
   static int numinvisible;
 
@@ -899,17 +899,6 @@
   if( force == 2 )
     force = 0;
 
-  // do motd updates here too
-  trap_Cvar_VariableStringBuffer( "cl_motdString", uiInfo.serverStatus.motd, sizeof( uiInfo.serverStatus.motd ) );
-
-  len = strlen( uiInfo.serverStatus.motd );
-
-  if( len != uiInfo.serverStatus.motdLen )
-  {
-    uiInfo.serverStatus.motdLen = len;
-    uiInfo.serverStatus.motdWidth = -1;
-  }
-
   if( force )
   {
     numinvisible = 0;
@@ -1794,6 +1783,7 @@
 
 static const char *UI_OwnerDrawText( int ownerDraw )
 {
+  static char motd[MAX_STRING_CHARS];
   const char *s = NULL;
 
   switch( ownerDraw )
@@ -1836,7 +1826,8 @@
       break;
 
     case UI_SERVERMOTD:
-      s = uiInfo.serverStatus.motd;
+      trap_Cvar_VariableStringBuffer( "cl_motdString", motd, sizeof( motd ) );
+      s = motd;
       break;
 
     default:
diff -r 87f98d895296 -r 91f0a3d9f930 src/ui/ui_shared.c
--- a/src/ui/ui_shared.c	Sun Mar 29 01:15:08 2009 +0800
+++ b/src/ui/ui_shared.c	Sat Jun 06 02:45:31 2009 +0800
@@ -1803,13 +1803,13 @@
   const char *name;
   itemDef_t *focusItem;
 
-  Menu_ClearFocus( item->parent );
   if( String_Parse( args, &name ) )
   {
     focusItem = Menu_FindItemByName( item->parent, name );
 
     if( focusItem && !( focusItem->window.flags & WINDOW_DECORATION ) )
     {
+      Menu_ClearFocus( item->parent );
       focusItem->window.flags |= WINDOW_HASFOCUS;
 
       if( focusItem->onFocus )
@@ -2883,7 +2883,7 @@
   range = editDef->maxVal - editDef->minVal;
   value -= editDef->minVal;
   value /= range;
-  value *= SLIDER_WIDTH;
+  value *= SLIDER_WIDTH - SLIDER_THUMB_WIDTH;
   x += value;
 
   return x;
@@ -2902,7 +2902,7 @@
   rectDef_t r;
   float vScale = Item_Slider_VScale( item );
 
-  r.x = Item_Slider_ThumbPosition( item ) - ( SLIDER_THUMB_WIDTH / 2 );
+  r.x = Item_Slider_ThumbPosition( item );
   r.y = item->textRect.y - item->textRect.h +
         ( ( item->textRect.h - ( SLIDER_THUMB_HEIGHT * vScale ) ) / 2.0f );
   r.w = SLIDER_THUMB_WIDTH;
@@ -3544,7 +3544,8 @@
     }
   }
 
-  return "";
+  DC->getCVarString( item->cvar, buff, sizeof( buff ) );
+  return va( "Custom (%s)", buff );
 }
 
 qboolean Item_Combobox_HandleKey( itemDef_t *item, int key )
@@ -3976,8 +3977,8 @@
   else if( cursorx > x + SLIDER_WIDTH )
     cursorx = x + SLIDER_WIDTH;
 
-  value = cursorx - x;
-  value /= SLIDER_WIDTH;
+  value = cursorx - x - ( SLIDER_THUMB_WIDTH / 2 );
+  value /= SLIDER_WIDTH - SLIDER_THUMB_WIDTH;
   value *= ( editDef->maxVal - editDef->minVal );
   value += editDef->minVal;
   DC->setCVar( si->item->cvar, va( "%f", value ) );
@@ -5557,9 +5558,7 @@
       ( ( item->textRect.h - ( SLIDER_THUMB_HEIGHT * vScale ) ) / 2.0f );
 
   x = Item_Slider_ThumbPosition( item );
-  DC->drawHandlePic( x - ( SLIDER_THUMB_WIDTH / 2 ), y,
-                     SLIDER_THUMB_WIDTH, SLIDER_THUMB_HEIGHT * vScale, DC->Assets.sliderThumb );
-
+  DC->drawHandlePic( x, y, SLIDER_THUMB_WIDTH, SLIDER_THUMB_HEIGHT * vScale, DC->Assets.sliderThumb );
 }
 
 void Item_Bind_Paint( itemDef_t *item )
@@ -5991,20 +5990,20 @@
     {
       // draw scrollbar to right side of the window
       x = item->window.rect.x + item->window.rect.w - SCROLLBAR_WIDTH - one;
-      y = item->window.rect.y + 1;
+      y = item->window.rect.y + 2;
       DC->drawHandlePic( x, y, SCROLLBAR_WIDTH, SCROLLBAR_HEIGHT, DC->Assets.scrollBarArrowUp );
-      y += SCROLLBAR_HEIGHT - 1;
+      y += SCROLLBAR_HEIGHT;
 
       listPtr->endPos = listPtr->startPos;
       size = item->window.rect.h - ( SCROLLBAR_HEIGHT * 2 );
-      DC->drawHandlePic( x, y, SCROLLBAR_WIDTH, size + 1, DC->Assets.scrollBar );
-      y += size - 1;
+      DC->drawHandlePic( x, y, SCROLLBAR_WIDTH, size -4 , DC->Assets.scrollBar );
+      y += size - 4;
       DC->drawHandlePic( x, y, SCROLLBAR_WIDTH, SCROLLBAR_HEIGHT, DC->Assets.scrollBarArrowDown );
       // thumb
       thumb = Item_ListBox_ThumbDrawPosition( item );//Item_ListBox_ThumbPosition(item);
-
-      if( thumb > y - SCROLLBAR_HEIGHT - 1 )
-        thumb = y - SCROLLBAR_HEIGHT - 1;
+      thumb += 1;
+      if( thumb > y - SCROLLBAR_HEIGHT )
+        thumb = y - SCROLLBAR_HEIGHT;
 
       DC->drawHandlePic( x, thumb, SCROLLBAR_WIDTH, SCROLLBAR_HEIGHT, DC->Assets.scrollBarThumb );
     }
diff -r 87f98d895296 -r 91f0a3d9f930 ui/assets/scrollbar_arrow_dwn_a.tga
Binary file ui/assets/scrollbar_arrow_dwn_a.tga has changed
diff -r 87f98d895296 -r 91f0a3d9f930 ui/assets/scrollbar_arrow_up_a.tga
Binary file ui/assets/scrollbar_arrow_up_a.tga has changed
diff -r 87f98d895296 -r 91f0a3d9f930 voice/as2.ogg
Binary file voice/as2.ogg has changed
diff -r 87f98d895296 -r 91f0a3d9f930 voice/as3.ogg
Binary file voice/as3.ogg has changed
diff -r 87f98d895296 -r 91f0a3d9f930 voice/base.ogg
Binary file voice/base.ogg has changed
diff -r 87f98d895296 -r 91f0a3d9f930 voice/base.wav
Binary file voice/base.wav has changed
diff -r 87f98d895296 -r 91f0a3d9f930 voice/builder.ogg
Binary file voice/builder.ogg has changed
diff -r 87f98d895296 -r 91f0a3d9f930 voice/default.voice
--- a/voice/default.voice	Sun Mar 29 01:15:08 2009 +0800
+++ b/voice/default.voice	Sat Jun 06 02:45:31 2009 +0800
@@ -1,14 +1,79 @@
 base
 {
-	"voice/base.wav"
+	"voice/base.ogg"
 	{
-		text "^1Base under attack!"
+		text "Base under attack!"
 	}
 }
-rush
+
+as2
 {
-	"voice/rush.wav"
+	"voice/as2.ogg"
 	{
-		text "^2Rush the enemy!"
+		text "The aliens have reached stage 2!"
 	}
 }
+
+as3
+{
+	"voice/as3.ogg"
+	{
+		text "The aliens have reached stage 3!"
+	}
+}
+
+builder
+{
+	"voice/builder.ogg"
+	{
+		text "We need a builder!"
+	}
+}
+
+flank
+{
+	"voice/flank.ogg"
+	{
+		text "Flank!"
+	}
+}
+
+followme
+{
+	"voice/followme.ogg"
+	{
+		text "Follow me!"
+	}
+}
+
+getback
+{
+	"voice/getback.ogg"
+	{
+		text "Get back!"
+	}
+}
+
+grenade
+{
+	"voice/grenade.ogg"
+	{
+		text "Grenade!"
+	}
+}
+
+moveforward
+{
+	"voice/moveforward.ogg"
+	{
+		text "Move forward!"
+	}
+}
+
+repair
+{
+	"voice/repair.ogg"
+	{
+		text "Our base needs repairs!"
+	}
+}
diff -r 87f98d895296 -r 91f0a3d9f930 voice/flank.ogg
Binary file voice/flank.ogg has changed
diff -r 87f98d895296 -r 91f0a3d9f930 voice/followme.ogg
Binary file voice/followme.ogg has changed
diff -r 87f98d895296 -r 91f0a3d9f930 voice/getback.ogg
Binary file voice/getback.ogg has changed
diff -r 87f98d895296 -r 91f0a3d9f930 voice/grenade.ogg
Binary file voice/grenade.ogg has changed
diff -r 87f98d895296 -r 91f0a3d9f930 voice/moveforward.ogg
Binary file voice/moveforward.ogg has changed
diff -r 87f98d895296 -r 91f0a3d9f930 voice/repair.ogg
Binary file voice/repair.ogg has changed
diff -r 87f98d895296 -r 91f0a3d9f930 voice/rush.ogg
Binary file voice/rush.ogg has changed
diff -r 87f98d895296 -r 91f0a3d9f930 voice/rush.wav
Binary file voice/rush.wav has changed
