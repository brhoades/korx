diff -r 91f0a3d9f930 -r 4b5fc919fd59 .hgtags
--- a/.hgtags	Sat Jun 06 02:45:31 2009 +0800
+++ b/.hgtags	Mon Jul 06 04:07:05 2009 +0800
@@ -6,3 +6,6 @@
 766004a14b15a0c8c641b7decace3ad714a84dc3 0.9
 4135d88d07f11cc9e0527d4e6b1f389b8f4b961c 0.99
 87f98d895296ca5dd3f9570f799b4f2ffe0c5187 0.99
+91f0a3d9f9301e16f1c414226fdfb684d2a123d2 0.99r2
+249cb5d8ea8142b1e1a77c09f0930edfa275df78 0.99r3
+4432c63b51b2ff1f519dc45e64bc2c54c777a307 0.99r3
diff -r 91f0a3d9f930 -r 4b5fc919fd59 Makefile
--- a/Makefile	Sat Jun 06 02:45:31 2009 +0800
+++ b/Makefile	Mon Jul 06 04:07:05 2009 +0800
@@ -111,6 +111,14 @@
   USE_CODEC_VORBIS=1
 endif
 
+ifndef USE_CIN_THEORA
+  USE_CIN_THEORA=0
+endif
+
+ifeq ($(USE_CIN_THEORA),1)
+  USE_CODEC_VORBIS=1
+endif
+
 ifndef USE_CURSES
   USE_CURSES=1
 endif
@@ -152,7 +160,11 @@
   ifeq ($(ARCH),x86_64)
     USE_SSE=2
   else
-    USE_SSE=1
+	ifeq ($(ARCH),x86)
+	  USE_SSE=1
+	else
+	  USE_SSE=0
+	endif
   endif
 endif
 
@@ -198,10 +210,24 @@
   SDL_LIBS=$(shell pkg-config --libs sdl)
   OGG_CFLAGS=$(shell pkg-config --cflags ogg vorbis vorbisfile)
   OGG_LIBS=$(shell pkg-config --libs ogg vorbis vorbisfile)
+  # Some distros still use the old pkgconfig string
+  THEORA_CFLAGS=$(shell pkg-config --cflags theoradec 2> /dev/null)
+  THEORA_LIBS=$(shell pkg-config --libs theoradec 2> /dev/null)
+  ifeq ($(THEORA_LIBS),)
+    THEORA_CFLAGS=$(shell pkg-config --cflags theora)
+	THEORA_LIBS=$(shell pkg-config --libs theora)
+  endif
+endif
+# Use sdl-config if all else fails
+ifeq ($(SDL_CFLAGS),)
+  ifeq ($(shell which sdl-config > /dev/null; echo $$?),0)
+    SDL_CFLAGS=$(shell sdl-config --cflags)
+    SDL_LIBS=$(shell sdl-config --libs)
+  endif
 endif
 
 # version info
-VERSION_NUMBER=0.99r2
+VERSION_NUMBER=0.99r3
 
 ifeq ($(USE_SCM_VERSION),1)
   # For svn
@@ -280,7 +306,7 @@
   endif
 
   BASE_CFLAGS = -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes -pipe \
-    -DUSE_ICON $(shell sdl-config --cflags)
+    -DUSE_ICON $(SDL_CFLAGS)
 
   ifeq ($(USE_OPENAL),1)
     BASE_CFLAGS += -DUSE_OPENAL
@@ -317,6 +343,16 @@
     TTYC_CFLAGS += -UUSE_CODEC_VORBIS
   endif
 
+  ifeq ($(USE_CIN_THEORA),1)
+    BASE_CFLAGS += -DUSE_CIN_THEORA
+    ifeq ($(USE_LOCAL_HEADERS),1)
+      BASE_CFLAGS += -I$(OGGDIR)
+    else
+      BASE_CFLAGS += $(THEORA_CFLAGS)
+    endif
+    TTYC_CFLAGS += -UUSE_CIN_THEORA
+  endif
+
   OPTIMIZE = -O3 -funroll-loops -fomit-frame-pointer
 
   ifeq ($(ARCH),x86_64)
@@ -368,7 +404,7 @@
   CLIENT_LDFLAGS=-L/usr/X11R6/$(LIB)
   LIBS=-ldl -lm
 
-  CLIENT_LIBS += $(shell sdl-config --libs) -lGL -lpthread -lX11
+  CLIENT_LIBS += $(SDL_LIBS) -lGL -lpthread -lX11
 
   ifeq ($(USE_OPENAL),1)
     ifneq ($(USE_OPENAL_DLOPEN),1)
@@ -387,6 +423,10 @@
     CLIENT_LIBS += $(OGG_LIBS)
   endif
 
+  ifeq ($(USE_CIN_THEORA),1)
+    CLIENT_LIBS += $(THEORA_LIBS)
+  endif
+
   ifeq ($(USE_CURSES),1)
      LIBS += -lncurses
      BASE_CFLAGS += -DUSE_CURSES
@@ -437,9 +477,9 @@
   endif
   ifeq ($(ARCH),x86)
     OPTIMIZE += -march=prescott -mfpmath=sse
-    # x86 vm will crash without -mstackrealign since MMX instructions will be
-    # used no matter what and they corrupt the frame pointer in VM calls
-    BASE_CFLAGS += -mstackrealign
+  endif
+  ifeq ($(ARCH),x86_64)
+    OPTIMIZE += -mfpmath=sse
   endif
 
   BASE_CFLAGS += -DMACOS_X -fno-common -pipe
@@ -493,6 +533,16 @@
     TTYC_CFLAGS += -UUSE_CODEC_VORBIS
   endif
 
+  ifeq ($(USE_CIN_THEORA),1)
+    BASE_CFLAGS += -DUSE_CIN_THEORA
+    ifeq ($(USE_LOCAL_HEADERS),1)
+      BASE_CFLAGS += -I$(OGGDIR)
+    else
+      BASE_CFLAGS += $(THEORA_CFLAGS)
+    endif
+    TTYC_CFLAGS += -UUSE_CIN_THEORA
+  endif
+
   ifeq ($(USE_CURSES),1)
      LIBS += -lncurses
      BASE_CFLAGS += -DUSE_CURSES
@@ -524,6 +574,15 @@
     endif
   endif
 
+  ifeq ($(USE_CIN_THEORA),1)
+    ifeq ($(USE_LOCAL_HEADERS),1)
+      LIBTHEORA=$(B)/libtheoradec.a
+      LIBTHEORASRC=$(LIBSDIR)/macosx/libtheoradec.a
+    else
+      CLIENT_LIBS += $(THEORA_LIBS)
+    endif
+  endif
+
   OPTIMIZE += -falign-loops=16
 
   ifneq ($(HAVE_VM_COMPILED),true)
@@ -595,6 +654,16 @@
     TTYC_CFLAGS += -UUSE_CODEC_VORBIS
   endif
 
+  ifeq ($(USE_CIN_THEORA),1)
+    BASE_CFLAGS += -DUSE_CIN_THEORA
+    ifeq ($(USE_LOCAL_HEADERS),1)
+      BASE_CFLAGS += -I$(OGGDIR)
+    else
+      BASE_CFLAGS += $(THEORA_CFLAGS)
+    endif
+    TTYC_CFLAGS += -UUSE_CIN_THEORA
+  endif
+
   OPTIMIZE = -O3 -march=i586 -fno-omit-frame-pointer \
     -falign-loops=2 -funroll-loops -falign-jumps=2 -falign-functions=2 \
     -fstrength-reduce
@@ -645,6 +714,15 @@
     endif
   endif
 
+  ifeq ($(USE_CIN_THEORA),1)
+    ifeq ($(USE_LOCAL_HEADERS),1)
+      CLIENT_LIBS += \
+        $(LIBSDIR)/win32/libtheoradec.a
+    else
+      CLIENT_LIBS += $(THEORA_LIBS)
+    endif
+  endif
+
   ifeq ($(USE_CURSES),1)
      LIBS += $(LIBSDIR)/win32/pdcurses.a
      BASE_CFLAGS += -DUSE_CURSES -I$(PDCDIR)
@@ -686,7 +764,7 @@
 
 
   BASE_CFLAGS = -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes \
-    -DUSE_ICON $(shell sdl-config --cflags)
+    -DUSE_ICON $(SDL_CFLAGS)
 
   ifeq ($(USE_OPENAL),1)
     BASE_CFLAGS += -DUSE_OPENAL
@@ -736,7 +814,7 @@
   # don't need -ldl (FreeBSD)
   LIBS+=-lm
 
-  CLIENT_LIBS += $(shell sdl-config --libs) -lGL -lpthread
+  CLIENT_LIBS += $(SDL_LIBS) -lGL -lpthread
 
   ifeq ($(USE_OPENAL),1)
     ifneq ($(USE_OPENAL_DLOPEN),1)
@@ -761,7 +839,7 @@
 
 
   BASE_CFLAGS = -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes \
-    -DUSE_ICON $(shell sdl-config --cflags)
+    -DUSE_ICON $(SDL_CFLAGS)
 
   ifeq ($(USE_OPENAL),1)
     BASE_CFLAGS += -DUSE_OPENAL
@@ -794,7 +872,7 @@
 
   LIBS=-lm
 
-  CLIENT_LIBS = $(shell sdl-config --libs) -lGL -lpthread
+  CLIENT_LIBS = $(SDL_LIBS) -lGL -lpthread
 
   ifeq ($(USE_OPENAL),1)
     ifneq ($(USE_OPENAL_DLOPEN),1)
@@ -845,7 +923,7 @@
   MKDIR = mkdir -p
 
   BASE_CFLAGS=-Dstricmp=strcasecmp -Xcpluscomm -woff 1185 \
-    -I. $(shell sdl-config --cflags) -I$(ROOT)/usr/include -DNO_VM_COMPILED
+    -I. $(SDL_CFLAGS) -I$(ROOT)/usr/include -DNO_VM_COMPILED
   RELEASE_CFLAGS=$(BASE_CFLAGS) -O3
   DEBUG_CFLAGS=$(BASE_CFLAGS) -g
 
@@ -855,7 +933,7 @@
 
   LIBS=-ldl -lm -lgen
   # FIXME: The X libraries probably aren't necessary?
-  CLIENT_LIBS=-L/usr/X11/$(LIB) $(shell sdl-config --libs) -lGL \
+  CLIENT_LIBS=-L/usr/X11/$(LIB) $(SDL_LIBS) -lGL \
     -lX11 -lXext -lm
 
 else # ifeq IRIX
@@ -884,7 +962,7 @@
 
 
   BASE_CFLAGS = -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes \
-    -pipe -DUSE_ICON $(shell sdl-config --cflags)
+    -pipe -DUSE_ICON $(SDL_CFLAGS)
 
   OPTIMIZE = -O3 -funroll-loops
 
@@ -893,6 +971,7 @@
       -fstrength-reduce -falign-functions=2 \
       -mtune=ultrasparc3 -mv8plus -mno-faster-structs \
       -funroll-loops #-mv8plus
+    HAVE_VM_COMPILED=true
   else
   ifeq ($(ARCH),x86)
     OPTIMIZE = -O3 -march=i586 -fomit-frame-pointer \
@@ -919,7 +998,7 @@
 
   LIBS=-lsocket -lnsl -ldl -lm
 
-  CLIENT_LIBS +=$(shell sdl-config --libs) -lGL -lpthread
+  CLIENT_LIBS +=$(SDL_LIBS) -lGL -lpthread
 
 else # ifeq sunos
 
@@ -1123,6 +1202,18 @@
 		echo "    $$i"; \
 	done
 	@echo ""
+	@echo "  CLIENT_LDFLAGS:"
+	-@for i in $(CLIENT_LDFLAGS); \
+	do \
+		echo "    $$i"; \
+	done
+	@echo ""
+	@echo "  CLIENT_LIBS:"
+	-@for i in $(CLIENT_LIBS); \
+	do \
+		echo "    $$i"; \
+	done
+	@echo ""
 	@echo "  Output:"
 	-@for i in $(TARGETS); \
 	do \
@@ -1152,6 +1243,35 @@
 	@if [ ! -d $(B)/tools/lburg ];then $(MKDIR) $(B)/tools/lburg;fi
 
 #############################################################################
+# INSTALL
+#############################################################################
+
+install: release run-tremfusion.sh
+	@echo ""
+	@echo "Installing TremFusion in $(BUILDROOT)$(INSTALL_PREFIX):"
+	@if [ ! -d $(BUILDROOT)$(INSTALL_PREFIX) ];then $(MKDIR) -p $(BUILDROOT)$(INSTALL_PREFIX);fi
+	@if [ ! -d $(BUILDROOT)$(BINDIR) ];then $(MKDIR) -p $(BUILDROOT)$(BINDIR);fi
+	@if [ ! -d $(BUILDROOT)$(LIBDIR)/tremfusion ];then $(MKDIR) -p $(BUILDROOT)$(LIBDIR)/tremfusion;fi
+	@if [ ! -d $(BUILDROOT)$(DATADIR)/tremfusion ];then $(MKDIR) -p $(BUILDROOT)$(DATADIR)/tremfusion;fi
+ifeq ($(BUILD_CLIENT),1)
+	@$(Q)$(INSTALL) -vpm 755 $(BR)/tremulous.$(ARCH)$(BINEXT) $(BUILDROOT)$(LIBDIR)/tremfusion/tremfusion
+	@$(Q)$(INSTALL) -vpm 755 run-tremfusion.sh $(BUILDROOT)$(BINDIR)/tremfusion
+endif
+ifeq ($(BUILD_CLIENT_TTY),1)
+	@$(Q)$(INSTALL) -vpm 755 $(BR)/tremulous-tty.$(ARCH)$(BINEXT) $(BUILDROOT)$(LIBDIR)/tremfusion/tremfusion-tty
+	@$(Q)$(INSTALL) -vpm 755 run-tremfusion.sh $(BUILDROOT)$(BINDIR)/tremfusion-tty
+endif
+ifeq ($(BUILD_SERVER),1)
+	@$(Q)$(INSTALL) -vpm 755 $(BR)/tremded.$(ARCH)$(BINEXT) $(BUILDROOT)$(LIBDIR)/tremfusion/tremfusionded
+	@$(Q)$(INSTALL) -vpm 755 run-tremfusion.sh $(BUILDROOT)$(BINDIR)/tremfusionded
+endif
+
+run-tremfusion.sh:
+	@cp misc/run-tremfusion.sh.in ./run-tremfusion.sh
+	@sed -ie "s!@LIBDIR@!$(LIBDIR)!" run-tremfusion.sh
+	@sed -ie "s!@DATADIR@!$(DATADIR)!" run-tremfusion.sh
+
+#############################################################################
 # QVM BUILD TOOLS
 #############################################################################
 
@@ -1288,6 +1408,7 @@
 #############################################################################
 
 Q3OBJ_ = \
+  $(B)/client/cin_ogm.o \
   $(B)/client/cl_cgame.o \
   $(B)/client/cl_cin.o \
   $(B)/client/cl_console.o \
@@ -1582,6 +1703,14 @@
 endif
 endif
 
+ifneq ($(strip $(LIBTHEORA)),)
+ifneq ($(strip $(LIBTHEORASRC)),)
+$(LIBTHEORA) : $(LIBTHEORASRC)
+	cp $< $@
+	ranlib $@
+endif
+endif
+
 ifneq ($(strip $(LIBFREETYPE)),)   
 ifneq ($(strip $(LIBFREETYPESRC)),)
 $(LIBFREETYPE) : $(LIBFREETYPESRC)
diff -r 91f0a3d9f930 -r 4b5fc919fd59 make-macosx-ub.sh
--- a/make-macosx-ub.sh	Sat Jun 06 02:45:31 2009 +0800
+++ b/make-macosx-ub.sh	Mon Jul 06 04:07:05 2009 +0800
@@ -1,9 +1,9 @@
 #!/bin/sh
-APPBUNDLE=Tremulous.app
-BINARY=Tremulous.ub
-DEDBIN=Tremded.ub
-TTYBIN=Tremulous-tty.ub
-PKGINFO=APPLTREM
+APPBUNDLE=Tremfusion.app
+BINARY=Tremfusion.ub
+DEDBIN=Tremfusionded.ub
+TTYBIN=Tremfusion-tty.ub
+PKGINFO=APPLTREMFUSION
 ICNS=misc/Tremfusion.icns
 DESTDIR=build/release-darwin-ub
 BASEDIR=base
@@ -154,11 +154,11 @@
 		<key>CFBundleIconFile</key>
 		<string>Tremfusion.icns</string>
 		<key>CFBundleIdentifier</key>
-		<string>net.tremulous</string>
+		<string>net.tremfusion</string>
 		<key>CFBundleInfoDictionaryVersion</key>
 		<string>6.0</string>
 		<key>CFBundleName</key>
-		<string>Tremulous</string>
+		<string>Tremfusion</string>
 		<key>CFBundlePackageType</key>
 		<string>APPL</string>
 		<key>CFBundleShortVersionString</key>
diff -r 91f0a3d9f930 -r 4b5fc919fd59 misc/lakitu7-qvm-svdemo.patch
--- a/misc/lakitu7-qvm-svdemo.patch	Sat Jun 06 02:45:31 2009 +0800
+++ b/misc/lakitu7-qvm-svdemo.patch	Mon Jul 06 04:07:05 2009 +0800
@@ -1,5 +1,5 @@
 diff --git a/src/game/g_active.c b/src/game/g_active.c
-index 839299a..87deb53 100644
+index fe7ebd4..ef4fb34 100644
 --- a/src/game/g_active.c
 +++ b/src/game/g_active.c
 @@ -404,7 +404,7 @@ void SpectatorThink( gentity_t *ent, usercmd_t *ucmd )
@@ -11,7 +11,7 @@
          doPmove = qfalse;
      }
    }
-@@ -1847,7 +1847,7 @@ void SpectatorClientEndFrame( gentity_t *ent )
+@@ -1864,7 +1864,7 @@ void SpectatorClientEndFrame( gentity_t *ent )
      {
        cl = &level.clients[ clientNum ];
  
@@ -21,10 +21,10 @@
   
      if( cl -> sess.spectatorState != SPECTATOR_FOLLOW ) 
 diff --git a/src/game/g_admin.c b/src/game/g_admin.c
-index 4dcad64..a562f83 100644
+index 6c003b3..688a297 100644
 --- a/src/game/g_admin.c
 +++ b/src/game/g_admin.c
-@@ -2474,6 +2474,11 @@ qboolean G_admin_putteam( gentity_t *ent, int skiparg )
+@@ -2484,6 +2484,11 @@ qboolean G_admin_putteam( gentity_t *ent, int skiparg )
    }
    if( vic->client->pers.teamSelection == teamnum )
      return qfalse;
@@ -37,10 +37,10 @@
  
    AP( va( "print \"^3!putteam: ^7%s^7 put %s^7 on to the %s team\n\"",
 diff --git a/src/game/g_client.c b/src/game/g_client.c
-index 0799375..9ea17bb 100644
+index 6a64b7d..ae0a09f 100644
 --- a/src/game/g_client.c
 +++ b/src/game/g_client.c
-@@ -1248,6 +1248,9 @@ void ClientUserinfoChanged( int clientNum )
+@@ -1262,6 +1262,9 @@ void ClientUserinfoChanged( int clientNum, qboolean forceName )
  
    trap_SetConfigstring( CS_PLAYERS + clientNum, userinfo );
  
@@ -50,7 +50,7 @@
    /*G_LogPrintf( "ClientUserinfoChanged: %i %s\n", clientNum, userinfo );*/
  }
  
-@@ -1417,6 +1420,7 @@ void ClientBegin( int clientNum )
+@@ -1431,6 +1434,7 @@ void ClientBegin( int clientNum )
  {
    gentity_t *ent;
    gclient_t *client;
@@ -58,7 +58,7 @@
    int       flags;
  
    ent = g_entities + clientNum;
-@@ -1460,6 +1464,10 @@ void ClientBegin( int clientNum )
+@@ -1474,6 +1478,10 @@ void ClientBegin( int clientNum )
  
    G_LogPrintf( "ClientBegin: %i\n", clientNum );
  
@@ -69,7 +69,7 @@
    if( g_clientUpgradeNotice.integer )
    {
      if( !Q_stricmp( ent->client->pers.guid, "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" ) )
-@@ -1866,5 +1874,7 @@ void ClientDisconnect( int clientNum )
+@@ -1880,5 +1888,7 @@ void ClientDisconnect( int clientNum )
  
    trap_SetConfigstring( CS_PLAYERS + clientNum, "");
  
@@ -78,12 +78,12 @@
    CalculateRanks( );
  }
 diff --git a/src/game/g_cmds.c b/src/game/g_cmds.c
-index 858c1c9..0b0f0eb 100644
+index 765986d..517f93c 100644
 --- a/src/game/g_cmds.c
 +++ b/src/game/g_cmds.c
 @@ -797,6 +797,12 @@ void Cmd_Team_f( gentity_t *ent )
    
-   if( !Q_stricmp( s, "spectate" ) )
+   if( !Q_stricmpn( s, "spec", 4 ) )
      team = PTE_NONE;
 +  else if( level.demoState == DS_PLAYBACK )
 +  {
@@ -126,7 +126,7 @@
        break;
        
        case SAY_ADMINS:
-@@ -3698,11 +3708,13 @@ qboolean G_FollowNewClient( gentity_t *ent, int dir )
+@@ -3748,11 +3758,13 @@ qboolean G_FollowNewClient( gentity_t *ent, int dir )
        continue;
  
      // can only follow connected clients
@@ -143,10 +143,10 @@
       
        // can only follow teammates when dead and on a team
 diff --git a/src/game/g_local.h b/src/game/g_local.h
-index 418a89e..f631ccf 100644
+index 1eacea6..b99a232 100644
 --- a/src/game/g_local.h
 +++ b/src/game/g_local.h
-@@ -408,6 +408,7 @@ typedef struct
+@@ -410,6 +410,7 @@ typedef struct
    char                guid[ 33 ];
    char                ip[ 16 ];
    qboolean            muted;
@@ -154,7 +154,7 @@
    qboolean            denyBuild;
    int                 adminLevel;
    char                adminName[ MAX_NETNAME ];
-@@ -561,6 +562,15 @@ typedef struct damageRegion_s
+@@ -563,6 +564,15 @@ typedef struct damageRegion_s
    qboolean  crouch;
  } damageRegion_t;
  
@@ -170,7 +170,7 @@
  #define MAX_ARMOUR_TEXT    8192
  #define MAX_ARMOUR_REGIONS 16
  
-@@ -758,7 +768,9 @@ typedef struct
+@@ -760,7 +770,9 @@ typedef struct
    int               lastTeamUnbalancedTime;
    int               numTeamWarnings;  
    int               lastMsgTime;
@@ -181,7 +181,7 @@
    statsCounters_level alienStatsCounters;
    statsCounters_level humanStatsCounters;
  } level_locals_t;
-@@ -1080,6 +1092,7 @@ void QDECL G_Error( const char *fmt, ... );
+@@ -1082,6 +1094,7 @@ void QDECL G_Error( const char *fmt, ... );
  void CheckVote( void );
  void CheckTeamVote( int teamnum );
  void LogExit( const char *string );
@@ -189,13 +189,13 @@
  int  G_TimeTilSuddenDeath( void );
  void CheckMsgTimer( void );
  qboolean G_Flood_Limited( gentity_t *ent );
-@@ -1411,3 +1424,4 @@ qboolean  trap_GetEntityToken( char *buffer, int bufferSize );
+@@ -1414,3 +1427,4 @@ qboolean  trap_GetEntityToken( char *buffer, int bufferSize );
  
  void      trap_SnapVector( float *v );
  void      trap_SendGameStat( const char *data );
 +void      trap_DemoCommand( demoCommand_t cmd, const char *string );
 diff --git a/src/game/g_main.c b/src/game/g_main.c
-index 4b4b447..d92844f 100644
+index f07e30d..95b6212 100644
 --- a/src/game/g_main.c
 +++ b/src/game/g_main.c
 @@ -62,6 +62,7 @@ vmCvar_t  g_dedicated;
@@ -206,7 +206,7 @@
  vmCvar_t  g_knockback;
  vmCvar_t  g_quadfactor;
  vmCvar_t  g_inactivity;
-@@ -188,6 +189,9 @@ static cvarTable_t   gameCvarTable[ ] =
+@@ -189,6 +190,9 @@ static cvarTable_t   gameCvarTable[ ] =
    // don't override the cheat state set by the system
    { &g_cheats, "sv_cheats", "", 0, 0, qfalse },
  
@@ -216,7 +216,7 @@
    // noset vars
    { NULL, "gamename", GAME_VERSION , CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
    { NULL, "gamedate", __DATE__ , CVAR_ROM, 0, qfalse  },
-@@ -357,6 +361,9 @@ void G_InitGame( int levelTime, int randomSeed, int restart );
+@@ -359,6 +363,9 @@ void G_InitGame( int levelTime, int randomSeed, int restart );
  void G_RunFrame( int levelTime );
  void G_ShutdownGame( int restart );
  void CheckExitRules( void );
@@ -226,7 +226,7 @@
  
  void G_CountSpawns( void );
  void G_CalculateBuildPoints( void );
-@@ -412,6 +419,22 @@ intptr_t vmMain( int command, int arg0, int arg1, int arg2, int arg3, int arg4,
+@@ -414,6 +421,22 @@ intptr_t vmMain( int command, int arg0, int arg1, int arg2, int arg3, int arg4,
  
      case GAME_CONSOLE_COMMAND:
        return ConsoleCommand( );
@@ -249,7 +249,7 @@
    }
  
    return -1;
-@@ -612,6 +635,8 @@ G_InitGame
+@@ -614,6 +637,8 @@ G_InitGame
  void G_InitGame( int levelTime, int randomSeed, int restart )
  {
    int i;
@@ -258,7 +258,7 @@
  
    srand( randomSeed );
  
-@@ -631,6 +656,11 @@ void G_InitGame( int levelTime, int randomSeed, int restart )
+@@ -633,6 +658,11 @@ void G_InitGame( int levelTime, int randomSeed, int restart )
    level.startTime = levelTime;
    level.alienStage2Time = level.alienStage3Time =
      level.humanStage2Time = level.humanStage3Time = level.startTime;
@@ -270,7 +270,7 @@
  
    level.snd_fry = G_SoundIndex( "sound/misc/fry.wav" ); // FIXME standing in lava / slime
  
-@@ -781,6 +811,8 @@ G_ShutdownGame
+@@ -789,6 +819,8 @@ G_ShutdownGame
  */
  void G_ShutdownGame( int restart )
  {
@@ -279,7 +279,7 @@
    // in case of a map_restart
    G_ClearVotes( );
  
-@@ -802,6 +834,11 @@ void G_ShutdownGame( int restart )
+@@ -810,6 +842,11 @@ void G_ShutdownGame( int restart )
    level.restarted = qfalse;
    level.surrenderTeam = PTE_NONE;
    trap_SetConfigstring( CS_WINNER, "" );
@@ -291,7 +291,7 @@
  }
  
  
-@@ -1366,6 +1403,8 @@ void G_CalculateStages( void )
+@@ -1379,6 +1416,8 @@ void G_CalculateStages( void )
    float         humanPlayerCountMod     = level.averageNumHumanClients / PLAYER_COUNT_MOD;
    static int    lastAlienStageModCount  = 1;
    static int    lastHumanStageModCount  = 1;
@@ -300,7 +300,7 @@
  
    if( alienPlayerCountMod < 0.1f )
      alienPlayerCountMod = 0.1f;
-@@ -1435,6 +1474,15 @@ void G_CalculateStages( void )
+@@ -1448,6 +1487,15 @@ void G_CalculateStages( void )
  
      lastHumanStageModCount = g_humanStage.modificationCount;
    }
@@ -316,7 +316,7 @@
  }
  
  /*
-@@ -1502,13 +1550,15 @@ void CalculateRanks( void )
+@@ -1515,13 +1563,15 @@ void CalculateRanks( void )
    for( i = 0; i < level.maxclients; i++ )
    {
      P[ i ] = '-';
@@ -334,7 +334,7 @@
          continue;
  
        level.numVotingClients++;
-@@ -1559,6 +1609,84 @@ void CalculateRanks( void )
+@@ -1572,6 +1622,84 @@ void CalculateRanks( void )
      SendScoreboardMessageToAllClients( );
  }
  
@@ -419,7 +419,7 @@
  
  /*
  ========================================================================
-@@ -1755,7 +1883,6 @@ void ExitLevel( void )
+@@ -1768,7 +1896,6 @@ void ExitLevel( void )
      if( level.clients[ i ].pers.connected == CON_CONNECTED )
        level.clients[ i ].pers.connected = CON_CONNECTING;
    }
@@ -427,7 +427,7 @@
  }
  /*
  =================
-@@ -2172,6 +2299,10 @@ can see the last frag.
+@@ -2185,6 +2312,10 @@ can see the last frag.
  */
  void CheckExitRules( void )
  {
@@ -438,7 +438,7 @@
    // if at the intermission, wait for all non-bots to
    // signal ready, then go to next level
    if( level.intermissiontime )
-@@ -2514,6 +2645,54 @@ void CheckCvars( void )
+@@ -2536,6 +2667,54 @@ void CheckCvars( void )
  }
  
  /*
@@ -493,7 +493,7 @@
  =============
  G_RunThink
  
-@@ -2606,13 +2785,16 @@ void G_RunFrame( int levelTime )
+@@ -2628,13 +2807,16 @@ void G_RunFrame( int levelTime )
    // get any cvar changes
    G_UpdateCvars( );
  
@@ -595,16 +595,3 @@
  }
  
  
-diff --git a/src/tools/asm/Makefile b/src/tools/asm/Makefile
-index 52f1060..a788386 100644
---- a/src/tools/asm/Makefile
-+++ b/src/tools/asm/Makefile
-@@ -13,7 +13,7 @@ else
- endif
- 
- CC=gcc
--Q3ASM_CFLAGS=-O2 -Wall -Werror -fno-strict-aliasing
-+Q3ASM_CFLAGS=-O2 -Wall -fno-strict-aliasing
- 
- ifeq ($(PLATFORM),darwin)
-   LCC_CFLAGS += -DMACOS_X=1
diff -r 91f0a3d9f930 -r 4b5fc919fd59 misc/run-tremfusion.sh.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/misc/run-tremfusion.sh.in	Mon Jul 06 04:07:05 2009 +0800
@@ -0,0 +1,34 @@
+#!/bin/bash
+
+LIBDIR=@LIBDIR@
+DATADIR=@DATADIR@
+
+BINARY=$LIBDIR/tremfusion/$(basename $0)
+BASE_PATH="$DATADIR/tremulous"
+EXTRA_PATH="$DATADIR/tremfusion"
+QUIET=0
+
+# TremFusion binaries don't understand "regular" command line parameters. Let's
+# catch them here, to avoid accidently launching the binary.
+
+while [ "$1" != "" ]; do {
+	if [ "$1" = "+set" -o "$1" = "+connect" ]; then
+		break;
+	fi
+	case "$1" in
+		-q|--quiet)
+			QUIET=1
+			;;
+	esac
+	shift
+}; done
+
+# Ready to rumble!
+
+if [ ${QUIET} -eq 1 ]; then
+	exec ${BINARY} +set fs_basepath ${BASE_PATH} +set fs_extrapath ${EXTRA_PATH} $* >/dev/null 2>&1
+else
+	exec ${BINARY} +set fs_basepath ${BASE_PATH} +set fs_extrapath ${EXTRA_PATH} $*
+fi
+
+exit $?
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/client/cin_ogm.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/client/cin_ogm.c	Mon Jul 06 04:07:05 2009 +0800
@@ -0,0 +1,990 @@
+/*
+===========================================================================
+Copyright (C) 2008 Stefan Langer <raute@users.sourceforge.net>
+
+This file is part of Tremfusion.
+
+Tremfusion is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Tremfusion is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Tremfusion; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+
+/*
+
+  This is a "ogm"-decoder to use a "better"(smaller files,higher resolutions) Cinematic-Format than roq
+
+  In this code "ogm" is only: ogg wrapper, vorbis audio, xvid video (or theora video)
+  (ogm(Ogg Media) in general is ogg wrapper with all kind of audio/video/subtitle/...)
+
+... infos used for this src:
+xvid:
+ * examples/xvid_decraw.c
+ * xvid.h
+ogg/vobis:
+ * decoder_example.c (libvorbis src)
+ * libogg Documentation ( http://www.xiph.org/ogg/doc/libogg/ )
+ * VLC ogg demux ( http://trac.videolan.org/vlc/browser/trunk/modules/demux/ogg.c )
+theora:
+ * theora doxygen docs (1.0beta1)
+*/
+
+#if defined(USE_CODEC_VORBIS) && (defined(USE_CIN_XVID) || defined(USE_CIN_THEORA))
+
+#include <ogg/ogg.h>
+#include <vorbis/codec.h>
+
+#ifdef USE_CIN_XVID
+#include <xvid.h>
+#endif
+#ifdef USE_CIN_THEORA
+#include <theora/theora.h>
+#endif
+
+#include "client.h"
+#include "snd_local.h"
+
+#define OGG_BUFFER_SIZE	8*1024	//4096
+
+typedef struct
+{
+	fileHandle_t    ogmFile;
+
+	ogg_sync_state  oy;			/* sync and verify incoming physical bitstream */
+	//ogg_stream_state os; /* take physical pages, weld into a logical stream of packets */
+	ogg_stream_state os_audio;
+	ogg_stream_state os_video;
+
+	vorbis_dsp_state vd;		/* central working state for the packet->PCM decoder */
+	vorbis_info     vi;			/* struct that stores all the static vorbis bitstream settings */
+	vorbis_comment  vc;			/* struct that stores all the bitstream user comments */
+
+	qboolean        videoStreamIsXvid;	//FIXME: atm there isn't realy a check for this (all "video" streams are handelt as xvid, because xvid support more than one "subtype")
+#ifdef USE_CIN_XVID
+	xvid_dec_stats_t xvid_dec_stats;
+	void           *xvid_dec_handle;
+#endif
+	qboolean        videoStreamIsTheora;
+#ifdef USE_CIN_THEORA
+	theora_info     th_info;	// dump_video.c(example decoder): ti
+	theora_comment  th_comment;	// dump_video.c(example decoder): tc
+	theora_state    th_state;	// dump_video.c(example decoder): td
+
+	yuv_buffer      th_yuvbuffer;
+#endif
+
+	unsigned char  *outputBuffer;
+	int             outputWidht;
+	int             outputHeight;
+	int             outputBufferSize;	// in Pixel (so "real Bytesize" = outputBufferSize*4)
+	int             VFrameCount;	// output video-stream
+	ogg_int64_t     Vtime_unit;
+	int             currentTime;	// input from Run-function
+} cin_ogm_t;
+
+static cin_ogm_t g_ogm;
+
+int             nextNeededVFrame(void);
+
+
+/* ####################### #######################
+
+  XVID
+
+*/
+#ifdef USE_CIN_XVID
+
+#define BPP 4
+
+static int init_xvid()
+{
+	int             ret;
+
+	xvid_gbl_init_t xvid_gbl_init;
+	xvid_dec_create_t xvid_dec_create;
+
+	/* Reset the structure with zeros */
+	memset(&xvid_gbl_init, 0, sizeof(xvid_gbl_init_t));
+	memset(&xvid_dec_create, 0, sizeof(xvid_dec_create_t));
+
+	/* Version */
+	xvid_gbl_init.version = XVID_VERSION;
+
+	xvid_gbl_init.cpu_flags = 0;
+	xvid_gbl_init.debug = 0;
+
+	xvid_global(NULL, 0, &xvid_gbl_init, NULL);
+
+	/* Version */
+	xvid_dec_create.version = XVID_VERSION;
+
+	/*
+	 * Image dimensions -- set to 0, xvidcore will resize when ever it is
+	 * needed
+	 */
+	xvid_dec_create.width = 0;
+	xvid_dec_create.height = 0;
+
+	ret = xvid_decore(NULL, XVID_DEC_CREATE, &xvid_dec_create, NULL);
+
+	g_ogm.xvid_dec_handle = xvid_dec_create.handle;
+
+	return (ret);
+}
+
+static int dec_xvid(unsigned char *input, int input_size)
+{
+	int             ret;
+
+	xvid_dec_frame_t xvid_dec_frame;
+
+	/* Reset all structures */
+	memset(&xvid_dec_frame, 0, sizeof(xvid_dec_frame_t));
+	memset(&g_ogm.xvid_dec_stats, 0, sizeof(xvid_dec_stats_t));
+
+	/* Set version */
+	xvid_dec_frame.version = XVID_VERSION;
+	g_ogm.xvid_dec_stats.version = XVID_VERSION;
+
+	/* No general flags to set */
+	xvid_dec_frame.general = XVID_LOWDELAY;	//0;
+
+	/* Input stream */
+	xvid_dec_frame.bitstream = input;
+	xvid_dec_frame.length = input_size;
+
+	/* Output frame structure */
+	xvid_dec_frame.output.plane[0] = g_ogm.outputBuffer;
+	xvid_dec_frame.output.stride[0] = g_ogm.outputWidht * BPP;
+	if(g_ogm.outputBuffer == NULL)
+		xvid_dec_frame.output.csp = XVID_CSP_NULL;
+	else
+		xvid_dec_frame.output.csp = XVID_CSP_RGBA;	// example was with XVID_CSP_I420
+
+	ret = xvid_decore(g_ogm.xvid_dec_handle, XVID_DEC_DECODE, &xvid_dec_frame, &g_ogm.xvid_dec_stats);
+
+	return (ret);
+}
+
+static int shutdown_xvid()
+{
+	int             ret = 0;
+
+	if(g_ogm.xvid_dec_handle)
+		ret = xvid_decore(g_ogm.xvid_dec_handle, XVID_DEC_DESTROY, NULL, NULL);
+
+	return (ret);
+}
+#endif
+
+/* ####################### #######################
+
+  OGG/OGM
+  ... also calls to vorbis/theora-libs
+
+*/
+
+/*
+  loadBlockToSync
+
+  return:
+  !0 -> no data transferred
+*/
+static int loadBlockToSync(void)
+{
+	int             r = -1;
+	char           *buffer;
+	int             bytes;
+
+	if(g_ogm.ogmFile)
+	{
+		buffer = ogg_sync_buffer(&g_ogm.oy, OGG_BUFFER_SIZE);
+		bytes = FS_Read(buffer, OGG_BUFFER_SIZE, g_ogm.ogmFile);
+		ogg_sync_wrote(&g_ogm.oy, bytes);
+
+		r = (bytes == 0);
+	}
+
+	return r;
+}
+
+/*
+  loadPagesToStreams
+
+  return:
+  !0 -> no data transferred (or not for all Streams)
+*/
+static int loadPagesToStreams(void)
+{
+	int             r = -1;
+	int             AudioPages = 0;
+	int             VideoPages = 0;
+	ogg_stream_state *osptr = NULL;
+	ogg_page        og;
+
+	while(!AudioPages || !VideoPages)
+	{
+		if(ogg_sync_pageout(&g_ogm.oy, &og) != 1)
+			break;
+
+		if(g_ogm.os_audio.serialno == ogg_page_serialno(&og))
+		{
+			osptr = &g_ogm.os_audio;
+			++AudioPages;
+		}
+		if(g_ogm.os_video.serialno == ogg_page_serialno(&og))
+		{
+			osptr = &g_ogm.os_video;
+			++VideoPages;
+		}
+
+		if(osptr != NULL)
+		{
+			ogg_stream_pagein(osptr, &og);
+		}
+	}
+
+	if(AudioPages && VideoPages)
+		r = 0;
+
+	return r;
+}
+
+#define SIZEOF_RAWBUFF 4*1024
+static byte     rawBuffer[SIZEOF_RAWBUFF];
+
+#define MIN_AUDIO_PRELOAD 400	// in ms
+#define MAX_AUDIO_PRELOAD 500	// in ms
+
+
+/*
+
+  return: audio wants more packets
+*/
+static qboolean loadAudio(void)
+{
+	qboolean        anyDataTransferred = qtrue;
+	float         **pcm;
+	float          *right, *left;
+	int             samples, samplesNeeded;
+	int             i;
+	short          *ptr;
+	ogg_packet      op;
+	vorbis_block    vb;
+
+	memset(&op, 0, sizeof(op));
+	memset(&vb, 0, sizeof(vb));
+	vorbis_block_init(&g_ogm.vd, &vb);
+
+	while(anyDataTransferred && g_ogm.currentTime + MAX_AUDIO_PRELOAD > (int)(g_ogm.vd.granulepos * 1000 / g_ogm.vi.rate))
+	{
+		anyDataTransferred = qfalse;
+
+		if((samples = vorbis_synthesis_pcmout(&g_ogm.vd, &pcm)) > 0)
+		{
+			// vorbis -> raw
+			ptr = (short *)rawBuffer;
+			samplesNeeded = (SIZEOF_RAWBUFF) / (2 * 2);	// (width*channel)
+			if(samples < samplesNeeded)
+				samplesNeeded = samples;
+
+			left = pcm[0];
+			right = (g_ogm.vi.channels > 1) ? pcm[1] : pcm[0];
+			for(i = 0; i < samplesNeeded; ++i)
+			{
+				ptr[0] = (left[i] >= -1.0f &&
+						  left[i] <= 1.0f) ? left[i] * 32767.f : 32767 * ((left[i] > 0.0f) - (left[i] < 0.0f));
+				ptr[1] = (right[i] >= -1.0f &&
+						  right[i] <= 1.0f) ? right[i] * 32767.f : 32767 * ((right[i] > 0.0f) - (right[i] < 0.0f));
+				ptr += 2;		//numChans;
+			}
+
+			if(i > 0)
+			{
+				// tell libvorbis how many samples we actually consumed
+				vorbis_synthesis_read(&g_ogm.vd, i);
+
+//              S_RawSamples( ssize, 22050, 2, 2, (byte *)sbuf, 1.0f );
+				S_RawSamples(0, i, g_ogm.vi.rate, 2, 2, rawBuffer, 1.0f);
+
+				anyDataTransferred = qtrue;
+			}
+		}
+
+		if(!anyDataTransferred)
+		{
+			// op -> vorbis
+			if(ogg_stream_packetout(&g_ogm.os_audio, &op))
+			{
+				if(vorbis_synthesis(&vb, &op) == 0)
+					vorbis_synthesis_blockin(&g_ogm.vd, &vb);
+				anyDataTransferred = qtrue;
+			}
+		}
+	}
+
+	vorbis_block_clear(&vb);
+
+	if(g_ogm.currentTime + MIN_AUDIO_PRELOAD > (int)(g_ogm.vd.granulepos * 1000 / g_ogm.vi.rate))
+		return qtrue;
+	else
+		return qfalse;
+}
+
+/*
+
+  return:	1	-> loaded a new Frame ( g_ogm.outputBuffer points to the actual frame )
+			0	-> no new Frame
+			<0	-> error
+*/
+#ifdef USE_CIN_XVID
+static int loadVideoFrameXvid()
+{
+	int             r = 0;
+	ogg_packet      op;
+	int             used_bytes = 0;
+
+	memset(&op, 0, sizeof(op));
+
+	while(!r && (ogg_stream_packetout(&g_ogm.os_video, &op)))
+	{
+		used_bytes = dec_xvid(op.packet, op.bytes);
+		if(g_ogm.xvid_dec_stats.type == XVID_TYPE_VOL)
+		{
+			if(g_ogm.outputWidht != g_ogm.xvid_dec_stats.data.vol.width ||
+			   g_ogm.outputHeight != g_ogm.xvid_dec_stats.data.vol.height)
+			{
+				g_ogm.outputWidht = g_ogm.xvid_dec_stats.data.vol.width;
+				g_ogm.outputHeight = g_ogm.xvid_dec_stats.data.vol.height;
+				Com_DPrintf("[XVID]new resolution %dx%d\n", g_ogm.outputWidht, g_ogm.outputHeight);
+			}
+
+			if(g_ogm.outputBufferSize < g_ogm.xvid_dec_stats.data.vol.width * g_ogm.xvid_dec_stats.data.vol.height)
+			{
+
+				g_ogm.outputBufferSize = g_ogm.xvid_dec_stats.data.vol.width * g_ogm.xvid_dec_stats.data.vol.height;
+
+				/* Free old output buffer */
+				if(g_ogm.outputBuffer)
+					free(g_ogm.outputBuffer);
+
+				/* Allocate the new buffer */
+				g_ogm.outputBuffer = (unsigned char *)malloc(g_ogm.outputBufferSize * 4);	//FIXME? should the 4 stay for BPP?
+				if(g_ogm.outputBuffer == NULL)
+				{
+					g_ogm.outputBufferSize = 0;
+					r = -2;
+					break;
+				}
+			}
+
+			// use the rest of this packet
+			used_bytes += dec_xvid(op.packet + used_bytes, op.bytes - used_bytes);
+		}
+
+		// we got a real output frame ...
+		if(g_ogm.xvid_dec_stats.type > 0)
+		{
+			r = 1;
+
+			++g_ogm.VFrameCount;
+//          Com_Printf("frame infos: %d %d %d\n", xvid_dec_stats.data.vop.general, xvid_dec_stats.data.vop.time_base, xvid_dec_stats.data.vop.time_increment);
+//          Com_Printf("frame info time: %d (Frame# %d, %d)\n", xvid_dec_stats.data.vop.time_base, VFrameCount, (int)(VFrameCount*Vtime_unit/10000000));
+		}
+
+//      if((op.bytes-used_bytes)>0)
+//          Com_Printf("unused: %d(firstChar: %X)\n",(op.bytes-used_bytes),(int)(op.packet[used_bytes]));
+	}
+
+	return r;
+}
+#endif
+
+/*
+
+  return:	1	-> loaded a new Frame ( g_ogm.outputBuffer points to the actual frame )
+			0	-> no new Frame
+			<0	-> error
+*/
+#ifdef USE_CIN_THEORA
+/*
+how many >> are needed to make y==x (shifting y>>i)
+return: -1	-> no match
+		>=0	-> number of shifts
+*/
+static int findSizeShift(int x, int y)
+{
+	int             i;
+
+	for(i = 0; (y >> i); ++i)
+		if(x == (y >> i))
+			return i;
+
+	return -1;
+}
+
+static int loadVideoFrameTheora(void)
+{
+	int             r = 0;
+	ogg_packet      op;
+
+	memset(&op, 0, sizeof(op));
+
+	while(!r && (ogg_stream_packetout(&g_ogm.os_video, &op)))
+	{
+		ogg_int64_t     th_frame;
+
+		theora_decode_packetin(&g_ogm.th_state, &op);
+
+		th_frame = theora_granule_frame(&g_ogm.th_state, g_ogm.th_state.granulepos);
+
+		if((g_ogm.VFrameCount < th_frame && th_frame >= nextNeededVFrame()) || !g_ogm.outputBuffer)
+		{
+//          int i,j;
+			int             yWShift, uvWShift;
+			int             yHShift, uvHShift;
+
+			if(theora_decode_YUVout(&g_ogm.th_state, &g_ogm.th_yuvbuffer))
+				continue;
+
+			if(g_ogm.outputWidht != g_ogm.th_info.width || g_ogm.outputHeight != g_ogm.th_info.height)
+			{
+				g_ogm.outputWidht = g_ogm.th_info.width;
+				g_ogm.outputHeight = g_ogm.th_info.height;
+				Com_DPrintf("[Theora(ogg)]new resolution %dx%d\n", g_ogm.outputWidht, g_ogm.outputHeight);
+			}
+
+			if(g_ogm.outputBufferSize < g_ogm.th_info.width * g_ogm.th_info.height)
+			{
+
+				g_ogm.outputBufferSize = g_ogm.th_info.width * g_ogm.th_info.height;
+
+				/* Free old output buffer */
+				if(g_ogm.outputBuffer)
+					free(g_ogm.outputBuffer);
+
+				/* Allocate the new buffer */
+				g_ogm.outputBuffer = (unsigned char *)malloc(g_ogm.outputBufferSize * 4);
+				if(g_ogm.outputBuffer == NULL)
+				{
+					g_ogm.outputBufferSize = 0;
+					r = -2;
+					break;
+				}
+			}
+
+			yWShift = findSizeShift(g_ogm.th_yuvbuffer.y_width, g_ogm.th_info.width);
+			uvWShift = findSizeShift(g_ogm.th_yuvbuffer.uv_width, g_ogm.th_info.width);
+			yHShift = findSizeShift(g_ogm.th_yuvbuffer.y_height, g_ogm.th_info.height);
+			uvHShift = findSizeShift(g_ogm.th_yuvbuffer.uv_height, g_ogm.th_info.height);
+
+			if(yWShift < 0 || uvWShift < 0 || yHShift < 0 || uvHShift < 0)
+			{
+				Com_Printf("[Theora] unexpected resolution in a yuv-Frame\n");
+				r = -1;
+			}
+			else
+			{
+
+				Frame_yuv_to_rgb24(g_ogm.th_yuvbuffer.y, g_ogm.th_yuvbuffer.u, g_ogm.th_yuvbuffer.v,
+								   g_ogm.th_info.width, g_ogm.th_info.height, g_ogm.th_yuvbuffer.y_stride,
+								   g_ogm.th_yuvbuffer.uv_stride, yWShift, uvWShift, yHShift, uvHShift,
+								   (unsigned int *)g_ogm.outputBuffer);
+
+/*				unsigned char*	pixelPtr = g_ogm.outputBuffer;
+				unsigned int*	pixPtr;
+				pixPtr = (unsigned int*)g_ogm.outputBuffer;
+
+				//TODO: use one yuv->rgb funktion for the hole frame (the big amout of stack movement(yuv->rgb calls) couldn't be good ;) )
+				for(j=0;j<g_ogm.th_info.height;++j) {
+					for(i=0;i<g_ogm.th_info.width;++i) {
+#if 1
+						// simple grayscale-output ^^
+						pixelPtr[0] =
+							pixelPtr[1] =
+							pixelPtr[2] = g_ogm.th_yuvbuffer.y[i+j*g_ogm.th_yuvbuffer.y_stride];
+						pixelPtr+=4;
+
+#else
+						// using RoQ yuv->rgb code
+						*pixPtr++ = yuv_to_rgb24( g_ogm.th_yuvbuffer.y[(i>>yWShift)+(j>>yHShift)*g_ogm.th_yuvbuffer.y_stride],
+												g_ogm.th_yuvbuffer.u[(i>>uvWShift)+(j>>uvHShift)*g_ogm.th_yuvbuffer.uv_stride],
+												g_ogm.th_yuvbuffer.v[(i>>uvWShift)+(j>>uvHShift)*g_ogm.th_yuvbuffer.uv_stride]);
+#endif
+					}
+				}
+*/
+
+				r = 1;
+				g_ogm.VFrameCount = th_frame;
+			}
+		}
+
+
+	}
+
+	return r;
+}
+#endif
+
+
+/*
+
+  return:	1	-> loaded a new Frame ( g_ogm.outputBuffer points to the actual frame )
+			0	-> no new Frame
+			<0	-> error
+*/
+static int loadVideoFrame(void)
+{
+#ifdef USE_CIN_XVID
+	if(g_ogm.videoStreamIsXvid)
+		return loadVideoFrameXvid();
+#endif
+#ifdef USE_CIN_THEORA
+	if(g_ogm.videoStreamIsTheora)
+		return loadVideoFrameTheora();
+#endif
+
+	// if we come to this point, there will be no codec that use the stream content ...
+	if(g_ogm.os_video.serialno)
+	{
+		ogg_packet      op;
+
+		while(ogg_stream_packetout(&g_ogm.os_video, &op));
+	}
+
+	return 1;
+}
+
+/*
+
+  return: qtrue => noDataTransferred
+*/
+static qboolean loadFrame(void)
+{
+	qboolean        anyDataTransferred = qtrue;
+	qboolean        needVOutputData = qtrue;
+
+//  qboolean audioSDone = qfalse;
+//  qboolean videoSDone = qfalse;
+	qboolean        audioWantsMoreData = qfalse;
+	int             status;
+
+	while(anyDataTransferred && (needVOutputData || audioWantsMoreData))
+	{
+		anyDataTransferred = qfalse;
+
+//      xvid -> "gl" ? videoDone : needPacket
+//      vorbis -> raw sound ? audioDone : needPacket
+//      anyDataTransferred = videoDone && audioDone;
+//      needVOutputData = videoDone && audioDone;
+//      if needPacket
+		{
+//          videoStream -> xvid ? videoStreamDone : needPage
+//          audioSteam -> vorbis ? audioStreamDone : needPage
+//          anyDataTransferred = audioStreamDone && audioStreamDone;
+
+			if(needVOutputData && (status = loadVideoFrame()))
+			{
+				needVOutputData = qfalse;
+				if(status > 0)
+					anyDataTransferred = qtrue;
+				else
+					anyDataTransferred = qfalse;	// error (we don't need any videodata and we had no transferred)
+			}
+
+//          if needPage
+			if(needVOutputData || audioWantsMoreData)
+			{
+				// try to transfer Pages to the audio- and video-Stream
+				if(loadPagesToStreams())
+				{
+					// try to load a datablock from file
+					anyDataTransferred |= !loadBlockToSync();
+				}
+				else
+					anyDataTransferred = qtrue;	// successful loadPagesToStreams()
+			}
+
+			// load all Audio after loading new pages ...
+			if(g_ogm.VFrameCount > 1)	// wait some videoframes (it's better to have some delay, than a lagy sound)
+				audioWantsMoreData = loadAudio();
+		}
+	}
+
+//  ogg_packet_clear(&op);
+
+	return !anyDataTransferred;
+}
+
+//from VLC ogg.c ( http://trac.videolan.org/vlc/browser/trunk/modules/demux/ogg.c )
+typedef struct
+{
+	char            streamtype[8];
+	char            subtype[4];
+
+	ogg_int32_t     size;		/* size of the structure */
+
+	ogg_int64_t     time_unit;	/* in reference time */// in 10^-7 seconds (dT between frames)
+	ogg_int64_t     samples_per_unit;
+	ogg_int32_t     default_len;	/* in media time */
+
+	ogg_int32_t     buffersize;
+	ogg_int16_t     bits_per_sample;
+
+	union
+	{
+		struct
+		{
+			ogg_int32_t     width;
+			ogg_int32_t     height;
+		} stream_header_video;
+
+		struct
+		{
+			ogg_int16_t     channels;
+			ogg_int16_t     blockalign;
+			ogg_int32_t     avgbytespersec;
+		} stream_header_audio;
+	} sh;
+} stream_header_t;
+
+qboolean isPowerOf2(int x)
+{
+	int             bitsSet = 0;
+	int             i;
+
+	for(i = 0; i < sizeof(int) * 8; ++i)
+		if(x & (1 << i))
+			++bitsSet;
+
+	return (bitsSet <= 1);
+}
+
+/*
+
+  return: 0 -> no problem
+*/
+//TODO: vorbis/theora-header&init in sub-functions
+//TODO: "clean" error-returns ...
+int Cin_OGM_Init(const char *filename)
+{
+	int             status;
+	ogg_page        og;
+	ogg_packet      op;
+	int             i;
+
+	if(g_ogm.ogmFile)
+	{
+		Com_Printf(S_COLOR_YELLOW "WARNING: it seams there was already a ogm running, it will be killed to start %s\n", filename);
+		Cin_OGM_Shutdown();
+	}
+
+	memset(&g_ogm, 0, sizeof(cin_ogm_t));
+
+	FS_FOpenFileRead(filename, &g_ogm.ogmFile, qtrue);
+	if(!g_ogm.ogmFile)
+	{
+		Com_Printf(S_COLOR_YELLOW "WARNING: Can't open ogm-file for reading (%s)\n", filename);
+		return -1;
+	}
+
+	ogg_sync_init(&g_ogm.oy);	/* Now we can read pages */
+
+	//FIXME? can serialno be 0 in ogg? (better way to check inited?)
+	//TODO: support for more than one audio stream? / detect files with one stream(or without correct ones)
+	while(!g_ogm.os_audio.serialno || !g_ogm.os_video.serialno)
+	{
+		if(ogg_sync_pageout(&g_ogm.oy, &og) == 1)
+		{
+			if(strstr((char *)(og.body + 1), "vorbis"))
+			{
+				//FIXME? better way to find audio stream
+				if(g_ogm.os_audio.serialno)
+				{
+					Com_Printf(S_COLOR_YELLOW "WARNING: more than one audio stream, in ogm-file(%s) ... we will stay at the first one\n", filename);
+				}
+				else
+				{
+					ogg_stream_init(&g_ogm.os_audio, ogg_page_serialno(&og));
+					ogg_stream_pagein(&g_ogm.os_audio, &og);
+				}
+			}
+#ifdef USE_CIN_THEORA
+			if(strstr((char *)(og.body + 1), "theora"))
+			{
+				if(g_ogm.os_video.serialno)
+				{
+					Com_Printf(S_COLOR_YELLOW "WARNING: more than one video stream, in ogm-file(%s) ... we will stay at the first one\n", filename);
+				}
+				else
+				{
+					g_ogm.videoStreamIsTheora = qtrue;
+					ogg_stream_init(&g_ogm.os_video, ogg_page_serialno(&og));
+					ogg_stream_pagein(&g_ogm.os_video, &og);
+				}
+			}
+#endif
+#ifdef USE_CIN_XVID
+			if(strstr((char *)(og.body + 1), "video"))
+			{					//FIXME? better way to find video stream
+				if(g_ogm.os_video.serialno)
+				{
+					Com_Printf("more than one video stream, in ogm-file(%s) ... we will stay at the first one\n", filename);
+				}
+				else
+				{
+					stream_header_t *sh;
+
+					g_ogm.videoStreamIsXvid = qtrue;
+
+					sh = (stream_header_t *) (og.body + 1);
+					//TODO: one solution for checking xvid and theora
+					if(!isPowerOf2(sh->sh.stream_header_video.width))
+					{
+						Com_Printf("VideoWidth of the ogm-file isn't a power of 2 value (%s)\n", filename);
+
+						return -5;
+					}
+					if(!isPowerOf2(sh->sh.stream_header_video.height))
+					{
+						Com_Printf("VideoHeight of the ogm-file isn't a power of 2 value (%s)\n", filename);
+
+						return -6;
+					}
+
+					g_ogm.Vtime_unit = sh->time_unit;
+
+					ogg_stream_init(&g_ogm.os_video, ogg_page_serialno(&og));
+					ogg_stream_pagein(&g_ogm.os_video, &og);
+				}
+			}
+#endif
+		}
+		else if(loadBlockToSync())
+			break;
+	}
+
+	if(g_ogm.videoStreamIsXvid && g_ogm.videoStreamIsTheora)
+	{
+		Com_Printf(S_COLOR_YELLOW "WARNING: Found \"video\"- and \"theora\"-stream ,ogm-file (%s)\n", filename);
+		return -2;
+	}
+
+#if 1
+	if(!g_ogm.os_audio.serialno)
+	{
+		Com_Printf(S_COLOR_YELLOW "WARNING: Haven't found a audio(vorbis) stream in ogm-file (%s)\n", filename);
+		return -2;
+	}
+#endif
+	if(!g_ogm.os_video.serialno)
+	{
+		Com_Printf(S_COLOR_YELLOW "WARNING: Haven't found a video stream in ogm-file (%s)\n", filename);
+		return -3;
+	}
+
+	//load vorbis header
+	vorbis_info_init(&g_ogm.vi);
+	vorbis_comment_init(&g_ogm.vc);
+	i = 0;
+	while(i < 3)
+	{
+		status = ogg_stream_packetout(&g_ogm.os_audio, &op);
+		if(status < 0)
+		{
+			Com_Printf(S_COLOR_YELLOW "WARNING: Corrupt ogg packet while loading vorbis-headers, ogm-file(%s)\n", filename);
+			return -8;
+		}
+		if(status > 0)
+		{
+			status = vorbis_synthesis_headerin(&g_ogm.vi, &g_ogm.vc, &op);
+			if(i == 0 && status < 0)
+			{
+				Com_Printf(S_COLOR_YELLOW "WARNING: This Ogg bitstream does not contain Vorbis audio data, ogm-file(%s)\n", filename);
+				return -9;
+			}
+			++i;
+		}
+		else if(loadPagesToStreams())
+		{
+			if(loadBlockToSync())
+			{
+				Com_Printf(S_COLOR_YELLOW "WARNING: Couldn't find all vorbis headers before end of ogm-file (%s)\n", filename);
+				return -10;
+			}
+		}
+	}
+
+	vorbis_synthesis_init(&g_ogm.vd, &g_ogm.vi);
+
+#ifdef USE_CIN_XVID
+	status = init_xvid();
+	if(status)
+	{
+		Com_Printf("[Xvid]Decore INIT problem, return value %d(ogm-file: %s)\n", status, filename);
+
+		return -4;
+	}
+#endif
+
+#ifdef USE_CIN_THEORA
+	if(g_ogm.videoStreamIsTheora)
+	{
+		ROQ_GenYUVTables();
+
+		theora_info_init(&g_ogm.th_info);
+		theora_comment_init(&g_ogm.th_comment);
+
+		i = 0;
+		while(i < 3)
+		{
+			status = ogg_stream_packetout(&g_ogm.os_video, &op);
+			if(status < 0)
+			{
+				Com_Printf(S_COLOR_YELLOW "WARNING: Corrupt ogg packet while loading theora-headers, ogm-file(%s)\n", filename);
+				return -8;
+			}
+			if(status > 0)
+			{
+				status = theora_decode_header(&g_ogm.th_info, &g_ogm.th_comment, &op);
+				if(i == 0 && status != 0)
+				{
+					Com_Printf(S_COLOR_YELLOW "WARNING: This Ogg bitstream does not contain theora data, ogm-file(%s)\n", filename);
+					return -9;
+				}
+				++i;
+			}
+			else if(loadPagesToStreams())
+			{
+				if(loadBlockToSync())
+				{
+					Com_Printf(S_COLOR_YELLOW "WARNING: Couldn't find all theora headers before end of ogm-file (%s)\n", filename);
+					return -10;
+				}
+			}
+		}
+
+		theora_decode_init(&g_ogm.th_state, &g_ogm.th_info);
+
+		if(!isPowerOf2(g_ogm.th_info.width))
+		{
+			Com_Printf(S_COLOR_YELLOW "WARNING: VideoWidth of the ogm-file isn't a power of 2 value (%s)\n", filename);
+			return -5;
+		}
+		if(!isPowerOf2(g_ogm.th_info.height))
+		{
+			Com_Printf(S_COLOR_YELLOW "WARNING: VideoHeight of the ogm-file isn't a power of 2 value (%s)\n", filename);
+			return -6;
+		}
+
+		g_ogm.Vtime_unit = ((ogg_int64_t) g_ogm.th_info.fps_denominator * 1000 * 10000 / g_ogm.th_info.fps_numerator);
+	}
+#endif
+
+	Com_DPrintf("OGM-Init done (%s)\n", filename);
+
+	return 0;
+}
+
+int nextNeededVFrame(void)
+{
+	return (int)(g_ogm.currentTime * (ogg_int64_t) 10000 / g_ogm.Vtime_unit);
+}
+
+/*
+
+  time ~> time in ms to which the movie should run
+  return:	0 => nothing special
+			1 => eof
+*/
+int Cin_OGM_Run(int time)
+{
+
+	g_ogm.currentTime = time;
+
+	while(!g_ogm.VFrameCount || time + 20 >= (int)(g_ogm.VFrameCount * g_ogm.Vtime_unit / 10000))
+	{
+		if(loadFrame())
+			return 1;
+	}
+
+	return 0;
+}
+
+/*
+  Gives a Pointer to the current Output-Buffer
+  and the Resolution
+*/
+unsigned char  *Cin_OGM_GetOutput(int *outWidth, int *outHeight)
+{
+	if(outWidth != NULL)
+		*outWidth = g_ogm.outputWidht;
+	if(outHeight != NULL)
+		*outHeight = g_ogm.outputHeight;
+
+	return g_ogm.outputBuffer;
+}
+
+void Cin_OGM_Shutdown()
+{
+#ifdef USE_CIN_XVID
+	int             status;
+
+	status = shutdown_xvid();
+	if(status)
+		Com_Printf("[Xvid]Decore RELEASE problem, return value %d\n", status);
+#endif
+
+#ifdef USE_CIN_THEORA
+	theora_clear(&g_ogm.th_state);
+	theora_comment_clear(&g_ogm.th_comment);
+	theora_info_clear(&g_ogm.th_info);
+#endif
+
+	if(g_ogm.outputBuffer)
+		free(g_ogm.outputBuffer);
+	g_ogm.outputBuffer = NULL;
+
+	vorbis_dsp_clear(&g_ogm.vd);
+	vorbis_comment_clear(&g_ogm.vc);
+	vorbis_info_clear(&g_ogm.vi);	/* must be called last (comment from vorbis example code) */
+
+	ogg_stream_clear(&g_ogm.os_audio);
+	ogg_stream_clear(&g_ogm.os_video);
+
+	ogg_sync_clear(&g_ogm.oy);
+
+	FS_FCloseFile(g_ogm.ogmFile);
+	g_ogm.ogmFile = 0;
+}
+
+#else
+int Cin_OGM_Init(const char *filename)
+{
+	return 1;
+}
+int Cin_OGM_Run(int time)
+{
+	return 1;
+}
+unsigned char  *Cin_OGM_GetOutput(int *outWidth, int *outHeight)
+{
+	return 0;
+}
+
+void Cin_OGM_Shutdown()
+{
+}
+#endif
+
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/client/cl_cgame.c
--- a/src/client/cl_cgame.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/client/cl_cgame.c	Mon Jul 06 04:07:05 2009 +0800
@@ -859,7 +859,6 @@
 */
 void CL_CGameRendering( stereoFrame_t stereo ) {
 	VM_Call( cgvm, CG_DRAW_ACTIVE_FRAME, cl.serverTime, stereo, clc.demoplaying );
-	VM_Debug( 0 );
 }
 
 
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/client/cl_cin.c
--- a/src/client/cl_cin.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/client/cl_cin.c	Mon Jul 06 04:07:05 2009 +0800
@@ -74,6 +74,11 @@
 static	unsigned short		vq4[256*64*4];
 static	unsigned short		vq8[256*256*4];
 
+typedef enum
+{
+	FT_ROQ = 0,					// normal roq (vq3 stuff)
+	FT_OGM						// ogm(ogg wrapper, vorbis audio, xvid/theora video) for WoP
+} filetype_t;
 
 typedef struct {
 	byte				linbuf[DEFAULT_CIN_WIDTH*DEFAULT_CIN_HEIGHT*4*2];
@@ -126,6 +131,7 @@
 	int					playonwalls;
 	byte*				buf;
 	long				drawX, drawY;
+	filetype_t			fileType;
 } cin_cache;
 
 static cinematics_t		cin;
@@ -506,7 +512,7 @@
 *
 ******************************************************************************/
 
-static void ROQ_GenYUVTables( void )
+void ROQ_GenYUVTables( void )
 {
 	float t_ub,t_vr,t_ug,t_vg;
 	long i;
@@ -584,6 +590,51 @@
 	return (unsigned short)((r<<11)+(g<<5)+(b));
 }
 
+/*
+Frame_yuv_to_rgb24
+is used by the Theora(ogm) code
+
+  moved the convertion into one function, to reduce the number of function-calls
+*/
+void Frame_yuv_to_rgb24(const unsigned char *y, const unsigned char *u, const unsigned char *v,
+						int width, int height, int y_stride, int uv_stride,
+						int yWShift, int uvWShift, int yHShift, int uvHShift, unsigned int *output)
+{
+	int             i, j, uvI;
+	long            r, g, b, YY;
+
+	for(j = 0; j < height; ++j)
+	{
+		for(i = 0; i < width; ++i)
+		{
+
+			YY = (long)(ROQ_YY_tab[(y[(i >> yWShift) + (j >> yHShift) * y_stride])]);
+			uvI = (i >> uvWShift) + (j >> uvHShift) * uv_stride;
+
+			r = (YY + ROQ_VR_tab[v[uvI]]) >> 6;
+			g = (YY + ROQ_UG_tab[u[uvI]] + ROQ_VG_tab[v[uvI]]) >> 6;
+			b = (YY + ROQ_UB_tab[u[uvI]]) >> 6;
+
+			if(r < 0)
+				r = 0;
+			if(g < 0)
+				g = 0;
+			if(b < 0)
+				b = 0;
+			if(r > 255)
+				r = 255;
+			if(g > 255)
+				g = 255;
+			if(b > 255)
+				b = 255;
+
+			*output = LittleLong((r) | (g << 8) | (b << 16) | (255 << 24));
+			++output;
+		}
+	}
+
+}
+
 /******************************************************************************
 *
 * Function:		
@@ -992,19 +1043,6 @@
 
         cinTable[currentHandle].drawX = cinTable[currentHandle].CIN_WIDTH;
         cinTable[currentHandle].drawY = cinTable[currentHandle].CIN_HEIGHT;
-        
-	// rage pro is very slow at 512 wide textures, voodoo can't do it at all
-	if ( cls.glconfig.hardwareType == GLHW_RAGEPRO || cls.glconfig.maxTextureSize <= 256) {
-                if (cinTable[currentHandle].drawX>256) {
-                        cinTable[currentHandle].drawX = 256;
-                }
-                if (cinTable[currentHandle].drawY>256) {
-                        cinTable[currentHandle].drawY = 256;
-                }
-		if (cinTable[currentHandle].CIN_WIDTH != 256 || cinTable[currentHandle].CIN_HEIGHT != 256) {
-			Com_Printf("HACK: approxmimating cinematic for Rage Pro or Voodoo\n");
-		}
-	}
 }
 
 /******************************************************************************
@@ -1261,8 +1299,12 @@
 *
 ******************************************************************************/
 
+//FIXME: this isn't realy a "roq-shutdown" (it's more a CIN-shutdown, beside the file-closing)
 static void RoQShutdown( void ) {
+	const char *s;
+
 	if (!cinTable[currentHandle].buf) {
+		//FIXME: there could be something that should be "shutdowned" even if we don't have a output frame (at least in the ogm code)
 		return;
 	}
 
@@ -1279,15 +1321,30 @@
 
 	if (cinTable[currentHandle].alterGameState) {
 		cls.state = CA_DISCONNECTED;
+		// we can't just do a vstr nextmap, because
+		// if we are aborting the intro cinematic with
+		// a devmap command, nextmap would be valid by
+		// the time it was referenced
+		s = Cvar_VariableString("nextmap");
+		if(s[0])
+		{
+			Cbuf_ExecuteText(EXEC_APPEND, va("%s\n", s));
+			Cvar_Set("nextmap", "");
+		}
 		CL_handle = -1;
 	}
 	cinTable[currentHandle].fileName[0] = 0;
+	if(cinTable[currentHandle].fileType == FT_OGM)
+	{
+		Cin_OGM_Shutdown();
+		cinTable[currentHandle].buf = NULL;
+	}
 	currentHandle = -1;
 }
 
 /*
 ==================
-SCR_StopCinematic
+CIN_StopCinematic
 ==================
 */
 e_status CIN_StopCinematic(int handle) {
@@ -1314,13 +1371,11 @@
 
 /*
 ==================
-SCR_RunCinematic
+CIN_RunCinematic
 
 Fetch and decompress the pending frame
 ==================
 */
-
-
 e_status CIN_RunCinematic (int handle)
 {
 	int	start = 0;
@@ -1352,6 +1407,67 @@
 		return cinTable[currentHandle].status;
 	}
 
+	if(cinTable[currentHandle].fileType == FT_OGM)
+	{
+
+		if(Cin_OGM_Run(cinTable[currentHandle].startTime == 0 ? 0 : CL_ScaledMilliseconds() - cinTable[currentHandle].startTime))
+			cinTable[currentHandle].status = FMV_EOF;
+		else
+		{
+			int             newW, newH;
+			qboolean        resolutionChange = qfalse;
+
+			cinTable[currentHandle].buf = Cin_OGM_GetOutput(&newW, &newH);
+
+			if(newW != cinTable[currentHandle].CIN_WIDTH)
+			{
+				cinTable[currentHandle].CIN_WIDTH = newW;
+				resolutionChange = qtrue;
+			}
+			if(newH != cinTable[currentHandle].CIN_HEIGHT)
+			{
+				cinTable[currentHandle].CIN_HEIGHT = newH;
+				resolutionChange = qtrue;
+			}
+
+			if(resolutionChange)
+			{
+				cinTable[currentHandle].drawX = cinTable[currentHandle].CIN_WIDTH;
+				cinTable[currentHandle].drawY = cinTable[currentHandle].CIN_HEIGHT;
+			}
+
+			cinTable[currentHandle].status = FMV_PLAY;
+			cinTable[currentHandle].dirty = qtrue;
+		}
+
+		if(!cinTable[currentHandle].startTime)
+			cinTable[currentHandle].startTime = CL_ScaledMilliseconds();
+
+		if(cinTable[currentHandle].status == FMV_EOF)
+		{
+			if(cinTable[currentHandle].holdAtEnd)
+			{
+				cinTable[currentHandle].status = FMV_IDLE;
+			}
+			else if(cinTable[currentHandle].looping)
+			{
+				Cin_OGM_Shutdown();
+				Cin_OGM_Init(cinTable[currentHandle].fileName);
+				cinTable[currentHandle].buf = NULL;
+				cinTable[currentHandle].startTime = 0;
+				cinTable[currentHandle].status = FMV_PLAY;
+			}
+			else
+			{
+				RoQShutdown();
+//              Cin_OGM_Shutdown();
+			}
+		}
+
+		return cinTable[currentHandle].status;
+	}
+
+	//FIXME? CL_ScaledMilliseconds already uses com_timescale (so I can't see that the com_timescale in here makes any sense at all O_o)
 	// we need to use CL_ScaledMilliseconds because of the smp mode calls from the renderer
 	thisTime = CL_ScaledMilliseconds()*com_timescale->value;
 	if (cinTable[currentHandle].shader && (abs(thisTime - cinTable[currentHandle].lastTime))>100) {
@@ -1390,15 +1506,18 @@
 	return cinTable[currentHandle].status;
 }
 
+char *S_FileExtension(const char *fni);	// from snd_codec.c (just a nice implementation of getting a point to the extention)
+
 /*
 ==================
-CL_PlayCinematic
+CIN_PlayCinematic
 
 ==================
 */
 int CIN_PlayCinematic( const char *arg, int x, int y, int w, int h, int systemBits ) {
 	unsigned short RoQID;
 	char	name[MAX_OSPATH];
+	char	*fileextPtr;
 	int		i;
 
 	if (strstr(arg, "/") == NULL && strstr(arg, "\\") == NULL) {
@@ -1420,10 +1539,62 @@
 	Com_Memset(&cin, 0, sizeof(cinematics_t) );
 	currentHandle = CIN_HandleForVideo();
 
+	Com_Memset(&cinTable[currentHandle], 0, sizeof(cin_cache));
+
 	cin.currentHandle = currentHandle;
 
 	strcpy(cinTable[currentHandle].fileName, name);
 
+	fileextPtr = S_FileExtension(name);	// using the function from soundfile/audiocodec-detection
+	if(!Q_stricmp(fileextPtr, ".ogm") || !Q_stricmp(fileextPtr, ".ogv"))
+	{
+		if(Cin_OGM_Init(name))
+		{
+			Com_DPrintf("starting ogm-playback failed(%s)\n", arg);
+			cinTable[currentHandle].fileName[0] = 0;
+			Cin_OGM_Shutdown();
+			return -1;
+		}
+
+		cinTable[currentHandle].fileType = FT_OGM;
+
+		CIN_SetExtents(currentHandle, x, y, w, h);
+		CIN_SetLooping(currentHandle, (systemBits & CIN_loop) != 0);
+
+		cinTable[currentHandle].holdAtEnd = (systemBits & CIN_hold) != 0;
+		cinTable[currentHandle].alterGameState = (systemBits & CIN_system) != 0;
+		cinTable[currentHandle].playonwalls = 1;
+		cinTable[currentHandle].silent = (systemBits & CIN_silent) != 0;
+		cinTable[currentHandle].shader = (systemBits & CIN_shader) != 0;
+
+/* we will set this info after the first xvid-frame
+		cinTable[currentHandle].CIN_HEIGHT = DEFAULT_CIN_HEIGHT;
+		cinTable[currentHandle].CIN_WIDTH  =  DEFAULT_CIN_WIDTH;
+*/
+
+		if(cinTable[currentHandle].alterGameState)
+		{
+			// close the menu
+			if(uivm)
+			{
+				VM_Call(uivm, UI_SET_ACTIVE_MENU, UIMENU_NONE);
+			}
+		}
+		else
+		{
+			cinTable[currentHandle].playonwalls = cl_inGameVideo->integer;
+		}
+
+		if(cinTable[currentHandle].alterGameState)
+		{
+			cls.state = CA_CINEMATIC;
+		}
+
+		cinTable[currentHandle].status = FMV_PLAY;
+
+		return currentHandle;
+	}
+
 	cinTable[currentHandle].ROQSize = 0;
 	cinTable[currentHandle].ROQSize = FS_FOpenFileRead (cinTable[currentHandle].fileName, &cinTable[currentHandle].iFile, qtrue);
 
@@ -1498,7 +1669,7 @@
 
 /*
 ==================
-SCR_DrawCinematic
+CIN_DrawCinematic
 
 ==================
 */
@@ -1647,7 +1818,8 @@
 				}
 			}
 		}
-		re.UploadCinematic( 256, 256, 256, 256, cinTable[handle].buf, handle, cinTable[handle].dirty);
+		re.UploadCinematic(cinTable[handle].width, cinTable[handle].height, cinTable[handle].drawX, cinTable[handle].drawY,
+						   cinTable[handle].buf, handle, cinTable[handle].dirty);
 		if (cl_inGameVideo->integer == 0 && cinTable[handle].playonwalls == 1) {
 			cinTable[handle].playonwalls--;
 		}
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/client/cl_console.c
--- a/src/client/cl_console.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/client/cl_console.c	Mon Jul 06 04:07:05 2009 +0800
@@ -58,6 +58,8 @@
 
 cvar_t		*con_conspeed;
 
+cvar_t		*scr_conUseOld;
+
 // Color and alpha for console
 cvar_t		*scr_conUseShader;
 
@@ -374,6 +376,80 @@
 
 /*
 ================
+Con_Grep_f
+
+Find all console lines containing a string
+================
+*/
+void Con_Grep_f (void)
+{
+	int		l, x, i;
+	short	*line;
+	char	buffer[1024];
+	char	buffer2[1024];
+	char	printbuf[CON_TEXTSIZE];
+	char	*search;
+	char	lastcolor;
+
+	if (Cmd_Argc() != 2)
+	{
+		Com_Printf ("usage: grep <string>\n");
+		return;
+	}
+
+	// skip empty lines
+	for (l = con.current - con.totallines + 1 ; l <= con.current ; l++)
+	{
+		line = con.text + (l%con.totallines)*con.linewidth;
+		for (x=0 ; x<con.linewidth ; x++)
+			if ((line[x] & 0xff) != ' ')
+				break;
+		if (x != con.linewidth)
+			break;
+	}
+
+	// check the remaining lines
+	buffer[con.linewidth] = 0;
+	search = Cmd_Argv( 1 );
+	printbuf[0] = '\0';
+	lastcolor = 7;
+	for ( ; l <= con.current ; l++)
+	{
+		line = con.text + (l%con.totallines)*con.linewidth;
+		for(i=0,x=0; i<con.linewidth; i++)
+		{
+			if (line[i] >> 8 != lastcolor)
+			{
+				lastcolor = line[i] >> 8;
+				buffer[x++] = Q_COLOR_ESCAPE;
+				buffer[x++] = lastcolor + '0';
+			}
+			buffer[x++] = line[i] & 0xff;
+		}
+		for (x=con.linewidth-1 ; x>=0 ; x--)
+		{
+			if (buffer[x] == ' ')
+				buffer[x] = 0;
+			else
+				break;
+		}
+		// Don't search commands
+		if (!Q_stricmpn(buffer, cl_consolePrompt->string, strlen(cl_consolePrompt->string)))
+			continue;
+		strcpy(buffer2, buffer);
+		Q_CleanStr(buffer2);
+		if (Q_stristr(buffer2, search))
+		{
+			strcat( printbuf, buffer );
+			strcat( printbuf, "\n" );
+		}
+	}
+	if ( printbuf[0] )
+		Com_Printf( "%s", printbuf );
+}
+
+/*
+================
 Con_ClearNotify
 ================
 */
@@ -397,8 +473,12 @@
 	short	tbuf[CON_TEXTSIZE];
 
 	if (cls.glconfig.vidWidth) {
-		g_consoleField.widthInChars = cls.glconfig.vidWidth / SCR_ConsoleFontCharWidth('W') - Q_PrintStrlen(cl_consolePrompt->string) - 1;
-		width = cls.glconfig.vidWidth / SCR_ConsoleFontCharWidth('W') - 2;
+		if (scr_conUseOld->integer) {
+			width = cls.glconfig.vidWidth / SCR_ConsoleFontCharWidth('W');
+		} else {
+			width = (cls.glconfig.vidWidth - 30) / SCR_ConsoleFontCharWidth('W');
+		}
+		g_consoleField.widthInChars = width - Q_PrintStrlen(cl_consolePrompt->string) - 1;
 	} else {
 		width = 0;
 	}
@@ -474,6 +554,8 @@
 	
 	con_conspeed = Cvar_Get ("scr_conspeed", "3", 0);
 	
+	scr_conUseOld = Cvar_Get ("scr_conUseOld", "0", CVAR_ARCHIVE|CVAR_LATCH);
+	
 	// Defines cvar for color and alpha for console/bar under console
 	scr_conUseShader = Cvar_Get ("scr_conUseShader", "0", CVAR_ARCHIVE);
 	
@@ -509,6 +591,7 @@
 	Cmd_SetCommandCompletionFunc( "condump", Cmd_CompleteTxtName );
 	Cmd_AddCommand ("search", Con_Search_f);
 	Cmd_AddCommand ("searchDown", Con_Search_f);
+	Cmd_AddCommand ("grep", Con_Grep_f);
 }
 
 
@@ -665,6 +748,7 @@
 void Con_DrawInput (void) {
 	int		y;
 	char	prompt[ MAX_STRING_CHARS ];
+	vec4_t	color;
 	qtime_t realtime;
 
 	if ( cls.state != CA_DISCONNECTED && !(Key_GetCatcher( ) & KEYCATCH_CONSOLE ) ) {
@@ -677,10 +761,15 @@
 
 	Com_sprintf( prompt,  sizeof( prompt ), "^0[^3%02d%c%02d^0]^7 %s", realtime.tm_hour, (realtime.tm_sec & 1) ? ':' : ' ', realtime.tm_min, cl_consolePrompt->string );
 
-	SCR_DrawSmallStringExt( con.xadjust + cl_conXOffset->integer, y, prompt, colorWhite, qfalse, qfalse );
+	color[0] = 1.0f;
+	color[1] = 1.0f;
+	color[2] = 1.0f;
+	color[3] = (scr_conUseOld->integer ? 1.0f : con.displayFrac * 2.0f);
+
+	SCR_DrawSmallStringExt( con.xadjust + cl_conXOffset->integer, y, prompt, color, qfalse, qfalse );
 
 	Q_CleanStr( prompt );
-	Field_Draw( &g_consoleField, con.xadjust + cl_conXOffset->integer + SCR_ConsoleFontStringWidth(prompt, strlen(prompt)), y, qtrue, qtrue );
+	Field_Draw( &g_consoleField, con.xadjust + cl_conXOffset->integer + SCR_ConsoleFontStringWidth(prompt, strlen(prompt)), y, qtrue, qtrue, color[3] );
 }
 
 /*
@@ -700,74 +789,108 @@
 	int				currentColor;
 	vec4_t			color;
 
-	lines = cls.glconfig.vidHeight * frac;
-	if (lines <= 0)
-		return;
+	if (scr_conUseOld->integer) {
+		lines = cls.glconfig.vidHeight * frac;
+		if (lines <= 0)
+			return;
 
-	if (lines > cls.glconfig.vidHeight )
-		lines = cls.glconfig.vidHeight;
+		if (lines > cls.glconfig.vidHeight )
+			lines = cls.glconfig.vidHeight;
+	} else {
+		lines = cls.glconfig.vidHeight * scr_conHeight->integer * 0.01 - 10;
+	}
 
 	// on wide screens, we will center the text
-	con.xadjust = 0;
+	if (!scr_conUseOld->integer) {
+		con.xadjust = 15;
+	}
 	SCR_AdjustFrom640( &con.xadjust, NULL, NULL, NULL );
 
 	// draw the background
-	y = frac * SCREEN_HEIGHT;
-	if ( y < 1 ) {
-		y = 0;
+	if (scr_conUseOld->integer) {
+		y = frac * SCREEN_HEIGHT;
+		if ( y < 1 ) {
+			y = 0;
+		}
+		else {
+		 if( scr_conUseShader->integer )
+		   {
+			SCR_DrawPic( 0, 0, SCREEN_WIDTH, y, cls.consoleShader );
+		   }
+		 else
+		   {
+			// This will be overwrote, so ill just abuse it here, no need to define another array
+			color[0] = scr_conColorRed->value;
+			color[1] = scr_conColorGreen->value;
+			color[2] = scr_conColorBlue->value;
+			color[3] = scr_conColorAlpha->value;
+			
+			SCR_FillRect( 0, 0, SCREEN_WIDTH, y, color );
+		   }
+		}
+
+		color[0] = scr_conBarColorRed->value;
+		color[1] = scr_conBarColorGreen->value;
+		color[2] = scr_conBarColorBlue->value;
+		color[3] = scr_conBarColorAlpha->value;
+		
+		SCR_FillRect( 0, y, SCREEN_WIDTH, scr_conBarSize->value, color );
+	} else {
+		color[0] = 0.05f;
+		color[1] = 0.25f;
+		color[2] = 0.30f;
+		color[3] = frac * 0.85f;
+		SCR_FillRect(10, 10, 620, 460 * scr_conHeight->integer * 0.01, color);
+
+		color[0] = 0.7f;
+		color[1] = 0.7f;
+		color[2] = 0.9f;
+		color[3] = frac * 0.75f;
+		SCR_FillRect(10, 10, 620, 1, color);	//top
+		SCR_FillRect(10, 460 * scr_conHeight->integer * 0.01 + 10, 620, 1, color);	//buttom
+		SCR_FillRect(10, 10, 1, 460 * scr_conHeight->integer * 0.01, color);	//left
+		SCR_FillRect(630, 10, 1, 460 * scr_conHeight->integer * 0.01, color);	//right
 	}
-	else {
-	 if( scr_conUseShader->integer )
-	   {
-		SCR_DrawPic( 0, 0, SCREEN_WIDTH, y, cls.consoleShader );
-	   }
-	 else
-	   {
-	  	// This will be overwrote, so ill just abuse it here, no need to define another array
-		color[0] = scr_conColorRed->value;
-		color[1] = scr_conColorGreen->value;
-		color[2] = scr_conColorBlue->value;
-		color[3] = scr_conColorAlpha->value;
-		
-	   	SCR_FillRect( 0, 0, SCREEN_WIDTH, y, color );
-	   }
-	}
-
-	color[0] = scr_conBarColorRed->value;
-	color[1] = scr_conBarColorGreen->value;
-	color[2] = scr_conBarColorBlue->value;
-	color[3] = scr_conBarColorAlpha->value;
-	
-	SCR_FillRect( 0, y, SCREEN_WIDTH, scr_conBarSize->value, color );
 
 
 	// draw the version number
 
-	re.SetColor( g_color_table[ColorIndex(COLOR_RED)] );
+	color[0] = 1.0f;
+	color[1] = 0.0f;
+	color[2] = 0.0f;
+	color[3] = (scr_conUseOld->integer ? 1.0f : frac * 2.0f);
+	re.SetColor( color );
 
 	i = strlen( Q3_VERSION );
     float totalwidth = SCR_ConsoleFontStringWidth( Q3_VERSION, i ) + cl_conXOffset->integer;
+	if (!scr_conUseOld->integer) {
+		totalwidth += 30;
+	}
     float currentWidthLocation = 0;
 	for (x=0 ; x<i ; x++) {
-
         SCR_DrawConsoleFontChar( cls.glconfig.vidWidth - totalwidth + currentWidthLocation, lines-SCR_ConsoleFontCharHeight(), Q3_VERSION[x] );
         currentWidthLocation += SCR_ConsoleFontCharWidth( Q3_VERSION[x] );
-
 	}
 
 
 	// draw the text
 	con.vislines = lines;
-	rows = (lines)/SCR_ConsoleFontCharHeight();		// rows of text to draw
+	rows = (lines)/SCR_ConsoleFontCharHeight() - 3;		// rows of text to draw
+	if (scr_conUseOld->integer)
+		rows++;
 
 	y = lines - (SCR_ConsoleFontCharHeight()*3);
 
 	// draw from the bottom up
 	if (con.display != con.current)
 	{
-	// draw arrows to show the buffer is backscrolled
-	    re.SetColor( g_color_table[ColorIndex(COLOR_RED)] );
-        for (x=0 ; x<con.linewidth ; x+=4)
+		// draw arrows to show the buffer is backscrolled
+		color[0] = 1.0f;
+		color[1] = 0.0f;
+		color[2] = 0.0f;
+		color[3] = (scr_conUseOld->integer ? 1.0f : frac * 2.0f);
+	    re.SetColor( color );
+        for (x=0 ; x<con.linewidth - (scr_conUseOld->integer ? 0 : 4); x+=4)
             SCR_DrawConsoleFontChar( con.xadjust + (x+1)*SCR_ConsoleFontCharWidth('^'), y, '^' );
         y -= SCR_ConsoleFontCharHeight();
         rows--;
@@ -780,7 +903,11 @@
 	}
 
 	currentColor = 7;
-	re.SetColor( g_color_table[currentColor] );
+	color[0] = g_color_table[currentColor][0];
+	color[1] = g_color_table[currentColor][1];
+	color[2] = g_color_table[currentColor][2];
+	color[3] = (scr_conUseOld->integer ? 1.0f : frac * 2.0f);
+	re.SetColor( color );
 
 	for (i=0 ; i<rows ; i++, y -= SCR_ConsoleFontCharHeight(), row--)
 	{
@@ -797,7 +924,11 @@
 		for (x=0 ; x<con.linewidth ; x++) {
 			if ( ( (text[x]>>8)&7 ) != currentColor ) {
 				currentColor = (text[x]>>8)&7;
-				re.SetColor( g_color_table[currentColor] );
+				color[0] = g_color_table[currentColor][0];
+				color[1] = g_color_table[currentColor][1];
+				color[2] = g_color_table[currentColor][2];
+				color[3] = (scr_conUseOld->integer ? 1.0f : frac * 2.0f);
+				re.SetColor( color );
 			}
             
             SCR_DrawConsoleFontChar(  con.xadjust + currentWidthLocation, y, text[x] & 0xff );
@@ -884,7 +1015,11 @@
 void Con_RunConsole (void) {
 	// decide on the destination height of the console
 	if ( Key_GetCatcher( ) & KEYCATCH_CONSOLE )
-		con.finalFrac = MAX(0.10, 0.01 * scr_conHeight->integer);  // configured console percentage
+		if (scr_conUseOld->integer) {
+			con.finalFrac = MAX(0.10, 0.01 * scr_conHeight->integer);  // configured console percentage
+		} else {
+			con.finalFrac = 0.5;
+		}
 	else
 		con.finalFrac = 0;				// none visible
 	
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/client/cl_keys.c
--- a/src/client/cl_keys.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/client/cl_keys.c	Mon Jul 06 04:07:05 2009 +0800
@@ -308,7 +308,7 @@
 ===================
 */
 void Field_VariableSizeDraw( field_t *edit, int x, int y, int size, qboolean showCursor,
-		qboolean noColorEscape ) {
+		qboolean noColorEscape, float alpha ) {
 	int		len;
 	int		drawLen;
 	int		prestep;
@@ -348,7 +348,8 @@
 	if ( size == SMALLCHAR_WIDTH ) {
 		float	color[4];
 
-		color[0] = color[1] = color[2] = color[3] = 1.0;
+		color[0] = color[1] = color[2] = 1.0;
+		color[3] = alpha;
 		SCR_DrawSmallStringExt( x, y, str, color, qfalse, noColorEscape );
 	} else {
 		// draw big string with drop shadow
@@ -381,14 +382,14 @@
 	}
 }
 
-void Field_Draw( field_t *edit, int x, int y, qboolean showCursor, qboolean noColorEscape ) 
+void Field_Draw( field_t *edit, int x, int y, qboolean showCursor, qboolean noColorEscape, float alpha ) 
 {
-	Field_VariableSizeDraw( edit, x, y, SMALLCHAR_WIDTH, showCursor, noColorEscape );
+	Field_VariableSizeDraw( edit, x, y, SMALLCHAR_WIDTH, showCursor, noColorEscape, alpha );
 }
 
 void Field_BigDraw( field_t *edit, int x, int y, qboolean showCursor, qboolean noColorEscape ) 
 {
-	Field_VariableSizeDraw( edit, x, y, BIGCHAR_WIDTH, showCursor, noColorEscape );
+	Field_VariableSizeDraw( edit, x, y, BIGCHAR_WIDTH, showCursor, noColorEscape, 1.0f );
 }
 
 /*
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/client/cl_main.c
--- a/src/client/cl_main.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/client/cl_main.c	Mon Jul 06 04:07:05 2009 +0800
@@ -1089,7 +1089,7 @@
 	}
 
 	if (!demofile) {
-		Com_Error( ERR_DROP, "couldn't open %s", name);
+		Com_Printf("Couldn't open %s\n", name);
 		return;
 	}
 
@@ -1484,11 +1484,7 @@
 		BigShort( cls.updateServer.port ) );
 
 	info[0] = 0;
-  // NOTE TTimo xoring against Com_Milliseconds, otherwise we may not have a true randomization
-  // only srand I could catch before here is tr_noise.c l:26 srand(1001)
-  // https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=382
-  // NOTE: the Com_Milliseconds xoring only affects the lower 16-bit word,
-  //   but I decided it was enough randomization
+
 	Com_sprintf( cls.updateChallenge, sizeof( cls.updateChallenge ),
 			"%i", ((rand() << 16) ^ rand()) ^ Com_Milliseconds());
 
@@ -1660,10 +1656,14 @@
 
 	// if we aren't playing on a lan, we need to authenticate
 	// with the cd key
-	if ( NET_IsLocalAddress( clc.serverAddress ) ) {
+	if(NET_IsLocalAddress(clc.serverAddress))
 		cls.state = CA_CHALLENGING;
-	} else {
+	else
+	{
 		cls.state = CA_CONNECTING;
+		
+		// Set a client challenge number that ideally is mirrored back by the server.
+		clc.challenge = ((rand() << 16) ^ rand()) ^ Com_Milliseconds();
 	}
 
 	Key_SetCatcher( 0 );
@@ -2257,9 +2257,9 @@
 =================
 */
 void CL_CheckForResend( void ) {
-	int		port, i;
+	int		port;
 	char	info[MAX_INFO_STRING];
-	char	data[MAX_INFO_STRING];
+	char	data[MAX_STRING_CHARS];
 
 	// don't send anything if playing back a demo
 	if ( clc.demoplaying ) {
@@ -2282,7 +2282,8 @@
 	switch ( cls.state ) {
 	case CA_CONNECTING:
 		// requesting a challenge
-		NET_OutOfBandPrint(NS_CLIENT, clc.serverAddress, "getchallenge");
+		// The challenge request shall be followed by a client challenge so no malicious server can hijack this connection.
+		NET_OutOfBandPrint(NS_CLIENT, clc.serverAddress, "getchallenge %d", clc.challenge);
 		break;
 		
 	case CA_CHALLENGING:
@@ -2293,20 +2294,9 @@
 		Info_SetValueForKey( info, "protocol", va("%i", PROTOCOL_VERSION ) );
 		Info_SetValueForKey( info, "qport", va("%i", port ) );
 		Info_SetValueForKey( info, "challenge", va("%i", clc.challenge ) );
-		
-		strcpy(data, "connect ");
-    // TTimo adding " " around the userinfo string to avoid truncated userinfo on the server
-    //   (Com_TokenizeString tokenizes around spaces)
-    data[8] = '"';
-
-		for(i=0;i<strlen(info);i++) {
-			data[9+i] = info[i];	// + (clc.challenge)&0x3;
-		}
-    data[9+i] = '"';
-		data[10+i] = 0;
-
-    // NOTE TTimo don't forget to set the right data length!
-		NET_OutOfBandData( NS_CLIENT, clc.serverAddress, (byte *) &data[0], i+10 );
+		Com_sprintf( data, sizeof( data ), "connect \"%s\"", info );
+
+		NET_OutOfBandData( NS_CLIENT, clc.serverAddress, data, strlen( data ) + 1 );
 		// the most current userinfo has been sent, so watch for any
 		// newer changes to userinfo variables
 		cvar_modifiedFlags &= ~CVAR_USERINFO;
@@ -2513,8 +2503,7 @@
 */
 void CL_ConnectionlessPacket( netadr_t from, msg_t *msg ) {
 	char	*s;
-	char	c[ BIG_INFO_STRING ];
-	char	arg1[ BIG_INFO_STRING ];
+	char	*c;
 
 	MSG_BeginReadingOOB( msg );
 	MSG_ReadLong( msg );	// skip the -1
@@ -2523,27 +2512,44 @@
 
 	Cmd_TokenizeString( s );
 
-	Q_strncpyz( c, Cmd_Argv( 0 ), BIG_INFO_STRING );
-	Q_strncpyz( arg1, Cmd_Argv( 1 ), BIG_INFO_STRING );
+	c = Cmd_Argv( 0 );
 
 	Com_DPrintf ("CL packet %s: %s\n", NET_AdrToStringwPort(from), c);
 
 	// challenge from the server we are connecting to
-	if ( !Q_stricmp(c, "challengeResponse") ) {
-		if ( cls.state != CA_CONNECTING ) {
-			Com_DPrintf( "Unwanted challenge response received.  Ignored.\n" );
-		} else {
-			// start sending challenge repsonse instead of challenge request packets
-			clc.challenge = atoi(arg1);
-			cls.state = CA_CHALLENGING;
-			clc.connectPacketCount = 0;
-			clc.connectTime = -99999;
-
-			// take this address as the new server address.  This allows
-			// a server proxy to hand off connections to multiple servers
-			clc.serverAddress = from;
-			Com_DPrintf ("challengeResponse: %d\n", clc.challenge);
-		}
+	if (!Q_stricmp(c, "challengeResponse"))
+	{
+		if (cls.state != CA_CONNECTING)
+		{
+			Com_DPrintf("Unwanted challenge response received.  Ignored.\n");
+			return;
+		}
+		
+		if(!NET_CompareAdr(from, clc.serverAddress))
+		{
+			// This challenge response is not coming from the expected address.
+			// Check whether we have a matching client challenge to prevent
+			// connection hi-jacking.
+			
+			c = Cmd_Argv(2);
+			
+			if(!*c || atoi(c) != clc.challenge)
+			{
+				Com_DPrintf("Challenge response received from unexpected source. Ignored.\n");
+				return;
+			}
+		}
+
+		// start sending challenge response instead of challenge request packets
+		clc.challenge = atoi(Cmd_Argv(1));
+		cls.state = CA_CHALLENGING;
+		clc.connectPacketCount = 0;
+		clc.connectTime = -99999;
+
+		// take this address as the new server address.  This allows
+		// a server proxy to hand off connections to multiple servers
+		clc.serverAddress = from;
+		Com_DPrintf ("challengeResponse: %d\n", clc.challenge);
 		return;
 	}
 
@@ -2554,13 +2560,11 @@
 			return;
 		}
 		if ( cls.state != CA_CHALLENGING ) {
-			Com_Printf ("connectResponse packet while not connecting.  Ignored.\n");
-			return;
-		}
-		if ( !NET_CompareBaseAdr( from, clc.serverAddress ) ) {
-			Com_Printf( "connectResponse from a different address.  Ignored.\n" );
-			Com_Printf( "%s should have been %s\n", NET_AdrToStringwPort( from ), 
-				NET_AdrToStringwPort( clc.serverAddress ) );
+			Com_Printf ("connectResponse packet while not connecting. Ignored.\n");
+			return;
+		}
+		if ( !NET_CompareAdr( from, clc.serverAddress ) ) {
+			Com_Printf( "connectResponse from wrong address. Ignored.\n" );
 			return;
 		}
 		Netchan_Setup (NS_CLIENT, &clc.netchan, from, Cvar_VariableValue( "net_qport" ) );
@@ -2590,13 +2594,13 @@
 
 	// echo request from server
 	if ( !Q_stricmp(c, "echo") ) {
-		NET_OutOfBandPrint( NS_CLIENT, from, "%s", arg1 );
+		NET_OutOfBandPrint( NS_CLIENT, from, "%s", Cmd_Argv(1) );
 		return;
 	}
 
 	// global MOTD from trem master
 	if ( !Q_stricmp(c, "motd") ) {
-		CL_MotdPacket( from, arg1 );
+		CL_MotdPacket( from, Cmd_Argv(1) );
 		return;
 	}
 
@@ -3668,7 +3672,6 @@
 	char	info[MAX_INFO_STRING];
 	char	*infoString;
 	int		prot;
-	int		realmsec = Sys_Milliseconds();
 
 	infoString = MSG_ReadString( msg );
 
@@ -3685,7 +3688,7 @@
 		if ( cl_pinglist[i].adr.port && !cl_pinglist[i].time && NET_CompareAdr( from, cl_pinglist[i].adr ) )
 		{
 			// calc ping time
-			cl_pinglist[i].time = realmsec - cl_pinglist[i].start;
+			cl_pinglist[i].time = Sys_Milliseconds() - cl_pinglist[i].start;
 			Com_DPrintf( "ping time %dms from %s\n", cl_pinglist[i].time, NET_AdrToString( from ) );
 
 			// save of info
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/client/client.h
--- a/src/client/client.h	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/client/client.h	Mon Jul 06 04:07:05 2009 +0800
@@ -613,6 +613,20 @@
 void CIN_UploadCinematic(int handle);
 void CIN_CloseAllVideos(void);
 
+// yuv->rgb will be used for Theora(ogm)
+void ROQ_GenYUVTables(void);
+void Frame_yuv_to_rgb24(const unsigned char *y, const unsigned char *u, const unsigned char *v,
+                        int width, int height, int y_stride, int uv_stride,
+                        int yWShift, int uvWShift, int yHShift, int uvHShift, unsigned int *output);
+
+//
+// cin_ogm.c
+//
+int Cin_OGM_Init(const char *filename);
+int Cin_OGM_Run(int time);
+unsigned char *Cin_OGM_GetOutput(int *outWidth, int *outHeight);
+void Cin_OGM_Shutdown(void);
+
 //
 // cl_cgame.c
 //
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/client/keys.h
--- a/src/client/keys.h	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/client/keys.h	Mon Jul 06 04:07:05 2009 +0800
@@ -34,7 +34,7 @@
 // NOTE TTimo the declaration of field_t and Field_Clear is now in qcommon/qcommon.h
 void Field_KeyDownEvent( field_t *edit, int key );
 void Field_CharEvent( field_t *edit, int ch );
-void Field_Draw( field_t *edit, int x, int y, qboolean showCursor, qboolean noColorEscape );
+void Field_Draw( field_t *edit, int x, int y, qboolean showCursor, qboolean noColorEscape, float alpha );
 void Field_BigDraw( field_t *edit, int x, int y, qboolean showCursor, qboolean noColorEscape );
 
 extern	field_t	g_consoleField;
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/client/qal.h
--- a/src/client/qal.h	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/client/qal.h	Mon Jul 06 04:07:05 2009 +0800
@@ -50,7 +50,6 @@
 
 #ifdef _WIN32
 #define ALDRIVER_DEFAULT "OpenAL32.dll"
-#define ALDEVICE_DEFAULT "Generic Software"
 #elif defined(MACOS_X)
 #define ALDRIVER_DEFAULT "/System/Library/Frameworks/OpenAL.framework/OpenAL"
 #else
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/client/snd_codec.c
--- a/src/client/snd_codec.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/client/snd_codec.c	Mon Jul 06 04:07:05 2009 +0800
@@ -32,7 +32,7 @@
 S_FileExtension
 =================
 */
-static char *S_FileExtension(const char *fni)
+char *S_FileExtension(const char *fni)
 {
 	// we should search from the ending to the last '/'
 
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/client/snd_openal.c
--- a/src/client/snd_openal.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/client/snd_openal.c	Mon Jul 06 04:07:05 2009 +0800
@@ -2055,8 +2055,7 @@
 qboolean S_AL_Init( soundInterface_t *si )
 {
 #ifdef USE_OPENAL
-
-	qboolean enumsupport, founddev = qfalse;
+	const char* device = NULL;
 	int i;
 
 	if( !si ) {
@@ -2081,7 +2080,9 @@
 	s_alGraceDistance = Cvar_Get("s_alGraceDistance", "512", CVAR_CHEAT);
 	s_alSourcePitch = Cvar_Get("s_alSourcePitch", "1.0", CVAR_ARCHIVE);
 
-	s_alDriver = Cvar_Get( "s_alDriver", ALDRIVER_DEFAULT, CVAR_ARCHIVE );
+	s_alDriver = Cvar_Get( "s_alDriver", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH );
+
+	s_alDevice = Cvar_Get("s_alDevice", "", CVAR_ARCHIVE | CVAR_LATCH);
 
 	// Load QAL
 	if( !QAL_Init( s_alDriver->string ) )
@@ -2090,8 +2091,12 @@
 		return qfalse;
 	}
 
+	device = s_alDevice->string;
+	if(device && !*device)
+		device = NULL;
+
 	// Device enumeration support (extension is implemented reasonably only on Windows right now).
-	if((enumsupport = qalcIsExtensionPresent(NULL, "ALC_ENUMERATION_EXT")))
+	if(qalcIsExtensionPresent(NULL, "ALC_ENUMERATION_EXT"))
 	{
 		char devicenames[1024] = "";
 		const char *devicelist;
@@ -2107,11 +2112,9 @@
 		// Generic Software as that one works more reliably with various sound systems.
 		// If it's not, use OpenAL's default selection as we don't want to ignore
 		// native hardware acceleration.
-		if(!strcmp(defaultdevice, "Generic Hardware"))
-			s_alDevice = Cvar_Get("s_alDevice", ALDEVICE_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH);
-		else
+		if(!device && !strcmp(defaultdevice, "Generic Hardware"))
+			device = "Generic Software";
 #endif
-			s_alDevice = Cvar_Get("s_alDevice", defaultdevice, CVAR_ARCHIVE | CVAR_LATCH);
 
 		// dump a list of available devices to a cvar for the user to see.
 		while((curlen = strlen(devicelist)))
@@ -2119,26 +2122,18 @@
 			Q_strcat(devicenames, sizeof(devicenames), devicelist);
 			Q_strcat(devicenames, sizeof(devicenames), "\n");
 
-			// check whether the device we want to load is available at all.
-			if(!strcmp(s_alDevice->string, devicelist))
-				founddev = qtrue;
-
 			devicelist += curlen + 1;
 		}
 
 		s_alAvailableDevices = Cvar_Get("s_alAvailableDevices", devicenames, CVAR_ROM | CVAR_NORESTART);
-		
-		if(!founddev)
-		{
-			Cvar_ForceReset("s_alDevice");
-			founddev = 1;
-		}
 	}
 
-	if(founddev)
-		alDevice = qalcOpenDevice(s_alDevice->string);
-	else
+	alDevice = qalcOpenDevice(device);
+	if( !alDevice && device )
+	{
+		Com_Printf( "Failed to open OpenAL device '%s', trying default.\n", device );
 		alDevice = qalcOpenDevice(NULL);
+	}
 
 	if( !alDevice )
 	{
@@ -2147,9 +2142,6 @@
 		return qfalse;
 	}
 
-	if(enumsupport)
-		Cvar_Set("s_alDevice", qalcGetString(alDevice, ALC_DEVICE_SPECIFIER));
-
 	// Create OpenAL context
 	alContext = qalcCreateContext( alDevice, NULL );
 	if( !alContext )
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/libs/macosx/libogg.a
Binary file src/libs/macosx/libogg.a has changed
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/libs/macosx/libtheoradec.a
Binary file src/libs/macosx/libtheoradec.a has changed
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/libs/macosx/libvorbis.a
Binary file src/libs/macosx/libvorbis.a has changed
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/libs/macosx/libvorbisfile.a
Binary file src/libs/macosx/libvorbisfile.a has changed
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/libs/win32/libogg.a
Binary file src/libs/win32/libogg.a has changed
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/libs/win32/libtheoradec.a
Binary file src/libs/win32/libtheoradec.a has changed
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/libs/win32/libvorbis.a
Binary file src/libs/win32/libvorbis.a has changed
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/libs/win32/libvorbisfile.a
Binary file src/libs/win32/libvorbisfile.a has changed
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/ogg_vorbis/ogg/ogg.h
--- a/src/ogg_vorbis/ogg/ogg.h	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/ogg_vorbis/ogg/ogg.h	Mon Jul 06 04:07:05 2009 +0800
@@ -11,7 +11,7 @@
  ********************************************************************
 
  function: toplevel libogg include
- last mod: $Id: ogg.h 14463 2008-02-09 11:16:55Z erikd $
+ last mod: $Id: ogg.h 16051 2009-05-27 05:00:06Z xiphmont $
 
  ********************************************************************/
 #ifndef _OGG_H
@@ -21,10 +21,11 @@
 extern "C" {
 #endif
 
+#include <stddef.h>
 #include <ogg/os_types.h>
 
 typedef struct {
-  void *iov_base; 
+  void *iov_base;
   size_t iov_len;
 } ogg_iovec_t;
 
@@ -58,8 +59,8 @@
 
   int     *lacing_vals;      /* The values that will go to the segment table */
   ogg_int64_t *granule_vals; /* granulepos values for headers. Not compact
-				this way, but it is simple coupled to the
-				lacing fifo */
+                                this way, but it is simple coupled to the
+                                lacing fifo */
   long    lacing_storage;
   long    lacing_fill;
   long    lacing_packet;
@@ -74,7 +75,7 @@
                              of a logical bitstream */
   long    serialno;
   long    pageno;
-  ogg_int64_t  packetno;      /* sequence number for decode; the framing
+  ogg_int64_t  packetno;  /* sequence number for decode; the framing
                              knows where there's a hole in the data,
                              but we need coupling so that the codec
                              (which is in a seperate abstraction
@@ -93,12 +94,12 @@
   long  e_o_s;
 
   ogg_int64_t  granulepos;
-  
+
   ogg_int64_t  packetno;     /* sequence number for decode; the framing
-				knows where there's a hole in the data,
-				but we need coupling so that the codec
-				(which is in a seperate abstraction
-				layer) also knows about the gap */
+                                knows where there's a hole in the data,
+                                but we need coupling so that the codec
+                                (which is in a seperate abstraction
+                                layer) also knows about the gap */
 } ogg_packet;
 
 typedef struct {
@@ -115,6 +116,7 @@
 /* Ogg BITSTREAM PRIMITIVES: bitstream ************************/
 
 extern void  oggpack_writeinit(oggpack_buffer *b);
+extern int   oggpack_writecheck(oggpack_buffer *b);
 extern void  oggpack_writetrunc(oggpack_buffer *b,long bits);
 extern void  oggpack_writealign(oggpack_buffer *b);
 extern void  oggpack_writecopy(oggpack_buffer *b,void *source,long bits);
@@ -133,6 +135,7 @@
 extern unsigned char *oggpack_get_buffer(oggpack_buffer *b);
 
 extern void  oggpackB_writeinit(oggpack_buffer *b);
+extern int   oggpackB_writecheck(oggpack_buffer *b);
 extern void  oggpackB_writetrunc(oggpack_buffer *b,long bits);
 extern void  oggpackB_writealign(oggpack_buffer *b);
 extern void  oggpackB_writecopy(oggpack_buffer *b,void *source,long bits);
@@ -154,7 +157,7 @@
 
 extern int      ogg_stream_packetin(ogg_stream_state *os, ogg_packet *op);
 extern int      ogg_stream_iovecin(ogg_stream_state *os, ogg_iovec_t *iov,
-				   int count, long e_o_s, ogg_int64_t granulepos);
+                                   int count, long e_o_s, ogg_int64_t granulepos);
 extern int      ogg_stream_pageout(ogg_stream_state *os, ogg_page *og);
 extern int      ogg_stream_flush(ogg_stream_state *os, ogg_page *og);
 
@@ -163,7 +166,8 @@
 extern int      ogg_sync_init(ogg_sync_state *oy);
 extern int      ogg_sync_clear(ogg_sync_state *oy);
 extern int      ogg_sync_reset(ogg_sync_state *oy);
-extern int	ogg_sync_destroy(ogg_sync_state *oy);
+extern int      ogg_sync_destroy(ogg_sync_state *oy);
+extern int      ogg_sync_check(ogg_sync_state *oy);
 
 extern char    *ogg_sync_buffer(ogg_sync_state *oy, long size);
 extern int      ogg_sync_wrote(ogg_sync_state *oy, long bytes);
@@ -180,6 +184,7 @@
 extern int      ogg_stream_reset(ogg_stream_state *os);
 extern int      ogg_stream_reset_serialno(ogg_stream_state *os,int serialno);
 extern int      ogg_stream_destroy(ogg_stream_state *os);
+extern int      ogg_stream_check(ogg_stream_state *os);
 extern int      ogg_stream_eos(ogg_stream_state *os);
 
 extern void     ogg_page_checksum_set(ogg_page *og);
@@ -201,9 +206,3 @@
 #endif
 
 #endif  /* _OGG_H */
-
-
-
-
-
-
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/ogg_vorbis/theora/codec.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/ogg_vorbis/theora/codec.h	Mon Jul 06 04:07:05 2009 +0800
@@ -0,0 +1,594 @@
+/********************************************************************
+ *                                                                  *
+ * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE.   *
+ * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
+ * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
+ * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
+ *                                                                  *
+ * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2007                *
+ * by the Xiph.Org Foundation http://www.xiph.org/                  *
+ *                                                                  *
+ ********************************************************************
+
+  function:
+  last mod: $Id: theora.h,v 1.8 2004/03/15 22:17:32 derf Exp $
+
+ ********************************************************************/
+
+/**\mainpage
+ * 
+ * \section intro Introduction
+ *
+ * This is the documentation for <tt>libtheora</tt> C API.
+ * The current reference
+ * implementation for <a href="http://www.theora.org/">Theora</a>, a free,
+ * patent-unencumbered video codec.
+ * Theora is derived from On2's VP3 codec with additional features and
+ *  integration for Ogg multimedia formats by
+ *  <a href="http://www.xiph.org/">the Xiph.Org Foundation</a>.
+ * Complete documentation of the format itself is available in
+ * <a href="http://www.theora.org/doc/Theora_I_spec.pdf">the Theora
+ *  specification</a>.
+ *
+ * \subsection Organization
+ *
+ * The functions documented here are actually subdivided into three 
+ * separate libraries:
+ * - <tt>libtheoraenc</tt> contains the encoder interface,
+ *   described in \ref encfuncs.
+ * - <tt>libtheoradec</tt> contains the decoder interface and
+ *   routines shared with the encoder.
+ *   You must also link to this if you link to <tt>libtheoraenc</tt>.
+ *   The routines in this library are described in \ref decfuncs and 
+ *   \ref basefuncs.
+ * - <tt>libtheora</tt> contains the \ref oldfuncs.
+ *
+ * New code should link to <tt>libtheoradec</tt> and, if using encoder
+ * features, <tt>libtheoraenc</tt>. Together these two export both
+ * the standard and the legacy API, so this is all that is needed by
+ * any code. The older <tt>libtheora</tt> library is provided just for
+ * compatibility with older build configurations.
+ *
+ * In general the recommended 1.x API symbols can be distinguished
+ * by their <tt>th_</tt> or <tt>TH_</tt> namespace prefix.
+ * The older, legacy API uses <tt>theora_</tt> or <tt>OC_</tt>
+ * prefixes instead.
+ */
+
+/**\file
+ * The shared <tt>libtheoradec</tt> and <tt>libtheoraenc</tt> C API.
+ * You don't need to include this directly.*/
+
+#if !defined(_O_THEORA_CODEC_H_)
+# define _O_THEORA_CODEC_H_ (1)
+# include <ogg/ogg.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+
+/**\name Return codes*/
+/*@{*/
+/**An invalid pointer was provided.*/
+#define TH_EFAULT     (-1)
+/**An invalid argument was provided.*/
+#define TH_EINVAL     (-10)
+/**The contents of the header were incomplete, invalid, or unexpected.*/
+#define TH_EBADHEADER (-20)
+/**The header does not belong to a Theora stream.*/
+#define TH_ENOTFORMAT (-21)
+/**The bitstream version is too high.*/
+#define TH_EVERSION   (-22)
+/**The specified function is not implemented.*/
+#define TH_EIMPL      (-23)
+/**There were errors in the video data packet.*/
+#define TH_EBADPACKET (-24)
+/**The decoded packet represented a dropped frame.
+   The player can continue to display the current frame, as the contents of the
+    decoded frame buffer have not changed.*/
+#define TH_DUPFRAME   (1)
+/*@}*/
+
+/**The currently defined color space tags.
+ * See <a href="http://www.theora.org/doc/Theora_I_spec.pdf">the Theora
+ *  specification</a>, Chapter 4, for exact details on the meaning of each of
+ *  these color spaces.*/
+typedef enum{
+  /**The color space was not specified at the encoder.
+      It may be conveyed by an external means.*/
+  TH_CS_UNSPECIFIED,
+  /**A color space designed for NTSC content.*/
+  TH_CS_ITU_REC_470M,
+  /**A color space designed for PAL/SECAM content.*/
+  TH_CS_ITU_REC_470BG,
+  /**The total number of currently defined color spaces.*/
+  TH_CS_NSPACES
+}th_colorspace;
+
+/**The currently defined pixel format tags.
+ * See <a href="http://www.theora.org/doc/Theora_I_spec.pdf">the Theora
+ *  specification</a>, Section 4.4, for details on the precise sample
+ *  locations.*/
+typedef enum{
+  /**Chroma decimation by 2 in both the X and Y directions (4:2:0).
+     The Cb and Cr chroma planes are half the width and half the height of the
+      luma plane.*/
+  TH_PF_420,
+  /**Currently reserved.*/
+  TH_PF_RSVD,
+  /**Chroma decimation by 2 in the X direction (4:2:2).
+     The Cb and Cr chroma planes are half the width of the luma plane, but full
+      height.*/
+  TH_PF_422,
+  /**No chroma decimation (4:4:4).
+     The Cb and Cr chroma planes are full width and full height.*/
+  TH_PF_444,
+  /**The total number of currently defined pixel formats.*/
+  TH_PF_NFORMATS
+}th_pixel_fmt;
+
+
+
+/**A buffer for a single color plane in an uncompressed image.
+ * This contains the image data in a left-to-right, top-down format.
+ * Each row of pixels is stored contiguously in memory, but successive rows
+ *  need not be.
+ * Use \a stride to compute the offset of the next row.
+ * The encoder accepts both positive \a stride values (top-down in memory) and
+ *  negative (bottom-up in memory).
+ * The decoder currently always generates images with positive strides.*/
+typedef struct{
+  /**The width of this plane.*/
+  int            width;
+  /**The height of this plane.*/
+  int            height;
+  /**The offset in bytes between successive rows.*/
+  int            stride;
+  /**A pointer to the beginning of the first row.*/
+  unsigned char *data;
+}th_img_plane;
+
+/**A complete image buffer for an uncompressed frame.
+ * The chroma planes may be decimated by a factor of two in either direction,
+ *  as indicated by th_info#pixel_fmt.
+ * The width and height of the Y' plane must be multiples of 16.
+ * They may need to be cropped for display, using the rectangle specified by
+ *  th_info#pic_x, th_info#pic_y, th_info#pic_width, and
+ *  th_info#pic_height.
+ * All samples are 8 bits.
+ * \note The term YUV often used to describe a colorspace is ambiguous.
+ * The exact parameters of the RGB to YUV conversion process aside, in many
+ *  contexts the U and V channels actually have opposite meanings.
+ * To avoid this confusion, we are explicit: the name of the color channels are
+ *  Y'CbCr, and they appear in that order, always.
+ * The prime symbol denotes that the Y channel is non-linear.
+ * Cb and Cr stand for "Chroma blue" and "Chroma red", respectively.*/
+typedef th_img_plane th_ycbcr_buffer[3];
+
+/**Theora bitstream information.
+ * This contains the basic playback parameters for a stream, and corresponds to 
+ *  the initial 'info' header packet.
+ * To initialize an encoder, the application fills in this structure and
+ *  passes it to th_encode_alloc().
+ * A default encoding mode is chosen based on the values of the #quality and
+ *  #target_bitrate fields.
+ * On decode, it is filled in by th_decode_headerin(), and then passed to
+ *  th_decode_alloc().
+ *
+ * Encoded Theora frames must be a multiple of 16 in size;
+ *  this is what the #frame_width and #frame_height members represent.
+ * To handle arbitrary picture sizes, a crop rectangle is specified in the
+ *  #pic_x, #pic_y, #pic_width and #pic_height members.
+ *
+ * All frame buffers contain pointers to the full, padded frame.
+ * However, the current encoder <em>will not</em> reference pixels outside of
+ *  the cropped picture region, and the application does not need to fill them
+ *  in.
+ * The decoder <em>will</em> allocate storage for a full frame, but the
+ *  application <em>should not</em> rely on the padding containing sensible
+ *  data.
+ *
+ * It is also generally recommended that the offsets and sizes should still be
+ *  multiples of 2 to avoid chroma sampling shifts when chroma is sub-sampled.
+ * See <a href="http://www.theora.org/doc/Theora_I_spec.pdf">the Theora
+ *  specification</a>, Section 4.4, for more details.
+ *
+ * Frame rate, in frames per second, is stored as a rational fraction, as is
+ *  the pixel aspect ratio.
+ * Note that this refers to the aspect ratio of the individual pixels, not of
+ *  the overall frame itself.
+ * The frame aspect ratio can be computed from pixel aspect ratio using the
+ *  image dimensions.*/
+typedef struct{
+  /**\name Theora version
+   * Bitstream version information.*/
+  /*@{*/
+  unsigned char version_major;
+  unsigned char version_minor;
+  unsigned char version_subminor;
+  /*@}*/
+  /**The encoded frame width.
+   * This must be a multiple of 16, and less than 1048576.*/
+  ogg_uint32_t  frame_width;
+  /**The encoded frame height.
+   * This must be a multiple of 16, and less than 1048576.*/
+  ogg_uint32_t  frame_height;
+  /**The displayed picture width.
+   * This must be no larger than width.*/
+  ogg_uint32_t  pic_width;
+  /**The displayed picture height.
+   * This must be no larger than height.*/
+  ogg_uint32_t  pic_height;
+  /**The X offset of the displayed picture.
+   * This must be no larger than #frame_width-#pic_width or 255, whichever is
+   *  smaller.*/
+  ogg_uint32_t  pic_x;
+  /**The Y offset of the displayed picture.
+   * This must be no larger than #frame_height-#pic_height, and
+   *  #frame_height-#pic_height-#pic_y must be no larger than 255.
+   * This slightly funny restriction is due to the fact that the offset is
+   *  specified from the top of the image for consistency with the standard
+   *  graphics left-handed coordinate system used throughout this API, while it
+   *  is stored in the encoded stream as an offset from the bottom.*/
+  ogg_uint32_t  pic_y;
+  /**\name Frame rate
+   * The frame rate, as a fraction.
+   * If either is 0, the frame rate is undefined.*/
+  /*@{*/
+  ogg_uint32_t  fps_numerator;
+  ogg_uint32_t  fps_denominator;
+  /*@}*/
+  /**\name Aspect ratio
+   * The aspect ratio of the pixels.
+   * If either value is zero, the aspect ratio is undefined.
+   * If not specified by any external means, 1:1 should be assumed.
+   * The aspect ratio of the full picture can be computed as
+   * \code
+   *  aspect_numerator*pic_width/(aspect_denominator*pic_height).
+   * \endcode */
+  /*@{*/
+  ogg_uint32_t  aspect_numerator;
+  ogg_uint32_t  aspect_denominator;
+  /*@}*/
+  /**The color space.*/
+  th_colorspace colorspace;
+  /**The pixel format.*/
+  th_pixel_fmt  pixel_fmt;
+  /**The target bit-rate in bits per second.
+     If initializing an encoder with this struct, set this field to a non-zero
+      value to activate CBR encoding by default.*/
+  /*TODO: Current encoder does not support CBR mode, or anything like it.
+    We also don't really know what nominal rate each quality level
+     corresponds to yet.*/
+  int           target_bitrate;
+  /**The target quality level.
+     Valid values range from 0 to 63, inclusive, with higher values giving
+      higher quality.
+     If initializing an encoder with this struct, and #target_bitrate is set
+      to zero, VBR encoding at this quality will be activated by default.*/
+  /*Currently this is set so that a qi of 0 corresponds to distortions of 24
+     times the JND, and each increase by 16 halves that value.
+    This gives us fine discrimination at low qualities, yet effective rate
+     control at high qualities.
+    The qi value 63 is special, however.
+    For this, the highest quality, we use one half of a JND for our threshold.
+    Due to the lower bounds placed on allowable quantizers in Theora, we will
+     not actually be able to achieve quality this good, but this should
+     provide as close to visually lossless quality as Theora is capable of.
+    We could lift the quantizer restrictions without breaking VP3.1
+     compatibility, but this would result in quantized coefficients that are
+     too large for the current bitstream to be able to store.
+    We'd have to redesign the token syntax to store these large coefficients,
+     which would make transcoding complex.*/
+  int           quality;
+  /**The amount to shift to extract the last keyframe number from the granule
+   *  position.
+   * This can be at most 31.
+   * th_info_init() will set this to a default value (currently <tt>6</tt>,
+   *  which is good for streaming applications), but you can set it to 0 to
+   *  make every frame a keyframe.
+   * The maximum distance between key frames is
+   *  <tt>1<<#keyframe_granule_shift</tt>.
+   * The keyframe frequency can be more finely controlled with
+   *  #TH_ENCCTL_SET_KEYFRAME_FREQUENCY_FORCE, which can also be adjusted
+   *  during encoding (for example, to force the next frame to be a keyframe),
+   *  but it cannot be set larger than the amount permitted by this field after
+   *  the headers have been output.*/
+  int           keyframe_granule_shift;
+}th_info;
+
+/**The comment information.
+ *
+ * This structure holds the in-stream metadata corresponding to
+ *  the 'comment' header packet.
+ * The comment header is meant to be used much like someone jotting a quick
+ *  note on the label of a video.
+ * It should be a short, to the point text note that can be more than a couple
+ *  words, but not more than a short paragraph.
+ *
+ * The metadata is stored as a series of (tag, value) pairs, in
+ *  length-encoded string vectors.
+ * The first occurrence of the '=' character delimits the tag and value.
+ * A particular tag may occur more than once, and order is significant.
+ * The character set encoding for the strings is always UTF-8, but the tag
+ *  names are limited to ASCII, and treated as case-insensitive.
+ * See <a href="http://www.theora.org/doc/Theora_I_spec.pdf">the Theora
+ *  specification</a>, Section 6.3.3 for details.
+ *
+ * In filling in this structure, th_decode_headerin() will null-terminate
+ *  the user_comment strings for safety.
+ * However, the bitstream format itself treats them as 8-bit clean vectors,
+ *  possibly containing null characters, and so the length array should be
+ *  treated as their authoritative length.
+ */
+typedef struct th_comment{
+  /**The array of comment string vectors.*/
+  char **user_comments;
+  /**An array of the corresponding length of each vector, in bytes.*/
+  int   *comment_lengths;
+  /**The total number of comment strings.*/
+  int    comments;
+  /**The null-terminated vendor string.
+     This identifies the software used to encode the stream.*/
+  char  *vendor;
+}th_comment;
+
+
+
+/**A single base matrix.*/
+typedef unsigned char th_quant_base[64];
+
+/**A set of \a qi ranges.*/
+typedef struct{
+  /**The number of ranges in the set.*/
+  int                  nranges;
+  /**The size of each of the #nranges ranges.
+     These must sum to 63.*/
+  const int           *sizes;
+  /**#nranges <tt>+1</tt> base matrices.
+     Matrices \a i and <tt>i+1</tt> form the endpoints of range \a i.*/
+  const th_quant_base *base_matrices;
+}th_quant_ranges;
+
+/**A complete set of quantization parameters.
+   The quantizer for each coefficient is calculated as:
+   \code
+    Q=MAX(MIN(qmin[qti][ci!=0],scale[ci!=0][qi]*base[qti][pli][qi][ci]/100),
+     1024).
+   \endcode
+
+   \a qti is the quantization type index: 0 for intra, 1 for inter.
+   <tt>ci!=0</tt> is 0 for the DC coefficient and 1 for AC coefficients.
+   \a qi is the quality index, ranging between 0 (low quality) and 63 (high
+    quality).
+   \a pli is the color plane index: 0 for Y', 1 for Cb, 2 for Cr.
+   \a ci is the DCT coefficient index.
+   Coefficient indices correspond to the normal 2D DCT block
+    ordering--row-major with low frequencies first--\em not zig-zag order.
+
+   Minimum quantizers are constant, and are given by:
+   \code
+   qmin[2][2]={{4,2},{8,4}}.
+   \endcode
+
+   Parameters that can be stored in the bitstream are as follows:
+    - The two scale matrices ac_scale and dc_scale.
+      \code
+      scale[2][64]={dc_scale,ac_scale}.
+      \endcode
+    - The base matrices for each \a qi, \a qti and \a pli (up to 384 in all).
+      In order to avoid storing a full 384 base matrices, only a sparse set of
+       matrices are stored, and the rest are linearly interpolated.
+      This is done as follows.
+      For each \a qti and \a pli, a series of \a n \a qi ranges is defined.
+      The size of each \a qi range can vary arbitrarily, but they must sum to
+       63.
+      Then, <tt>n+1</tt> matrices are specified, one for each endpoint of the
+       ranges.
+      For interpolation purposes, each range's endpoints are the first \a qi
+       value it contains and one past the last \a qi value it contains.
+      Fractional values are rounded to the nearest integer, with ties rounded
+       away from zero.
+
+      Base matrices are stored by reference, so if the same matrices are used
+       multiple times, they will only appear once in the bitstream.
+      The bitstream is also capable of omitting an entire set of ranges and
+       its associated matrices if they are the same as either the previous
+       set (indexed in row-major order) or if the inter set is the same as the
+       intra set.
+
+    - Loop filter limit values.
+      The same limits are used for the loop filter in all color planes, despite
+       potentially differing levels of quantization in each.
+
+   For the current encoder, <tt>scale[ci!=0][qi]</tt> must be no greater
+    than <tt>scale[ci!=0][qi-1]</tt> and <tt>base[qti][pli][qi][ci]</tt> must
+    be no greater than <tt>base[qti][pli][qi-1][ci]</tt>.
+   These two conditions ensure that the actual quantizer for a given \a qti,
+    \a pli, and \a ci does not increase as \a qi increases.
+   This is not required by the decoder.*/
+typedef struct{
+  /**The DC scaling factors.*/
+  ogg_uint16_t    dc_scale[64];
+  /**The AC scaling factors.*/
+  ogg_uint16_t    ac_scale[64];
+  /**The loop filter limit values.*/
+  unsigned char   loop_filter_limits[64];
+  /**The \a qi ranges for each \a ci and \a pli.*/
+  th_quant_ranges qi_ranges[2][3];
+}th_quant_info;
+
+
+
+/**The number of Huffman tables used by Theora.*/
+#define TH_NHUFFMAN_TABLES (80)
+/**The number of DCT token values in each table.*/
+#define TH_NDCT_TOKENS     (32)
+
+/**A Huffman code for a Theora DCT token.
+ * Each set of Huffman codes in a given table must form a complete, prefix-free
+ *  code.
+ * There is no requirement that all the tokens in a table have a valid code,
+ *  but the current encoder is not optimized to take advantage of this.
+ * If each of the five grouops of 16 tables does not contain at least one table
+ *  with a code for every token, then the encoder may fail to encode certain
+ *  frames.
+ * The complete table in the first group of 16 does not have to be in the same
+ *  place as the complete table in the other groups, but the complete tables in
+ *  the remaining four groups must all be in the same place.*/
+typedef struct{
+  /**The bit pattern for the code, with the LSbit of the pattern aligned in
+   *   the LSbit of the word.*/
+  ogg_uint32_t pattern;
+  /**The number of bits in the code.
+   * This must be between 0 and 32, inclusive.*/
+  int          nbits;
+}th_huff_code;
+
+
+
+/**\defgroup basefuncs Functions Shared by Encode and Decode*/
+/*@{*/
+/**\name Basic shared functions*/
+/*@{*/
+/**Retrieves a human-readable string to identify the library vendor and
+ *  version.
+ * \return the version string.*/
+extern const char *th_version_string(void);
+/**Retrieves the library version number.
+ * This is the highest bitstream version that the encoder library will produce,
+ *  or that the decoder library can decode.
+ * This number is composed of a 16-bit major version, 8-bit minor version
+ * and 8 bit sub-version, composed as follows:
+ * \code
+ * (VERSION_MAJOR<<16)+(VERSION_MINOR<<8)+(VERSION_SUBMINOR)
+ * \endcode
+ * \return the version number.*/
+extern ogg_uint32_t th_version_number(void);
+/**Converts a granule position to an absolute frame index, starting at
+ *  <tt>0</tt>.
+ * The granule position is interpreted in the context of a given
+ *  #th_enc_ctx or #th_dec_ctx handle (either will suffice).
+ * \param _encdec  A previously allocated #th_enc_ctx or #th_dec_ctx
+ *                  handle.
+ * \param _granpos The granule position to convert.
+ * \returns The absolute frame index corresponding to \a _granpos.
+ * \retval -1 The given granule position was invalid (i.e. negative).*/
+extern ogg_int64_t th_granule_frame(void *_encdec,ogg_int64_t _granpos);
+/**Converts a granule position to an absolute time in seconds.
+ * The granule position is interpreted in the context of a given
+ *  #th_enc_ctx or #th_dec_ctx handle (either will suffice).
+ * \param _encdec  A previously allocated #th_enc_ctx or #th_dec_ctx
+ *                  handle.
+ * \param _granpos The granule position to convert.
+ * \return The absolute time in seconds corresponding to \a _granpos.
+ *         This is the "end time" for the frame, or the latest time it should
+ *          be displayed.
+ *         It is not the presentation time.
+ * \retval -1 The given granule position was invalid (i.e. negative).*/
+extern double th_granule_time(void *_encdec,ogg_int64_t _granpos);
+/**Determines whether a Theora packet is a header or not.
+ * This function does no verification beyond checking the packet type bit, so
+ *  it should not be used for bitstream identification; use
+ *  th_decode_headerin() for that.
+ * As per the Theora specification, an empty (0-byte) packet is treated as a
+ *  data packet (a delta frame with no coded blocks).
+ * \param _op An <tt>ogg_packet</tt> containing encoded Theora data.
+ * \retval 1 The packet is a header packet
+ * \retval 0 The packet is a video data packet.*/
+extern int th_packet_isheader(ogg_packet *_op);
+/**Determines whether a theora packet is a key frame or not.
+ * This function does no verification beyond checking the packet type and
+ *  key frame bits, so it should not be used for bitstream identification; use
+ *  th_decode_headerin() for that.
+ * As per the Theora specification, an empty (0-byte) packet is treated as a
+ *  delta frame (with no coded blocks).
+ * \param _op An <tt>ogg_packet</tt> containing encoded Theora data.
+ * \retval 1  The packet contains a key frame.
+ * \retval 0  The packet contains a delta frame.
+ * \retval -1 The packet is not a video data packet.*/
+extern int th_packet_iskeyframe(ogg_packet *_op);
+/*@}*/
+
+
+/**\name Functions for manipulating header data*/
+/*@{*/
+/**Initializes a th_info structure.
+ * This should be called on a freshly allocated #th_info structure before
+ *  attempting to use it.
+ * \param _info The #th_info struct to initialize.*/
+extern void th_info_init(th_info *_info);
+/**Clears a #th_info structure.
+ * This should be called on a #th_info structure after it is no longer
+ *  needed.
+ * \param _info The #th_info struct to clear.*/
+extern void th_info_clear(th_info *_info);
+
+/**Initialize a #th_comment structure.
+ * This should be called on a freshly allocated #th_comment structure
+ *  before attempting to use it.
+ * \param _tc The #th_comment struct to initialize.*/
+extern void th_comment_init(th_comment *_tc);
+/**Add a comment to an initialized #th_comment structure.
+ * \note Neither th_comment_add() nor th_comment_add_tag() support
+ *  comments containing null values, although the bitstream format does
+ *  support them.
+ * To add such comments you will need to manipulate the #th_comment
+ *  structure directly.
+ * \param _tc      The #th_comment struct to add the comment to.
+ * \param _comment Must be a null-terminated UTF-8 string containing the
+ *                  comment in "TAG=the value" form.*/
+extern void th_comment_add(th_comment *_tc, char *_comment);
+/**Add a comment to an initialized #th_comment structure.
+ * \note Neither th_comment_add() nor th_comment_add_tag() support
+ *  comments containing null values, although the bitstream format does
+ *  support them.
+ * To add such comments you will need to manipulate the #th_comment
+ *  structure directly.
+ * \param _tc  The #th_comment struct to add the comment to.
+ * \param _tag A null-terminated string containing the tag  associated with
+ *              the comment.
+ * \param _val The corresponding value as a null-terminated string.*/
+extern void th_comment_add_tag(th_comment *_tc,char *_tag,char *_val);
+/**Look up a comment value by its tag.
+ * \param _tc    An initialized #th_comment structure.
+ * \param _tag   The tag to look up.
+ * \param _count The instance of the tag.
+ *               The same tag can appear multiple times, each with a distinct
+ *                value, so an index is required to retrieve them all.
+ *               The order in which these values appear is significant and
+ *                should be preserved.
+ *               Use th_comment_query_count() to get the legal range for
+ *                the \a _count parameter.
+ * \return A pointer to the queried tag's value.
+ *         This points directly to data in the #th_comment structure.
+ *         It should not be modified or freed by the application, and
+ *          modifications to the structure may invalidate the pointer.
+ * \retval NULL If no matching tag is found.*/
+extern char *th_comment_query(th_comment *_tc,char *_tag,int _count);
+/**Look up the number of instances of a tag.
+ * Call this first when querying for a specific tag and then iterate over the
+ *  number of instances with separate calls to th_comment_query() to
+ *  retrieve all the values for that tag in order.
+ * \param _tc    An initialized #th_comment structure.
+ * \param _tag   The tag to look up.
+ * \return The number on instances of this particular tag.*/
+extern int th_comment_query_count(th_comment *_tc,char *_tag);
+/**Clears a #th_comment structure.
+ * This should be called on a #th_comment structure after it is no longer
+ *  needed.
+ * It will free all memory used by the structure members.
+ * \param _tc The #th_comment struct to clear.*/
+extern void th_comment_clear(th_comment *_tc);
+/*@}*/
+/*@}*/
+
+
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/ogg_vorbis/theora/theora.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/ogg_vorbis/theora/theora.h	Mon Jul 06 04:07:05 2009 +0800
@@ -0,0 +1,794 @@
+/********************************************************************
+ *                                                                  *
+ * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE.   *
+ * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
+ * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
+ * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
+ *                                                                  *
+ * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2007                *
+ * by the Xiph.Org Foundation http://www.xiph.org/                  *
+ *                                                                  *
+ ********************************************************************
+
+  function:
+  last mod: $Id: theora.h,v 1.17 2003/12/06 18:06:19 arc Exp $
+
+ ********************************************************************/
+
+#ifndef _O_THEORA_H_
+#define _O_THEORA_H_
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+#include <stddef.h>	/* for size_t */
+
+#include <ogg/ogg.h>
+
+/** \defgroup oldfuncs Legacy pre-1.0 C API */
+/*  @{ */
+
+/** \mainpage
+ * 
+ * \section intro Introduction
+ *
+ * This is the documentation for the libtheora legacy C API, declared in 
+ * the theora.h header, which describes the old interface used before
+ * the 1.0 release. This API was widely deployed for several years and
+ * remains supported, but for new code we recommend the cleaner API 
+ * declared in theoradec.h and theoraenc.h.
+ *
+ * libtheora is the reference implementation for
+ * <a href="http://www.theora.org/">Theora</a>, a free video codec.
+ * Theora is derived from On2's VP3 codec with improved integration for
+ * Ogg multimedia formats by <a href="http://www.xiph.org/">Xiph.Org</a>.
+ * 
+ * \section overview Overview
+ *
+ * This library will both decode and encode theora packets to/from raw YUV 
+ * frames.  In either case, the packets will most likely either come from or
+ * need to be embedded in an Ogg stream.  Use 
+ * <a href="http://xiph.org/ogg/">libogg</a> or 
+ * <a href="http://www.annodex.net/software/liboggz/index.html">liboggz</a>
+ * to extract/package these packets.
+ *
+ * \section decoding Decoding Process
+ *
+ * Decoding can be separated into the following steps:
+ * -# initialise theora_info and theora_comment structures using 
+ *    theora_info_init() and theora_comment_init():
+ \verbatim
+ theora_info     info;
+ theora_comment  comment;
+   
+ theora_info_init(&info);
+ theora_comment_init(&comment);
+ \endverbatim
+ * -# retrieve header packets from Ogg stream (there should be 3) and decode 
+ *    into theora_info and theora_comment structures using 
+ *    theora_decode_header().  See \ref identification for more information on 
+ *    identifying which packets are theora packets.
+ \verbatim
+ int i;
+ for (i = 0; i < 3; i++)
+ {
+   (get a theora packet "op" from the Ogg stream)
+   theora_decode_header(&info, &comment, op);
+ }
+ \endverbatim
+ * -# initialise the decoder based on the information retrieved into the
+ *    theora_info struct by theora_decode_header().  You will need a 
+ *    theora_state struct.
+ \verbatim
+ theora_state state;
+ 
+ theora_decode_init(&state, &info);
+ \endverbatim
+ * -# pass in packets and retrieve decoded frames!  See the yuv_buffer 
+ *    documentation for information on how to retrieve raw YUV data.
+ \verbatim
+ yuf_buffer buffer;
+ while (last packet was not e_o_s) {
+   (get a theora packet "op" from the Ogg stream)
+   theora_decode_packetin(&state, op);
+   theora_decode_YUVout(&state, &buffer);
+ }
+ \endverbatim
+ *  
+ *
+ * \subsection identification Identifying Theora Packets
+ *
+ * All streams inside an Ogg file have a unique serial_no attached to the 
+ * stream.  Typically, you will want to 
+ *  - retrieve the serial_no for each b_o_s (beginning of stream) page 
+ *    encountered within the Ogg file; 
+ *  - test the first (only) packet on that page to determine if it is a theora 
+ *    packet;
+ *  - once you have found a theora b_o_s page then use the retrieved serial_no 
+ *    to identify future packets belonging to the same theora stream.
+ * 
+ * Note that you \e cannot use theora_packet_isheader() to determine if a 
+ * packet is a theora packet or not, as this function does not perform any
+ * checking beyond whether a header bit is present.  Instead, use the
+ * theora_decode_header() function and check the return value; or examine the
+ * header bytes at the beginning of the Ogg page.
+ *
+ * \subsection example Example Decoder 
+ *
+ * See <a href="http://svn.xiph.org/trunk/theora/examples/dump_video.c">
+ * examples/dump_video.c</a> for a simple decoder implementation.
+ *
+ * \section encoding Encoding Process
+ *
+ * See <a href="http://svn.xiph.org/trunk/theora/examples/encoder_example.c">
+ * examples/encoder_example.c</a> for a simple encoder implementation.
+ */
+
+/** \file
+ * The libtheora pre-1.0 legacy C API.
+ */
+
+/**
+ * A YUV buffer for passing uncompressed frames to and from the codec.
+ * This holds a Y'CbCr frame in planar format. The CbCr planes can be
+ * subsampled and have their own separate dimensions and row stride
+ * offsets. Note that the strides may be negative in some 
+ * configurations. For theora the width and height of the largest plane
+ * must be a multiple of 16. The actual meaningful picture size and 
+ * offset are stored in the theora_info structure; frames returned by
+ * the decoder may need to be cropped for display.
+ *
+ * All samples are 8 bits. Within each plane samples are ordered by
+ * row from the top of the frame to the bottom. Within each row samples
+ * are ordered from left to right.
+ *
+ * During decode, the yuv_buffer struct is allocated by the user, but all
+ * fields (including luma and chroma pointers) are filled by the library.  
+ * These pointers address library-internal memory and their contents should 
+ * not be modified.
+ *
+ * Conversely, during encode the user allocates the struct and fills out all
+ * fields.  The user also manages the data addressed by the luma and chroma
+ * pointers.  See the encoder_example.c and dump_video.c example files in
+ * theora/examples/ for more information.
+ */
+typedef struct {
+    int   y_width;      /**< Width of the Y' luminance plane */
+    int   y_height;     /**< Height of the luminance plane */
+    int   y_stride;     /**< Offset in bytes between successive rows */
+
+    int   uv_width;     /**< Width of the Cb and Cr chroma planes */
+    int   uv_height;    /**< Height of the chroma planes */
+    int   uv_stride;    /**< Offset between successive chroma rows */
+    unsigned char *y;   /**< Pointer to start of luminance data */
+    unsigned char *u;   /**< Pointer to start of Cb data */
+    unsigned char *v;   /**< Pointer to start of Cr data */
+
+} yuv_buffer;
+
+/**
+ * A Colorspace.
+ */
+typedef enum {
+  OC_CS_UNSPECIFIED,    /**< The colorspace is unknown or unspecified */
+  OC_CS_ITU_REC_470M,   /**< This is the best option for 'NTSC' content */
+  OC_CS_ITU_REC_470BG,  /**< This is the best option for 'PAL' content */
+  OC_CS_NSPACES         /**< This marks the end of the defined colorspaces */
+} theora_colorspace;
+
+/**
+ * A Chroma subsampling
+ *
+ * These enumerate the available chroma subsampling options supported
+ * by the theora format. See Section 4.4 of the specification for
+ * exact definitions.
+ */
+typedef enum {
+  OC_PF_420,    /**< Chroma subsampling by 2 in each direction (4:2:0) */
+  OC_PF_RSVD,   /**< Reserved value */
+  OC_PF_422,    /**< Horizonatal chroma subsampling by 2 (4:2:2) */
+  OC_PF_444,    /**< No chroma subsampling at all (4:4:4) */
+} theora_pixelformat;
+
+/**
+ * Theora bitstream info.
+ * Contains the basic playback parameters for a stream,
+ * corresponding to the initial 'info' header packet.
+ * 
+ * Encoded theora frames must be a multiple of 16 in width and height.
+ * To handle other frame sizes, a crop rectangle is specified in
+ * frame_height and frame_width, offset_x and * offset_y. The offset
+ * and size should still be a multiple of 2 to avoid chroma sampling
+ * shifts. Offset values in this structure are measured from the
+ * upper left of the image.
+ *
+ * Frame rate, in frames per second, is stored as a rational
+ * fraction. Aspect ratio is also stored as a rational fraction, and
+ * refers to the aspect ratio of the frame pixels, not of the
+ * overall frame itself.
+ * 
+ * See <a href="http://svn.xiph.org/trunk/theora/examples/encoder_example.c">
+ * examples/encoder_example.c</a> for usage examples of the
+ * other paramters and good default settings for the encoder parameters.
+ */
+typedef struct {
+  ogg_uint32_t  width;		/**< encoded frame width  */
+  ogg_uint32_t  height;		/**< encoded frame height */
+  ogg_uint32_t  frame_width;	/**< display frame width  */
+  ogg_uint32_t  frame_height;	/**< display frame height */
+  ogg_uint32_t  offset_x;	/**< horizontal offset of the displayed frame */
+  ogg_uint32_t  offset_y;	/**< vertical offset of the displayed frame */
+  ogg_uint32_t  fps_numerator;	    /**< frame rate numerator **/
+  ogg_uint32_t  fps_denominator;    /**< frame rate denominator **/
+  ogg_uint32_t  aspect_numerator;   /**< pixel aspect ratio numerator */
+  ogg_uint32_t  aspect_denominator; /**< pixel aspect ratio denominator */
+  theora_colorspace colorspace;	    /**< colorspace */
+  int           target_bitrate;	    /**< nominal bitrate in bits per second */
+  int           quality;  /**< Nominal quality setting, 0-63 */
+  int           quick_p;  /**< Quick encode/decode */
+
+  /* decode only */
+  unsigned char version_major;
+  unsigned char version_minor;
+  unsigned char version_subminor;
+
+  void *codec_setup;
+
+  /* encode only */
+  int           dropframes_p;
+  int           keyframe_auto_p;
+  ogg_uint32_t  keyframe_frequency;
+  ogg_uint32_t  keyframe_frequency_force;  /* also used for decode init to
+                                              get granpos shift correct */
+  ogg_uint32_t  keyframe_data_target_bitrate;
+  ogg_int32_t   keyframe_auto_threshold;
+  ogg_uint32_t  keyframe_mindistance;
+  ogg_int32_t   noise_sensitivity;
+  ogg_int32_t   sharpness;
+
+  theora_pixelformat pixelformat;	/**< chroma subsampling mode to expect */
+
+} theora_info;
+
+/** Codec internal state and context.
+ */
+typedef struct{
+  theora_info *i;
+  ogg_int64_t granulepos;
+
+  void *internal_encode;
+  void *internal_decode;
+
+} theora_state;
+
+/** 
+ * Comment header metadata.
+ *
+ * This structure holds the in-stream metadata corresponding to
+ * the 'comment' header packet.
+ *
+ * Meta data is stored as a series of (tag, value) pairs, in
+ * length-encoded string vectors. The first occurence of the 
+ * '=' character delimits the tag and value. A particular tag
+ * may occur more than once. The character set encoding for
+ * the strings is always UTF-8, but the tag names are limited
+ * to case-insensitive ASCII. See the spec for details.
+ *
+ * In filling in this structure, theora_decode_header() will
+ * null-terminate the user_comment strings for safety. However,
+ * the bitstream format itself treats them as 8-bit clean,
+ * and so the length array should be treated as authoritative
+ * for their length.
+ */
+typedef struct theora_comment{
+  char **user_comments;         /**< An array of comment string vectors */
+  int   *comment_lengths;       /**< An array of corresponding string vector lengths in bytes */
+  int    comments;              /**< The total number of comment string vectors */
+  char  *vendor;                /**< The vendor string identifying the encoder, null terminated */
+
+} theora_comment;
+
+
+/**\name theora_control() codes */
+
+/**\anchor decctlcodes
+ * These are the available request codes for theora_control()
+ * when called with a decoder instance.
+ * By convention, these are odd, to distinguish them from the
+ *  \ref encctlcodes "encoder control codes".
+ * Keep any experimental or vendor-specific values above \c 0x8000.*/
+
+/**Get the maximum post-processing level.
+ * The decoder supports a post-processing filter that can improve
+ * the appearance of the decoded images. This returns the highest
+ * level setting for this post-processor, corresponding to maximum
+ * improvement and computational expense.
+ */
+#define TH_DECCTL_GET_PPLEVEL_MAX (1)
+
+/**Set the post-processing level.
+ * Sets the level of post-processing to use when decoding the 
+ * compressed stream. This must be a value between zero (off)
+ * and the maximum returned by TH_DECCTL_GET_PPLEVEL_MAX.
+ */
+#define TH_DECCTL_SET_PPLEVEL (3)
+
+/**Sets the maximum distance between key frames.
+ * This can be changed during an encode, but will be bounded by
+ *  <tt>1<<th_info#keyframe_granule_shift</tt>.
+ * If it is set before encoding begins, th_info#keyframe_granule_shift will
+ *  be enlarged appropriately.
+ *
+ * \param[in]  buf <tt>ogg_uint32_t</tt>: The maximum distance between key
+ *                   frames.
+ * \param[out] buf <tt>ogg_uint32_t</tt>: The actual maximum distance set.
+ * \retval TH_FAULT  \a theora_state or \a buf is <tt>NULL</tt>.
+ * \retval TH_EINVAL \a buf_sz is not <tt>sizeof(ogg_uint32_t)</tt>.
+ * \retval TH_IMPL   Not supported by this implementation.*/
+#define TH_ENCCTL_SET_KEYFRAME_FREQUENCY_FORCE (4)
+
+/**Set the granule position.
+ * Call this after a seek, to update the internal granulepos
+ * in the decoder, to insure that subsequent frames are marked
+ * properly. If you track timestamps yourself and do not use
+ * the granule postion returned by the decoder, then you do
+ * not need to use this control.
+ */
+#define TH_DECCTL_SET_GRANPOS (5)
+
+
+/**\anchor encctlcodes
+ * These are the available request codes for theora_control()
+ * when called with an encoder instance.
+ * By convention, these are even, to distinguish them from the
+ *  \ref decctlcodes "decoder control codes".
+ * Keep any experimental or vendor-specific values above \c 0x8000.*/
+/*@{*/
+/**Sets the quantization parameters to use.
+ * The parameters are copied, not stored by reference, so they can be freed
+ *  after this call.
+ * <tt>NULL</tt> may be specified to revert to the default parameters.
+ * For the current encoder, <tt>scale[ci!=0][qi]</tt> must be no greater than
+ *  <tt>scale[ci!=0][qi-1]</tt> and <tt>base[qti][pli][qi][ci]</tt> must be no
+ *  greater than <tt>base[qti][pli][qi-1][ci]</tt>.
+ * These two conditions ensure that the actual quantizer for a given \a qti,
+ *  \a pli, and \a ci does not increase as \a qi increases.
+ *
+ * \param[in] buf #th_quant_info
+ * \retval TH_FAULT  \a theora_state is <tt>NULL</tt>.
+ * \retval TH_EINVAL Encoding has already begun, the quantization parameters
+ *                    do not meet one of the above stated conditions, \a buf
+ *                    is <tt>NULL</tt> and \a buf_sz is not zero, or \a buf
+ *                    is non-<tt>NULL</tt> and \a buf_sz is not
+ *                    <tt>sizeof(#th_quant_info)</tt>.
+ * \retval TH_IMPL   Not supported by this implementation.*/
+#define TH_ENCCTL_SET_QUANT_PARAMS (2)
+/**Disables any encoder features that would prevent lossless transcoding back
+ *  to VP3.
+ * This primarily means disabling block-level QI values and not using 4MV mode
+ *  when any of the luma blocks in a macro block are not coded.
+ * It also includes using the VP3 quantization tables and Huffman codes; if you
+ *  set them explicitly after calling this function, the resulting stream will
+ *  not be VP3-compatible.
+ * If you enable VP3-compatibility when encoding 4:2:2 or 4:4:4 source
+ *  material, or when using a picture region smaller than the full frame (e.g.
+ *  a non-multiple-of-16 width or height), then non-VP3 bitstream features will
+ *  still be disabled, but the stream will still not be VP3-compatible, as VP3
+ *  was not capable of encoding such formats.
+ * If you call this after encoding has already begun, then the quantization
+ *  tables and codebooks cannot be changed, but the frame-level features will
+ *  be enabled or disabled as requested.
+ *
+ * \param[in]  buf <tt>int</tt>: a non-zero value to enable VP3 compatibility,
+ *                   or 0 to disable it (the default).
+ * \param[out] buf <tt>int</tt>: 1 if all bitstream features required for
+ *                   VP3-compatibility could be set, and 0 otherwise.
+ *                  The latter will be returned if the pixel format is not
+ *                   4:2:0, the picture region is smaller than the full frame,
+ *                   or if encoding has begun, preventing the quantization
+ *                   tables and codebooks from being set.
+ * \retval TH_FAULT  \a theora_state or \a buf is <tt>NULL</tt>.
+ * \retval TH_EINVAL \a buf_sz is not <tt>sizeof(int)</tt>.
+ * \retval TH_IMPL   Not supported by this implementation.*/
+#define TH_ENCCTL_SET_VP3_COMPATIBLE (10)
+/**Gets the maximum speed level.
+ * Higher speed levels favor quicker encoding over better quality per bit.
+ * Depending on the encoding mode, and the internal algorithms used, quality
+ *  may actually improve, but in this case bitrate will also likely increase.
+ * In any case, overall rate/distortion performance will probably decrease.
+ * The maximum value, and the meaning of each value, may change depending on
+ *  the current encoding mode (VBR vs. CQI, etc.).
+ *
+ * \param[out] buf int: The maximum encoding speed level.
+ * \retval TH_FAULT  \a theora_state or \a buf is <tt>NULL</tt>.
+ * \retval TH_EINVAL \a buf_sz is not <tt>sizeof(int)</tt>.
+ * \retval TH_IMPL   Not supported by this implementation in the current
+ *                    encoding mode.*/
+#define TH_ENCCTL_GET_SPLEVEL_MAX (12)
+/**Sets the speed level.
+ * By default a speed value of 1 is used.
+ *
+ * \param[in] buf int: The new encoding speed level.
+ *                      0 is slowest, larger values use less CPU.
+ * \retval TH_FAULT  \a theora_state or \a buf is <tt>NULL</tt>.
+ * \retval TH_EINVAL \a buf_sz is not <tt>sizeof(int)</tt>, or the
+ *                    encoding speed level is out of bounds.
+ *                   The maximum encoding speed level may be
+ *                    implementation- and encoding mode-specific, and can be
+ *                    obtained via #TH_ENCCTL_GET_SPLEVEL_MAX.
+ * \retval TH_IMPL   Not supported by this implementation in the current
+ *                    encoding mode.*/
+#define TH_ENCCTL_SET_SPLEVEL (14)
+/*@}*/
+
+#define OC_FAULT       -1       /**< General failure */
+#define OC_EINVAL      -10      /**< Library encountered invalid internal data */
+#define OC_DISABLED    -11      /**< Requested action is disabled */
+#define OC_BADHEADER   -20      /**< Header packet was corrupt/invalid */
+#define OC_NOTFORMAT   -21      /**< Packet is not a theora packet */
+#define OC_VERSION     -22      /**< Bitstream version is not handled */
+#define OC_IMPL        -23      /**< Feature or action not implemented */
+#define OC_BADPACKET   -24      /**< Packet is corrupt */
+#define OC_NEWPACKET   -25      /**< Packet is an (ignorable) unhandled extension */
+#define OC_DUPFRAME    1        /**< Packet is a dropped frame */
+
+/** 
+ * Retrieve a human-readable string to identify the encoder vendor and version.
+ * \returns A version string.
+ */
+extern const char *theora_version_string(void);
+
+/**
+ * Retrieve a 32-bit version number.
+ * This number is composed of a 16-bit major version, 8-bit minor version
+ * and 8 bit sub-version, composed as follows:
+<pre>
+   (VERSION_MAJOR<<16) + (VERSION_MINOR<<8) + (VERSION_SUB)
+</pre>
+* \returns The version number.
+*/
+extern ogg_uint32_t theora_version_number(void);
+
+/**
+ * Initialize the theora encoder.
+ * \param th The theora_state handle to initialize for encoding.
+ * \param ti A theora_info struct filled with the desired encoding parameters.
+ * \retval 0 Success
+ */
+extern int theora_encode_init(theora_state *th, theora_info *ti);
+
+/**
+ * Submit a YUV buffer to the theora encoder.
+ * \param t A theora_state handle previously initialized for encoding.
+ * \param yuv A buffer of YUV data to encode.  Note that both the yuv_buffer
+ *            struct and the luma/chroma buffers within should be allocated by
+ *            the user.
+ * \retval OC_EINVAL Encoder is not ready, or is finished.
+ * \retval -1 The size of the given frame differs from those previously input
+ * \retval 0 Success
+ */
+extern int theora_encode_YUVin(theora_state *t, yuv_buffer *yuv);
+
+/**
+ * Request the next packet of encoded video. 
+ * The encoded data is placed in a user-provided ogg_packet structure.
+ * \param t A theora_state handle previously initialized for encoding.
+ * \param last_p whether this is the last packet the encoder should produce.
+ * \param op An ogg_packet structure to fill. libtheora will set all
+ *           elements of this structure, including a pointer to encoded
+ *           data. The memory for the encoded data is owned by libtheora.
+ * \retval 0 No internal storage exists OR no packet is ready
+ * \retval -1 The encoding process has completed
+ * \retval 1 Success
+ */
+extern int theora_encode_packetout( theora_state *t, int last_p,
+                                    ogg_packet *op);
+
+/**
+ * Request a packet containing the initial header.
+ * A pointer to the header data is placed in a user-provided ogg_packet
+ * structure.
+ * \param t A theora_state handle previously initialized for encoding.
+ * \param op An ogg_packet structure to fill. libtheora will set all
+ *           elements of this structure, including a pointer to the header
+ *           data. The memory for the header data is owned by libtheora.
+ * \retval 0 Success
+ */
+extern int theora_encode_header(theora_state *t, ogg_packet *op);
+
+/**
+ * Request a comment header packet from provided metadata.
+ * A pointer to the comment data is placed in a user-provided ogg_packet
+ * structure.
+ * \param tc A theora_comment structure filled with the desired metadata
+ * \param op An ogg_packet structure to fill. libtheora will set all
+ *           elements of this structure, including a pointer to the encoded
+ *           comment data. The memory for the comment data is owned by
+ *           libtheora.
+ * \retval 0 Success
+ */
+extern int theora_encode_comment(theora_comment *tc, ogg_packet *op);
+
+/**
+ * Request a packet containing the codebook tables for the stream.
+ * A pointer to the codebook data is placed in a user-provided ogg_packet
+ * structure.
+ * \param t A theora_state handle previously initialized for encoding.
+ * \param op An ogg_packet structure to fill. libtheora will set all
+ *           elements of this structure, including a pointer to the codebook
+ *           data. The memory for the header data is owned by libtheora.
+ * \retval 0 Success
+ */
+extern int theora_encode_tables(theora_state *t, ogg_packet *op);
+
+/**
+ * Decode an Ogg packet, with the expectation that the packet contains
+ * an initial header, comment data or codebook tables.
+ *
+ * \param ci A theora_info structure to fill. This must have been previously
+ *           initialized with theora_info_init(). If \a op contains an initial
+ *           header, theora_decode_header() will fill \a ci with the
+ *           parsed header values. If \a op contains codebook tables,
+ *           theora_decode_header() will parse these and attach an internal
+ *           representation to \a ci->codec_setup.
+ * \param cc A theora_comment structure to fill. If \a op contains comment
+ *           data, theora_decode_header() will fill \a cc with the parsed
+ *           comments.
+ * \param op An ogg_packet structure which you expect contains an initial
+ *           header, comment data or codebook tables.
+ *
+ * \retval OC_BADHEADER \a op is NULL; OR the first byte of \a op->packet
+ *                      has the signature of an initial packet, but op is
+ *                      not a b_o_s packet; OR this packet has the signature
+ *                      of an initial header packet, but an initial header
+ *                      packet has already been seen; OR this packet has the
+ *                      signature of a comment packet, but the initial header
+ *                      has not yet been seen; OR this packet has the signature
+ *                      of a comment packet, but contains invalid data; OR
+ *                      this packet has the signature of codebook tables,
+ *                      but the initial header or comments have not yet
+ *                      been seen; OR this packet has the signature of codebook
+ *                      tables, but contains invalid data;
+ *                      OR the stream being decoded has a compatible version
+ *                      but this packet does not have the signature of a
+ *                      theora initial header, comments, or codebook packet
+ * \retval OC_VERSION   The packet data of \a op is an initial header with
+ *                      a version which is incompatible with this version of
+ *                      libtheora.
+ * \retval OC_NEWPACKET the stream being decoded has an incompatible (future)
+ *                      version and contains an unknown signature.
+ * \retval 0            Success
+ *
+ * \note The normal usage is that theora_decode_header() be called on the
+ *       first three packets of a theora logical bitstream in succession.
+ */
+extern int theora_decode_header(theora_info *ci, theora_comment *cc,
+                                ogg_packet *op);
+
+/**
+ * Initialize a theora_state handle for decoding.
+ * \param th The theora_state handle to initialize.
+ * \param c  A theora_info struct filled with the desired decoding parameters.
+ *           This is of course usually obtained from a previous call to
+ *           theora_decode_header().
+ * \retval 0 Success
+ */
+extern int theora_decode_init(theora_state *th, theora_info *c);
+
+/**
+ * Input a packet containing encoded data into the theora decoder.
+ * \param th A theora_state handle previously initialized for decoding.
+ * \param op An ogg_packet containing encoded theora data.
+ * \retval 0 Success
+ * \retval OC_BADPACKET \a op does not contain encoded video data
+ */
+extern int theora_decode_packetin(theora_state *th,ogg_packet *op);
+
+/**
+ * Output the next available frame of decoded YUV data.
+ * \param th A theora_state handle previously initialized for decoding.
+ * \param yuv A yuv_buffer in which libtheora should place the decoded data.
+ *            Note that the buffer struct itself is allocated by the user, but
+ *            that the luma and chroma pointers will be filled in by the 
+ *            library.  Also note that these luma and chroma regions should be 
+ *            considered read-only by the user.
+ * \retval 0 Success
+ */
+extern int theora_decode_YUVout(theora_state *th,yuv_buffer *yuv);
+
+/**
+ * Report whether a theora packet is a header or not
+ * This function does no verification beyond checking the header
+ * flag bit so it should not be used for bitstream identification;
+ * use theora_decode_header() for that.
+ *
+ * \param op An ogg_packet containing encoded theora data.
+ * \retval 1 The packet is a header packet
+ * \retval 0 The packet is not a header packet (and so contains frame data)
+ *
+ * Thus function was added in the 1.0alpha4 release.
+ */
+extern int theora_packet_isheader(ogg_packet *op);
+
+/**
+ * Report whether a theora packet is a keyframe or not
+ *
+ * \param op An ogg_packet containing encoded theora data.
+ * \retval 1 The packet contains a keyframe image
+ * \retval 0 The packet is contains an interframe delta
+ * \retval -1 The packet is not an image data packet at all
+ *
+ * Thus function was added in the 1.0alpha4 release.
+ */
+extern int theora_packet_iskeyframe(ogg_packet *op);
+
+/**
+ * Report the granulepos shift radix
+ *
+ * When embedded in Ogg, Theora uses a two-part granulepos, 
+ * splitting the 64-bit field into two pieces. The more-significant
+ * section represents the frame count at the last keyframe,
+ * and the less-significant section represents the count of
+ * frames since the last keyframe. In this way the overall
+ * field is still non-decreasing with time, but usefully encodes
+ * a pointer to the last keyframe, which is necessary for
+ * correctly restarting decode after a seek. 
+ *
+ * This function reports the number of bits used to represent
+ * the distance to the last keyframe, and thus how the granulepos
+ * field must be shifted or masked to obtain the two parts.
+ * 
+ * Since libtheora returns compressed data in an ogg_packet
+ * structure, this may be generally useful even if the Theora
+ * packets are not being used in an Ogg container. 
+ *
+ * \param ti A previously initialized theora_info struct
+ * \returns The bit shift dividing the two granulepos fields
+ *
+ * This function was added in the 1.0alpha5 release.
+ */
+int theora_granule_shift(theora_info *ti);
+
+/**
+ * Convert a granulepos to an absolute frame index, starting at 0.
+ * The granulepos is interpreted in the context of a given theora_state handle.
+ * 
+ * Note that while the granulepos encodes the frame count (i.e. starting
+ * from 1) this call returns the frame index, starting from zero. Thus
+ * One can calculate the presentation time by multiplying the index by
+ * the rate.
+ *
+ * \param th A previously initialized theora_state handle (encode or decode)
+ * \param granulepos The granulepos to convert.
+ * \returns The frame index corresponding to \a granulepos.
+ * \retval -1 The given granulepos is undefined (i.e. negative)
+ *
+ * Thus function was added in the 1.0alpha4 release.
+ */
+extern ogg_int64_t theora_granule_frame(theora_state *th,ogg_int64_t granulepos);
+
+/**
+ * Convert a granulepos to absolute time in seconds. The granulepos is
+ * interpreted in the context of a given theora_state handle, and gives
+ * the end time of a frame's presentation as used in Ogg mux ordering.
+ *
+ * \param th A previously initialized theora_state handle (encode or decode)
+ * \param granulepos The granulepos to convert.
+ * \returns The absolute time in seconds corresponding to \a granulepos.
+ *          This is the "end time" for the frame, or the latest time it should
+ *           be displayed.
+ *          It is not the presentation time.
+ * \retval -1. The given granulepos is undefined (i.e. negative), or
+ * \retval -1. The function has been disabled because floating 
+ *              point support is not available.
+ */
+extern double theora_granule_time(theora_state *th,ogg_int64_t granulepos);
+
+/**
+ * Initialize a theora_info structure. All values within the given theora_info
+ * structure are initialized, and space is allocated within libtheora for
+ * internal codec setup data.
+ * \param c A theora_info struct to initialize.
+ */
+extern void theora_info_init(theora_info *c);
+
+/**
+ * Clear a theora_info structure. All values within the given theora_info
+ * structure are cleared, and associated internal codec setup data is freed.
+ * \param c A theora_info struct to initialize.
+ */
+extern void theora_info_clear(theora_info *c);
+
+/**
+ * Free all internal data associated with a theora_state handle.
+ * \param t A theora_state handle.
+ */
+extern void theora_clear(theora_state *t);
+
+/**
+ * Initialize an allocated theora_comment structure
+ * \param tc An allocated theora_comment structure 
+ **/
+extern void theora_comment_init(theora_comment *tc);
+
+/**
+ * Add a comment to an initialized theora_comment structure
+ * \param tc A previously initialized theora comment structure
+ * \param comment A null-terminated string encoding the comment in the form
+ *                "TAG=the value"
+ *
+ * Neither theora_comment_add() nor theora_comment_add_tag() support
+ * comments containing null values, although the bitstream format
+ * supports this. To add such comments you will need to manipulate
+ * the theora_comment structure directly.
+ **/
+
+extern void theora_comment_add(theora_comment *tc, char *comment);
+
+/**
+ * Add a comment to an initialized theora_comment structure.
+ * \param tc A previously initialized theora comment structure
+ * \param tag A null-terminated string containing the tag 
+ *            associated with the comment.
+ * \param value The corresponding value as a null-terminated string
+ *
+ * Neither theora_comment_add() nor theora_comment_add_tag() support
+ * comments containing null values, although the bitstream format
+ * supports this. To add such comments you will need to manipulate
+ * the theora_comment structure directly.
+ **/
+extern void theora_comment_add_tag(theora_comment *tc,
+                                       char *tag, char *value);
+
+/**
+ * Look up a comment value by tag.
+ * \param tc Tn initialized theora_comment structure
+ * \param tag The tag to look up
+ * \param count The instance of the tag. The same tag can appear multiple
+ *              times, each with a distinct and ordered value, so an index
+ *              is required to retrieve them all.
+ * \returns A pointer to the queried tag's value
+ * \retval NULL No matching tag is found
+ *
+ * \note Use theora_comment_query_count() to get the legal range for the
+ * count parameter.
+ **/
+
+extern char *theora_comment_query(theora_comment *tc, char *tag, int count);
+
+/** Look up the number of instances of a tag.
+ *  \param tc An initialized theora_comment structure
+ *  \param tag The tag to look up
+ *  \returns The number on instances of a particular tag.
+ * 
+ *  Call this first when querying for a specific tag and then interate
+ *  over the number of instances with separate calls to 
+ *  theora_comment_query() to retrieve all instances in order.
+ **/
+extern int   theora_comment_query_count(theora_comment *tc, char *tag);
+
+/**
+ * Clear an allocated theora_comment struct so that it can be freed.
+ * \param tc An allocated theora_comment structure.
+ **/
+extern void  theora_comment_clear(theora_comment *tc);
+
+/**Encoder control function.
+ * This is used to provide advanced control the encoding process.
+ * \param th     A #theora_state handle.
+ * \param req    The control code to process.
+ *                See \ref encctlcodes "the list of available control codes"
+ *                 for details.
+ * \param buf    The parameters for this control code.
+ * \param buf_sz The size of the parameter buffer.*/
+extern int theora_control(theora_state *th,int req,void *buf,size_t buf_sz);
+
+/* @} */ /* end oldfuncs doxygen group */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* _O_THEORA_H_ */
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/ogg_vorbis/theora/theoradec.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/ogg_vorbis/theora/theoradec.h	Mon Jul 06 04:07:05 2009 +0800
@@ -0,0 +1,307 @@
+/********************************************************************
+ *                                                                  *
+ * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE.   *
+ * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
+ * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
+ * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
+ *                                                                  *
+ * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2007                *
+ * by the Xiph.Org Foundation http://www.xiph.org/                  *
+ *                                                                  *
+ ********************************************************************
+
+  function:
+  last mod: $Id: theora.h,v 1.8 2004/03/15 22:17:32 derf Exp $
+
+ ********************************************************************/
+
+/**\file
+ * The <tt>libtheoradec</tt> C decoding API.*/
+
+#if !defined(_O_THEORA_THEORADEC_H_)
+# define _O_THEORA_THEORADEC_H_ (1)
+# include <stddef.h>
+# include <ogg/ogg.h>
+# include "codec.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+
+/**\name th_decode_ctl() codes
+ * \anchor decctlcodes
+ * These are the available request codes for th_decode_ctl().
+ * By convention, these are odd, to distinguish them from the
+ *  \ref encctlcodes "encoder control codes".
+ * Keep any experimental or vendor-specific values above \c 0x8000.*/
+/*@{*/
+/**Gets the maximum post-processing level.
+ *
+ * \param[out] _buf int: The maximum post-processing level.
+ * \retval TH_EFAULT  \a _dec_ctx or \a _buf is <tt>NULL</tt>.
+ * \retval TH_EINVAL  \a _buf_sz is not <tt>sizeof(int)</tt>.
+ * \retval TH_EIMPL   Not supported by this implementation.*/
+#define TH_DECCTL_GET_PPLEVEL_MAX (1)
+/**Sets the post-processing level.
+ * By default, post-processing is disabled.
+ *
+ * \param[in] _buf int: The new post-processing level.
+ *                      0 to disable; larger values use more CPU.
+ * \retval TH_EFAULT  \a _dec_ctx or \a _buf is <tt>NULL</tt>.
+ * \retval TH_EINVAL  \a _buf_sz is not <tt>sizeof(int)</tt>, or the
+ *                     post-processing level is out of bounds.
+ *                    The maximum post-processing level may be
+ *                     implementation-specific, and can be obtained via
+ *                     #TH_DECCTL_GET_PPLEVEL_MAX.
+ * \retval TH_EIMPL   Not supported by this implementation.*/
+#define TH_DECCTL_SET_PPLEVEL (3)
+/**Sets the granule position.
+ * Call this after a seek, before decoding the first frame, to ensure that the
+ *  proper granule position is returned for all subsequent frames.
+ * If you track timestamps yourself and do not use the granule position
+ *  returned by the decoder, then you need not call this function.
+ *
+ * \param[in] _buf <tt>ogg_int64_t</tt>: The granule position of the next
+ *                  frame.
+ * \retval TH_EFAULT  \a _dec_ctx or \a _buf is <tt>NULL</tt>.
+ * \retval TH_EINVAL  \a _buf_sz is not <tt>sizeof(ogg_int64_t)</tt>, or the
+ *                     granule position is negative.*/
+#define TH_DECCTL_SET_GRANPOS (5)
+/**Sets the striped decode callback function.
+ * If set, this function will be called as each piece of a frame is fully
+ *  decoded in th_decode_packetin().
+ * You can pass in a #th_stripe_callback with
+ *  th_stripe_callback#stripe_decoded set to <tt>NULL</tt> to disable the
+ *  callbacks at any point.
+ * Enabling striped decode does not prevent you from calling
+ *  th_decode_ycbcr_out() after the frame is fully decoded.
+ *
+ * \param[in]  _buf #th_stripe_callback: The callback parameters.
+ * \retval TH_EFAULT  \a _dec_ctx or \a _buf is <tt>NULL</tt>.
+ * \retval TH_EINVAL  \a _buf_sz is not
+ *                     <tt>sizeof(th_stripe_callback)</tt>.*/
+#define TH_DECCTL_SET_STRIPE_CB (7)
+/*@}*/
+
+
+
+/**A callback function for striped decode.
+ * This is a function pointer to an application-provided function that will be
+ *  called each time a section of the image is fully decoded in
+ *  th_decode_packetin().
+ * This allows the application to process the section immediately, while it is
+ *  still in cache.
+ * Note that the frame is decoded bottom to top, so \a _yfrag0 will steadily
+ *  decrease with each call until it reaches 0, at which point the full frame
+ *  is decoded.
+ * The number of fragment rows made available in each call depends on the pixel
+ *  format and the number of post-processing filters enabled, and may not even
+ *  be constant for the entire frame.
+ * If a non-<tt>NULL</tt> \a _granpos pointer is passed to
+ *  th_decode_packetin(), the granule position for the frame will be stored
+ *  in it before the first callback is made.
+ * If an entire frame is dropped (a 0-byte packet), then no callbacks will be
+ *  made at all for that frame.
+ * \param _ctx       An application-provided context pointer.
+ * \param _buf       The image buffer for the decoded frame.
+ * \param _yfrag0    The Y coordinate of the first row of 8x8 fragments
+ *                    decoded.
+ *                   Multiply this by 8 to obtain the pixel row number in the
+ *                    luma plane.
+ *                   If the chroma planes are subsampled in the Y direction,
+ *                    this will always be divisible by two.
+ * \param _yfrag_end The Y coordinate of the first row of 8x8 fragments past
+ *                    the newly decoded section.
+ *                   If the chroma planes are subsampled in the Y direction,
+ *                    this will always be divisible by two.
+ *                   I.e., this section contains fragment rows
+ *                    <tt>\a _yfrag0 ...\a _yfrag_end -1</tt>.*/
+typedef void (*th_stripe_decoded_func)(void *_ctx,th_ycbcr_buffer _buf,
+ int _yfrag0,int _yfrag_end);
+
+/**The striped decode callback data to pass to #TH_DECCTL_SET_STRIPE_CB.*/
+typedef struct{
+  /**An application-provided context pointer.
+   * This will be passed back verbatim to the application.*/
+  void                   *ctx;
+  /**The callback function pointer.*/
+  th_stripe_decoded_func  stripe_decoded;
+}th_stripe_callback;
+
+
+
+/**\name Decoder state
+   The following data structures are opaque, and their contents are not
+    publicly defined by this API.
+   Referring to their internals directly is unsupported, and may break without
+    warning.*/
+/*@{*/
+/**The decoder context.*/
+typedef struct th_dec_ctx    th_dec_ctx;
+/**Setup information.
+   This contains auxiliary information (Huffman tables and quantization
+    parameters) decoded from the setup header by th_decode_headerin() to be
+    passed to th_decode_alloc().
+   It can be re-used to initialize any number of decoders, and can be freed
+    via th_setup_free() at any time.*/
+typedef struct th_setup_info th_setup_info;
+/*@}*/
+
+
+
+/**\defgroup decfuncs Functions for Decoding*/
+/*@{*/
+/**\name Functions for decoding
+ * You must link to <tt>libtheoradec</tt> if you use any of the 
+ * functions in this section.
+ *
+ * The functions are listed in the order they are used in a typical decode.
+ * The basic steps are:
+ * - Parse the header packets by repeatedly calling th_decode_headerin().
+ * - Allocate a #th_dec_ctx handle with th_decode_alloc().
+ * - Call th_setup_free() to free any memory used for codec setup
+ *    information.
+ * - Perform any additional decoder configuration with th_decode_ctl().
+ * - For each video data packet:
+ *   - Submit the packet to the decoder via th_decode_packetin().
+ *   - Retrieve the uncompressed video data via th_decode_ycbcr_out().
+ * - Call th_decode_free() to release all decoder memory.*/
+/*@{*/
+/**Decodes the header packets of a Theora stream.
+ * This should be called on the initial packets of the stream, in succession,
+ *  until it returns <tt>0</tt>, indicating that all headers have been
+ *  processed, or an error is encountered.
+ * At least three header packets are required, and additional optional header
+ *  packets may follow.
+ * This can be used on the first packet of any logical stream to determine if
+ *  that stream is a Theora stream.
+ * \param _info  A #th_info structure to fill in.
+ *               This must have been previously initialized with
+ *                th_info_init().
+ *               The application may immediately begin using the contents of
+ *                this structure after the first header is decoded, though it
+ *                must continue to be passed in on all subsequent calls.
+ * \param _tc    A #th_comment structure to fill in.
+ *               The application may immediately begin using the contents of
+ *                this structure after the second header is decoded, though it
+ *                must continue to be passed in on all subsequent calls.
+ * \param _setup Returns a pointer to additional, private setup information
+ *                needed by the decoder.
+ *               The contents of this pointer must be initialized to
+ *                <tt>NULL</tt> on the first call, and the returned value must
+ *                continue to be passed in on all subsequent calls.
+ * \param _op    An <tt>ogg_packet</tt> structure which contains one of the
+ *                initial packets of an Ogg logical stream.
+ * \return A positive value indicates that a Theora header was successfully
+ *          processed.
+ * \retval 0             The first video data packet was encountered after all
+ *                        required header packets were parsed.
+ *                       The packet just passed in on this call should be saved
+ *                        and fed to th_decode_packetin() to begin decoding
+ *                        video data.
+ * \retval TH_EFAULT     One of \a _info, \a _tc, or \a _setup was
+ *                        <tt>NULL</tt>.
+ * \retval TH_EBADHEADER \a _op was <tt>NULL</tt>, the packet was not the next
+ *                        header packet in the expected sequence, or the format
+ *                        of the header data was invalid.
+ * \retval TH_EVERSION   The packet data was a Theora info header, but for a
+ *                        bitstream version not decodable with this version of
+ *                        <tt>libtheoradec</tt>.
+ * \retval TH_ENOTFORMAT The packet was not a Theora header.
+ */
+extern int th_decode_headerin(th_info *_info,th_comment *_tc,
+ th_setup_info **_setup,ogg_packet *_op);
+/**Allocates a decoder instance.
+ *
+ * <b>Security Warning:</b> The Theora format supports very large frame sizes,
+ *  potentially even larger than the address space of a 32-bit machine, and
+ *  creating a decoder context allocates the space for several frames of data.
+ * If the allocation fails here, your program will crash, possibly at some
+ *  future point because the OS kernel returned a valid memory range and will
+ *  only fail when it tries to map the pages in it the first time they are
+ *  used.
+ * Even if it succeeds, you may experience a denial of service if the frame
+ *  size is large enough to cause excessive paging.
+ * If you are integrating libtheora in a larger application where such things
+ *  are undesirable, it is highly recommended that you check the frame size in
+ *  \a _info before calling this function and refuse to decode streams where it
+ *  is larger than some reasonable maximum.
+ * libtheora will not check this for you, because there may be machines that
+ *  can handle such streams and applications that wish to.
+ * \param _info  A #th_info struct filled via th_decode_headerin().
+ * \param _setup A #th_setup_info handle returned via
+ *                th_decode_headerin().
+ * \return The initialized #th_dec_ctx handle.
+ * \retval NULL If the decoding parameters were invalid.*/
+extern th_dec_ctx *th_decode_alloc(const th_info *_info,
+ const th_setup_info *_setup);
+/**Releases all storage used for the decoder setup information.
+ * This should be called after you no longer want to create any decoders for
+ *  a stream whose headers you have parsed with th_decode_headerin().
+ * \param _setup The setup information to free.
+ *               This can safely be <tt>NULL</tt>.*/
+extern void th_setup_free(th_setup_info *_setup);
+/**Decoder control function.
+ * This is used to provide advanced control of the decoding process.
+ * \param _dec    A #th_dec_ctx handle.
+ * \param _req    The control code to process.
+ *                See \ref decctlcodes "the list of available control codes"
+ *                 for details.
+ * \param _buf    The parameters for this control code.
+ * \param _buf_sz The size of the parameter buffer.*/
+extern int th_decode_ctl(th_dec_ctx *_dec,int _req,void *_buf,
+ size_t _buf_sz);
+/**Submits a packet containing encoded video data to the decoder.
+ * \param _dec     A #th_dec_ctx handle.
+ * \param _op      An <tt>ogg_packet</tt> containing encoded video data.
+ * \param _granpos Returns the granule position of the decoded packet.
+ *                 If non-<tt>NULL</tt>, the granule position for this specific
+ *                  packet is stored in this location.
+ *                 This is computed incrementally from previously decoded
+ *                  packets.
+ *                 After a seek, the correct granule position must be set via
+ *                  #TH_DECCTL_SET_GRANPOS for this to work properly.
+ * \retval 0             Success.
+ *                       A new decoded frame can be retrieved by calling
+ *                        th_decode_ycbcr_out().
+ * \retval TH_DUPFRAME   The packet represented a dropped (0-byte) frame.
+ *                       The player can skip the call to th_decode_ycbcr_out(),
+ *                        as the contents of the decoded frame buffer have not
+ *                        changed.
+ * \retval TH_EFAULT     \a _dec or \a _op was <tt>NULL</tt>.
+ * \retval TH_EBADPACKET \a _op does not contain encoded video data.
+ * \retval TH_EIMPL      The video data uses bitstream features which this
+ *                        library does not support.*/
+extern int th_decode_packetin(th_dec_ctx *_dec,const ogg_packet *_op,
+ ogg_int64_t *_granpos);
+/**Outputs the next available frame of decoded Y'CbCr data.
+ * If a striped decode callback has been set with #TH_DECCTL_SET_STRIPE_CB,
+ *  then the application does not need to call this function.
+ * \param _dec   A #th_dec_ctx handle.
+ * \param _ycbcr A video buffer structure to fill in.
+ *               <tt>libtheoradec</tt> will fill in all the members of this
+ *                structure, including the pointers to the uncompressed video
+ *                data.
+ *               The memory for this video data is owned by
+ *                <tt>libtheoradec</tt>.
+ *               It may be freed or overwritten without notification when
+ *                subsequent frames are decoded.
+ * \retval 0 Success
+ */
+extern int th_decode_ycbcr_out(th_dec_ctx *_dec,
+ th_ycbcr_buffer _ycbcr);
+/**Frees an allocated decoder instance.
+ * \param _dec A #th_dec_ctx handle.*/
+extern void th_decode_free(th_dec_ctx *_dec);
+/*@}*/
+/*@}*/
+
+
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/ogg_vorbis/vorbis/codec.h
--- a/src/ogg_vorbis/vorbis/codec.h	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/ogg_vorbis/vorbis/codec.h	Mon Jul 06 04:07:05 2009 +0800
@@ -11,7 +11,7 @@
  ********************************************************************
 
  function: libvorbis codec headers
- last mod: $Id: codec.h 13571 2007-08-19 09:36:24Z erikd $
+ last mod: $Id: codec.h 16037 2009-05-26 21:10:58Z xiphmont $
 
  ********************************************************************/
 
@@ -168,7 +168,7 @@
 extern void     vorbis_comment_init(vorbis_comment *vc);
 extern void     vorbis_comment_add(vorbis_comment *vc, const char *comment);
 extern void     vorbis_comment_add_tag(vorbis_comment *vc,
-				       const char *tag, const char *contents);
+                                       const char *tag, const char *contents);
 extern char    *vorbis_comment_query(vorbis_comment *vc, const char *tag, int count);
 extern int      vorbis_comment_query_count(vorbis_comment *vc, const char *tag);
 extern void     vorbis_comment_clear(vorbis_comment *vc);
@@ -177,17 +177,19 @@
 extern int      vorbis_block_clear(vorbis_block *vb);
 extern void     vorbis_dsp_clear(vorbis_dsp_state *v);
 extern double   vorbis_granule_time(vorbis_dsp_state *v,
-				    ogg_int64_t granulepos);
+                                    ogg_int64_t granulepos);
+
+extern const char *vorbis_version_string(void);
 
 /* Vorbis PRIMITIVES: analysis/DSP layer ****************************/
 
 extern int      vorbis_analysis_init(vorbis_dsp_state *v,vorbis_info *vi);
 extern int      vorbis_commentheader_out(vorbis_comment *vc, ogg_packet *op);
 extern int      vorbis_analysis_headerout(vorbis_dsp_state *v,
-					  vorbis_comment *vc,
-					  ogg_packet *op,
-					  ogg_packet *op_comm,
-					  ogg_packet *op_code);
+                                          vorbis_comment *vc,
+                                          ogg_packet *op,
+                                          ogg_packet *op_comm,
+                                          ogg_packet *op_code);
 extern float  **vorbis_analysis_buffer(vorbis_dsp_state *v,int vals);
 extern int      vorbis_analysis_wrote(vorbis_dsp_state *v,int vals);
 extern int      vorbis_analysis_blockout(vorbis_dsp_state *v,vorbis_block *vb);
@@ -195,12 +197,12 @@
 
 extern int      vorbis_bitrate_addblock(vorbis_block *vb);
 extern int      vorbis_bitrate_flushpacket(vorbis_dsp_state *vd,
-					   ogg_packet *op);
+                                           ogg_packet *op);
 
 /* Vorbis PRIMITIVES: synthesis layer *******************************/
 extern int      vorbis_synthesis_idheader(ogg_packet *op);
 extern int      vorbis_synthesis_headerin(vorbis_info *vi,vorbis_comment *vc,
-					  ogg_packet *op);
+                                          ogg_packet *op);
 
 extern int      vorbis_synthesis_init(vorbis_dsp_state *v,vorbis_info *vi);
 extern int      vorbis_synthesis_restart(vorbis_dsp_state *v);
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/ogg_vorbis/vorbis/vorbisfile.h
--- a/src/ogg_vorbis/vorbis/vorbisfile.h	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/ogg_vorbis/vorbis/vorbisfile.h	Mon Jul 06 04:07:05 2009 +0800
@@ -11,7 +11,7 @@
  ********************************************************************
 
  function: stdio-based convenience library for opening/seeking/decoding
- last mod: $Id: vorbisfile.h 14771 2008-04-17 18:21:55Z xiphmont $
+ last mod: $Id: vorbisfile.h 16037 2009-05-26 21:10:58Z xiphmont $
 
  ********************************************************************/
 
@@ -50,18 +50,28 @@
 
 static int _ov_header_fseek_wrap(FILE *f,ogg_int64_t off,int whence){
   if(f==NULL)return(-1);
+
+#ifdef __MINGW32__
+  return fseeko64(f,off,whence);
+#elif defined (_WIN32)
+  return _fseeki64(f,off,whence);
+#else
   return fseek(f,off,whence);
+#endif
 }
 
 /* These structs below (OV_CALLBACKS_DEFAULT etc) are defined here as
  * static data. That means that every file which includes this header
  * will get its own copy of these structs whether it uses them or
- * not. This is essential on platforms such as Windows on which
- * several different versions of stdio support may be linked to by
- * different DLLs, and we need to be certain we know which one we're
- * using (the same one as the main application).
+ * not unless it #defines OV_EXCLUDE_STATIC_CALLBACKS.
+ * These static symbols are essential on platforms such as Windows on
+ * which several different versions of stdio support may be linked to
+ * by different DLLs, and we need to be certain we know which one
+ * we're using (the same one as the main application).
  */
 
+#ifndef OV_EXCLUDE_STATIC_CALLBACKS
+
 static ov_callbacks OV_CALLBACKS_DEFAULT = {
   (size_t (*)(void *, size_t, size_t, void *))  fread,
   (int (*)(void *, ogg_int64_t, int))           _ov_header_fseek_wrap,
@@ -90,6 +100,8 @@
   (long (*)(void *))                            NULL
 };
 
+#endif
+
 #define  NOTOPEN   0
 #define  PARTOPEN  1
 #define  OPENED    2
@@ -110,8 +122,8 @@
   ogg_int64_t     *dataoffsets;
   long            *serialnos;
   ogg_int64_t     *pcmlengths; /* overloaded to maintain binary
-				  compatability; x2 size, stores both
-				  beginning and end values */
+                                  compatability; x2 size, stores both
+                                  beginning and end values */
   vorbis_info     *vi;
   vorbis_comment  *vc;
 
@@ -138,11 +150,11 @@
 extern int ov_fopen(char *path,OggVorbis_File *vf);
 extern int ov_open(FILE *f,OggVorbis_File *vf,char *initial,long ibytes);
 extern int ov_open_callbacks(void *datasource, OggVorbis_File *vf,
-		char *initial, long ibytes, ov_callbacks callbacks);
+                char *initial, long ibytes, ov_callbacks callbacks);
 
 extern int ov_test(FILE *f,OggVorbis_File *vf,char *initial,long ibytes);
 extern int ov_test_callbacks(void *datasource, OggVorbis_File *vf,
-		char *initial, long ibytes, ov_callbacks callbacks);
+                char *initial, long ibytes, ov_callbacks callbacks);
 extern int ov_test_open(OggVorbis_File *vf);
 
 extern long ov_bitrate(OggVorbis_File *vf,int i);
@@ -175,12 +187,12 @@
 extern vorbis_comment *ov_comment(OggVorbis_File *vf,int link);
 
 extern long ov_read_float(OggVorbis_File *vf,float ***pcm_channels,int samples,
-			  int *bitstream);
+                          int *bitstream);
 extern long ov_read_filter(OggVorbis_File *vf,char *buffer,int length,
-			  int bigendianp,int word,int sgned,int *bitstream,
-			  void (*filter)(float **pcm,long channels,long samples,void *filter_param),void *filter_param);
+                          int bigendianp,int word,int sgned,int *bitstream,
+                          void (*filter)(float **pcm,long channels,long samples,void *filter_param),void *filter_param);
 extern long ov_read(OggVorbis_File *vf,char *buffer,int length,
-		    int bigendianp,int word,int sgned,int *bitstream);
+                    int bigendianp,int word,int sgned,int *bitstream);
 extern int ov_crosslap(OggVorbis_File *vf1,OggVorbis_File *vf2);
 
 extern int ov_halfrate(OggVorbis_File *vf,int flag);
@@ -192,4 +204,3 @@
 
 #endif
 
-
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/qcommon/common.c
--- a/src/qcommon/common.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/qcommon/common.c	Mon Jul 06 04:07:05 2009 +0800
@@ -45,8 +45,6 @@
 #define MIN_COMHUNKMEGS		128
 #define DEF_COMHUNKMEGS		128
 #define DEF_COMZONEMEGS		24
-#define XSTRING(x)				STRING(x)
-#define STRING(x)					#x
 #define DEF_COMHUNKMEGS_S	XSTRING(DEF_COMHUNKMEGS)
 #define DEF_COMZONEMEGS_S	XSTRING(DEF_COMZONEMEGS)
 
@@ -2108,6 +2106,21 @@
 	}
 }
 
+/*
+=================
+Com_InitRand
+Seed the random number generator, if possible with an OS supplied random seed.
+=================
+*/
+static void Com_InitRand(void)
+{
+	unsigned int seed;
+
+	if(Sys_RandomBytes((byte *) &seed, sizeof(seed)))
+		srand(seed);
+	else
+		srand(time(NULL));
+}
 
 /*
 =================
@@ -2443,8 +2456,11 @@
 	Com_Memset( &eventQueue[ 0 ], 0, MAX_QUEUED_EVENTS * sizeof( sysEvent_t ) );
 	Com_Memset( &sys_packetReceived[ 0 ], 0, MAX_MSGLEN * sizeof( byte ) );
 
-  // do this before anything else decides to push events
-  Com_InitPushEvent();
+	// initialize the weak pseudo-random number generator for use later.
+	Com_InitRand();
+
+	// do this before anything else decides to push events
+	Com_InitPushEvent();
 
 	Com_InitSmallZoneMemory();
 	Cvar_Init ();
@@ -3299,7 +3315,6 @@
 		return;
 
 	Com_Printf( "Com_RandomBytes: using weak randomization\n" );
-	srand( time( 0 ) );
 	for( i = 0; i < len; i++ )
 		string[i] = (unsigned char)( rand() % 255 );
 }
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/qcommon/cvar.c
--- a/src/qcommon/cvar.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/qcommon/cvar.c	Mon Jul 06 04:07:05 2009 +0800
@@ -306,9 +306,9 @@
 	cvar_t	*var;
 	long	hash;
 
-  if ( !var_name || ! var_value ) {
+	if ( !var_name || ! var_value ) {
 		Com_Error( ERR_FATAL, "Cvar_Get: NULL parameter" );
-  }
+	}
 
 	if ( !Cvar_ValidateString( var_name ) ) {
 		Com_Printf("invalid cvar name string: %s\n", var_name );
@@ -662,15 +662,15 @@
 	// set all default vars to the safe value
 	for ( var = cvar_vars ; var ; var = var->next ) {
 		if ( var->flags & CVAR_CHEAT ) {
-      // the CVAR_LATCHED|CVAR_CHEAT vars might escape the reset here 
-      // because of a different var->latchedString
-      if (var->latchedString)
-      {
-        Z_Free(var->latchedString);
-        var->latchedString = NULL;
-      }
+			// the CVAR_LATCHED|CVAR_CHEAT vars might escape the reset here 
+			// because of a different var->latchedString
+			if (var->latchedString)
+			{
+				Z_Free(var->latchedString);
+				var->latchedString = NULL;
+			}
 			if (strcmp(var->resetString,var->string)) {
-        Cvar_Set( var->name, var->resetString );
+				Cvar_Set( var->name, var->resetString );
 			}
 		}
 	}
@@ -927,6 +927,11 @@
 		} else {
 			Com_Printf(" ");
 		}
+		if (var->flags & CVAR_SYSTEMINFO) {
+			Com_Printf("s");
+		} else {
+			Com_Printf(" ");
+		}
 		if (var->flags & CVAR_USERINFO) {
 			Com_Printf("U");
 		} else {
@@ -957,6 +962,11 @@
 		} else {
 			Com_Printf(" ");
 		}
+		if (var->flags & CVAR_USER_CREATED) {
+			Com_Printf("?");
+		} else {
+			Com_Printf(" ");
+		}
 
 		Com_Printf (" %s \"%s\"\n", var->name, var->string);
 	}
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/qcommon/net_ip.c
--- a/src/qcommon/net_ip.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/qcommon/net_ip.c	Mon Jul 06 04:07:05 2009 +0800
@@ -92,13 +92,6 @@
 static qboolean usingSocks = qfalse;
 static int networkingEnabled = 0;
 
-#define NET_ENABLEV4		0x01
-#define NET_ENABLEV6		0x02
-// if this flag is set, always attempt ipv6 connections instead of ipv4 if a v6 address is found.
-#define NET_PRIOV6		0x04
-// disables ipv6 multicast support if set.
-#define NET_DISABLEMCAST	0x08
-
 static cvar_t	*net_enabled;
 
 static cvar_t	*net_socksEnabled;
@@ -284,8 +277,6 @@
 	hintsp = &hints;
 	hintsp->ai_family = family;
 	hintsp->ai_socktype = SOCK_DGRAM;
-	// FIXME: we should set "->ai_flags" to AI_PASSIVE if we intend
-	//        to use this structure for a bind() - instead of a sendto()
 	
 	retval = getaddrinfo(s, NULL, hintsp, &res);
 
@@ -294,18 +285,20 @@
 		if(family == AF_UNSPEC)
 		{
 			// Decide here and now which protocol family to use
-			if((net_enabled->integer & NET_ENABLEV6) && (net_enabled->integer & NET_PRIOV6))
-				search = SearchAddrInfo(res, AF_INET6);
+			if(net_enabled->integer & NET_PRIOV6)
+			{
+				if(net_enabled->integer & NET_ENABLEV6)
+					search = SearchAddrInfo(res, AF_INET6);
+				
+				if(!search && (net_enabled->integer & NET_ENABLEV4))
+					search = SearchAddrInfo(res, AF_INET);
+			}
 			else
-				search = SearchAddrInfo(res, AF_INET);
-			
-			if(!search)
 			{
-				if((net_enabled->integer & NET_ENABLEV6) &&
-				   (net_enabled->integer & NET_PRIOV6) &&
-				   (net_enabled->integer & NET_ENABLEV4))
+				if(net_enabled->integer & NET_ENABLEV4)
 					search = SearchAddrInfo(res, AF_INET);
-				else if(net_enabled->integer & NET_ENABLEV6)
+				
+				if(!search && (net_enabled->integer & NET_ENABLEV6))
 					search = SearchAddrInfo(res, AF_INET6);
 			}
 		}
@@ -382,47 +375,95 @@
 
 /*
 ===================
-NET_CompareBaseAdr
+NET_CompareBaseAdrMask
 
-Compares without the port
+Compare without port, and up to the bit number given in netmask.
 ===================
 */
-qboolean	NET_CompareBaseAdr (netadr_t a, netadr_t b)
+qboolean NET_CompareBaseAdrMask(netadr_t a, netadr_t b, int netmask)
 {
+	qboolean differed;
+	byte cmpmask, *addra, *addrb;
+	int curbyte;
+	
 	if (a.type != b.type)
 		return qfalse;
 
 	if (a.type == NA_LOOPBACK)
 		return qtrue;
 
-	if (a.type == NA_IP)
+	if(a.type == NA_IP)
 	{
-		if(!memcmp(a.ip, b.ip, sizeof(a.ip)))
-			return qtrue;
+		addra = (byte *) &a.ip;
+		addrb = (byte *) &b.ip;
 		
-		return qfalse;
+		if(netmask < 0 || netmask > 32)
+			netmask = 32;
 	}
-	
-	if (a.type == NA_IP6)
+	else if(a.type == NA_IP6)
 	{
-		if(!memcmp(a.ip6, b.ip6, sizeof(a.ip6)) && a.scope_id == b.scope_id)
-				  return qtrue;
+		addra = (byte *) &a.ip6;
+		addrb = (byte *) &b.ip6;
 		
+		if(netmask < 0 || netmask > 128)
+			netmask = 128;
+	}
+	else
+	{
+		Com_Printf ("NET_CompareBaseAdr: bad address type\n");
 		return qfalse;
 	}
 
-	Com_Printf ("NET_CompareBaseAdr: bad address type\n");
+	differed = qfalse;
+	curbyte = 0;
+
+	while(netmask > 7)
+	{
+		if(addra[curbyte] != addrb[curbyte])
+		{
+			differed = qtrue;
+			break;
+		}
+
+		curbyte++;
+		netmask -= 8;
+	}
+
+	if(differed)
+		return qfalse;
+
+	if(netmask)
+	{
+		cmpmask = (1 << netmask) - 1;
+		cmpmask <<= 8 - netmask;
+
+		if((addra[curbyte] & cmpmask) == (addrb[curbyte] & cmpmask))
+			return qtrue;
+	}
+	else
+		return qtrue;
+	
 	return qfalse;
 }
 
+/*
+===================
+NET_CompareBaseAdr
+
+Compares without the port
+===================
+*/
+qboolean NET_CompareBaseAdr (netadr_t a, netadr_t b)
+{
+	return NET_CompareBaseAdrMask(a, b, -1);
+}
+
 const char	*NET_AdrToString (netadr_t a)
 {
 	static	char	s[NET_ADDRSTRMAXLEN];
 
 	if (a.type == NA_LOOPBACK)
-	{
 		Com_sprintf (s, sizeof(s), "loopback");
-	}
 	else if (a.type == NA_IP || a.type == NA_IP6)
 	{
 		struct sockaddr_storage sadr;
@@ -440,16 +481,11 @@
 	static	char	s[NET_ADDRSTRMAXLEN];
 
 	if (a.type == NA_LOOPBACK)
-	{
 		Com_sprintf (s, sizeof(s), "loopback");
-	}
-	else if (a.type == NA_IP || a.type == NA_IP6)
-	{
-		if(a.type == NA_IP)
-			Com_sprintf(s, sizeof(s), "%s:%hu", NET_AdrToString(a), ntohs(a.port));
-		else if(a.type == NA_IP6)
-			Com_sprintf(s, sizeof(s), "[%s]:%hu", NET_AdrToString(a), ntohs(a.port));
-	}
+	else if(a.type == NA_IP)
+		Com_sprintf(s, sizeof(s), "%s:%hu", NET_AdrToString(a), ntohs(a.port));
+	else if(a.type == NA_IP6)
+		Com_sprintf(s, sizeof(s), "[%s]:%hu", NET_AdrToString(a), ntohs(a.port));
 
 	return s;
 }
@@ -886,7 +922,7 @@
 
 #ifdef IPV6_V6ONLY
 	{
-		int i;
+		int i = 1;
 
 		// ipv4 addresses should not be allowed to connect via this socket.
 		if(setsockopt(newsocket, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &i, sizeof(i)) == SOCKET_ERROR)
@@ -1278,9 +1314,6 @@
 	char				hostname[256];
 	struct addrinfo		hint;
 	struct addrinfo 	*res = NULL;
-	struct addrinfo 	*search;
-	struct sockaddr_in mask4;
-	struct sockaddr_in6 mask6;
 
 	if(gethostname( hostname, 256 ) == SOCKET_ERROR)
 		return;
@@ -1292,29 +1325,36 @@
 	hint.ai_family = AF_UNSPEC;
 	hint.ai_socktype = SOCK_DGRAM;
 	
-	if(getaddrinfo(hostname, NULL, &hint, &res))
- 		return;
+	if(!getaddrinfo(hostname, NULL, &hint, &res))
+	{
+		struct sockaddr_in mask4;
+		struct sockaddr_in6 mask6;
+		struct addrinfo 	*search;
+	
+		/* On operating systems where it's more difficult to find out the configured interfaces, we'll just assume a
+		 * netmask with all bits set. */
+	
+		memset(&mask4, 0, sizeof(mask4));
+		memset(&mask6, 0, sizeof(mask6));
+		mask4.sin_family = AF_INET;
+		memset(&mask4.sin_addr.s_addr, 0xFF, sizeof(mask4.sin_addr.s_addr));
+		mask6.sin6_family = AF_INET6;
+		memset(&mask6.sin6_addr, 0xFF, sizeof(mask6.sin6_addr));
 
-	/* On operating systems where it's more difficult to find out the configured interfaces, we'll just assume a
-	 * netmask with all bits set. */
+		// add all IPs from returned list.
+		for(search = res; search; search = search->ai_next)
+		{
+			if(search->ai_family == AF_INET)
+				NET_AddLocalAddress("", search->ai_addr, (struct sockaddr *) &mask4);
+			else if(search->ai_family == AF_INET6)
+				NET_AddLocalAddress("", search->ai_addr, (struct sockaddr *) &mask6);
+		}
 	
-	memset(&mask4, 0, sizeof(mask4));
-	memset(&mask6, 0, sizeof(mask6));
-	mask4.sin_family = AF_INET;
-	memset(&mask4.sin_addr.s_addr, 0xFF, sizeof(mask4.sin_addr.s_addr));
-	mask6.sin6_family = AF_INET6;
-	memset(&mask6.sin6_addr, 0xFF, sizeof(mask6.sin6_addr));
-
-	// add all IPs from returned list.
-	for(search = res; search; search = search->ai_next)
-	{
-		if(search->ai_family == AF_INET)
-			NET_AddLocalAddress("", search->ai_addr, (struct sockaddr *) &mask4);
-		else if(search->ai_family == AF_INET6)
-			NET_AddLocalAddress("", search->ai_addr, (struct sockaddr *) &mask6);
+		Sys_ShowIP();
 	}
 	
-	Sys_ShowIP();
+	if(res)
+		freeaddrinfo(res);
 }
 #endif
 
@@ -1329,11 +1369,6 @@
 	int		port;
 	int		port6;
 
-	net_ip = Cvar_Get( "net_ip", "0.0.0.0", CVAR_LATCH );
-	net_ip6 = Cvar_Get( "net_ip6", "::", CVAR_LATCH );
-	net_port = Cvar_Get( "net_port", va( "%i", PORT_SERVER ), CVAR_LATCH );
-	net_port6 = Cvar_Get( "net_port6", va( "%i", PORT_SERVER ), CVAR_LATCH );
-	
 	port = net_port->integer;
 	port6 = net_port6->integer;
 
@@ -1397,14 +1432,8 @@
 ====================
 */
 static qboolean NET_GetCvars( void ) {
-	qboolean	modified;
+	int modified;
 
-	modified = qfalse;
-
-	if( net_enabled && net_enabled->modified ) {
-		modified = qtrue;
-	}
-	
 #ifdef DEDICATED
 	// I want server owners to explicitly turn on ipv6 support.
 	net_enabled = Cvar_Get( "net_enabled", "1", CVAR_LATCH | CVAR_ARCHIVE );
@@ -1413,45 +1442,55 @@
 	 * used if available due to ping */
 	net_enabled = Cvar_Get( "net_enabled", "3", CVAR_LATCH | CVAR_ARCHIVE );
 #endif
+	modified = net_enabled->modified;
+	net_enabled->modified = qfalse;
+
+	net_ip = Cvar_Get( "net_ip", "0.0.0.0", CVAR_LATCH );
+	modified += net_ip->modified;
+	net_ip->modified = qfalse;
+	
+	net_ip6 = Cvar_Get( "net_ip6", "::", CVAR_LATCH );
+	modified += net_ip6->modified;
+	net_ip6->modified = qfalse;
+	
+	net_port = Cvar_Get( "net_port", va( "%i", PORT_SERVER ), CVAR_LATCH );
+	modified += net_port->modified;
+	net_port->modified = qfalse;
+	
+	net_port6 = Cvar_Get( "net_port6", va( "%i", PORT_SERVER ), CVAR_LATCH );
+	modified += net_port6->modified;
+	net_port6->modified = qfalse;
 
 	// Some cvars for configuring multicast options which facilitates scanning for servers on local subnets.
-	if( net_mcast6addr && net_mcast6addr->modified ) {
-		modified = qtrue;
-	}
 	net_mcast6addr = Cvar_Get( "net_mcast6addr", NET_MULTICAST_IP6, CVAR_LATCH | CVAR_ARCHIVE );
+	modified += net_mcast6addr->modified;
+	net_mcast6addr->modified = qfalse;
 
-	if( net_mcast6iface && net_mcast6iface->modified ) {
-		modified = qtrue;
-	}
 	net_mcast6iface = Cvar_Get( "net_mcast6iface", "0", CVAR_LATCH | CVAR_ARCHIVE );
+	modified += net_mcast6iface->modified; 
+	net_mcast6iface->modified = qfalse;
 
-	if( net_socksEnabled && net_socksEnabled->modified ) {
-		modified = qtrue;
-	}
 	net_socksEnabled = Cvar_Get( "net_socksEnabled", "0", CVAR_LATCH | CVAR_ARCHIVE );
+	modified += net_socksEnabled->modified; 
+	net_socksEnabled->modified = qfalse;
 
-	if( net_socksServer && net_socksServer->modified ) {
-		modified = qtrue;
-	}
 	net_socksServer = Cvar_Get( "net_socksServer", "", CVAR_LATCH | CVAR_ARCHIVE );
+	modified += net_socksServer->modified; 
+	net_socksServer->modified = qfalse;
 
-	if( net_socksPort && net_socksPort->modified ) {
-		modified = qtrue;
-	}
 	net_socksPort = Cvar_Get( "net_socksPort", "1080", CVAR_LATCH | CVAR_ARCHIVE );
+	modified += net_socksPort->modified; 
+	net_socksPort->modified = qfalse;
 
-	if( net_socksUsername && net_socksUsername->modified ) {
-		modified = qtrue;
-	}
 	net_socksUsername = Cvar_Get( "net_socksUsername", "", CVAR_LATCH | CVAR_ARCHIVE );
+	modified += net_socksUsername->modified; 
+	net_socksUsername->modified = qfalse;
 
-	if( net_socksPassword && net_socksPassword->modified ) {
-		modified = qtrue;
-	}
 	net_socksPassword = Cvar_Get( "net_socksPassword", "", CVAR_LATCH | CVAR_ARCHIVE );
+	modified += net_socksPassword->modified; 
+	net_socksPassword->modified = qfalse;
 
-
-	return modified;
+	return modified ? qtrue : qfalse;
 }
 
 
@@ -1556,10 +1595,9 @@
 	Com_Printf( "Winsock Initialized\n" );
 #endif
 
-	// this is really just to get the cvars registered
-	NET_GetCvars();
-
 	NET_Config( qtrue );
+	
+	Cmd_AddCommand ("net_restart", NET_Restart_f);
 }
 
 
@@ -1610,8 +1648,7 @@
 	{
 		FD_SET(ip_socket, &fdset);
 
-		if(ip_socket > highestfd)
-			highestfd = ip_socket;
+		highestfd = ip_socket;
 	}
 	if(ip6_socket != INVALID_SOCKET)
 	{
@@ -1623,7 +1660,7 @@
 
 	timeout.tv_sec = msec/1000;
 	timeout.tv_usec = (msec%1000)*1000;
-	select(ip_socket+1, &fdset, NULL, NULL, &timeout);
+	select(highestfd + 1, &fdset, NULL, NULL, &timeout);
 }
 
 /*
@@ -1631,6 +1668,6 @@
 NET_Restart_f
 ====================
 */
-void NET_Restart( void ) {
+void NET_Restart_f( void ) {
 	NET_Config( networkingEnabled );
 }
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/qcommon/q_shared.h
--- a/src/qcommon/q_shared.h	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/qcommon/q_shared.h	Mon Jul 06 04:07:05 2009 +0800
@@ -30,7 +30,7 @@
 #define PRODUCT_NAME            "tremfusion"
 
 #ifdef _MSC_VER
-# define PRODUCT_VERSION          "0.99r2"
+# define PRODUCT_VERSION          "0.99r3"
 #endif
 
 #define CLIENT_WINDOW_TITLE       "Tremfusion " PRODUCT_VERSION
@@ -169,6 +169,10 @@
 #define NULL ((void *)0)
 #endif
 
+#define STRING(s)			#s
+// expand constants before stringifying them
+#define XSTRING(s)			STRING(s)
+
 #define	MAX_QINT			0x7fffffff
 #define	MIN_QINT			(-MAX_QINT-1)
 
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/qcommon/qcommon.h
--- a/src/qcommon/qcommon.h	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/qcommon/qcommon.h	Mon Jul 06 04:07:05 2009 +0800
@@ -125,6 +125,14 @@
 ==============================================================
 */
 
+#define NET_ENABLEV4            0x01
+#define NET_ENABLEV6            0x02
+// if this flag is set, always attempt ipv6 connections instead of ipv4 if a v6 address is found.
+#define NET_PRIOV6              0x04
+// disables ipv6 multicast support if set.
+#define NET_DISABLEMCAST        0x08
+
+
 #define	PACKET_BACKUP	32	// number of old messages that must be kept on client and
 							// server for delta comrpession and ping estimation
 #define	PACKET_MASK		(PACKET_BACKUP-1)
@@ -136,7 +144,7 @@
 #define	MAX_RELIABLE_COMMANDS	128			// max string commands buffered for restransmit
 
 typedef enum {
-	NA_BAD,					// an address lookup failed
+	NA_BAD = 0,					// an address lookup failed
 	NA_LOOPBACK,
 	NA_BROADCAST,
 	NA_IP,
@@ -163,7 +171,7 @@
 
 void		NET_Init( void );
 void		NET_Shutdown( void );
-void		NET_Restart( void );
+void		NET_Restart_f( void );
 void		NET_Config( qboolean enableNetworking );
 void		NET_FlushPacketQueue(void);
 void		NET_SendPacket (netsrc_t sock, int length, const void *data, netadr_t to);
@@ -171,6 +179,7 @@
 void		QDECL NET_OutOfBandData( netsrc_t sock, netadr_t adr, byte *format, int len );
 
 qboolean	NET_CompareAdr (netadr_t a, netadr_t b);
+qboolean	NET_CompareBaseAdrMask(netadr_t a, netadr_t b, int netmask);
 qboolean	NET_CompareBaseAdr (netadr_t a, netadr_t b);
 qboolean	NET_IsLocalAddress (netadr_t adr);
 const char	*NET_AdrToString (netadr_t a);
@@ -571,7 +580,6 @@
 #define FS_GENERAL_REF	0x01
 #define FS_UI_REF		0x02
 #define FS_CGAME_REF	0x04
-#define FS_EXTRA_REF	0x08
 
 #define	MAX_FILE_HANDLES	64
 
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/qcommon/vm_x86_64.c
--- a/src/qcommon/vm_x86_64.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/qcommon/vm_x86_64.c	Mon Jul 06 04:07:05 2009 +0800
@@ -39,6 +39,18 @@
 //#define USE_GAS
 //#define DEBUG_VM
 
+#define MAX_CACHE_ENTRIES 6
+
+typedef struct {
+	int checksum;
+	int age;
+	byte *codeBase;
+	int codeLength;
+	int *instructionPointers;
+} vmCache_t;
+
+static vmCache_t vmCache[MAX_CACHE_ENTRIES];
+
 #ifdef DEBUG_VM
 #define Dfprintf(fd, args...) fprintf(fd, ##args)
 static FILE* qdasmout;
@@ -59,7 +71,68 @@
 #endif
 #endif // USE_GAS
 
-static void VM_Destroy_Compiled(vm_t* self);
+// Cache system to compensate for the slowness of the x86_64 JIT compiler
+
+static ID_INLINE void VM_Destroy_Compiled(byte *codeBase, int codeLength)
+{
+#ifdef _WIN32
+	VirtualFree(codeBase, 0, MEM_RELEASE);
+#else
+	munmap(codeBase, codeLength);
+#endif
+}
+
+static ID_INLINE qboolean VM_Cache_Search(vm_t *vm, vmHeader_t *header)
+{
+	int checksum = Com_BlockChecksum((byte *)header + header->codeOffset, header->codeLength);
+	int i;
+
+	for (i = 0; i < MAX_CACHE_ENTRIES; i++) {
+		if (vmCache[i].checksum == checksum) {
+			vm->codeLength = vmCache[i].codeLength;
+			vm->codeBase = vmCache[i].codeBase;
+			vm->instructionPointers = vmCache[i].instructionPointers;
+			vm->compiled = qtrue;
+			vm->destroy = NULL;
+			vmCache[i].age = 0;
+			return qtrue;
+		}
+	}
+
+	return qfalse;
+}
+
+static ID_INLINE void VM_Cache_Add(vm_t *vm, vmHeader_t *header)
+{
+	int checksum = Com_BlockChecksum((byte *)header + header->codeOffset, header->codeLength);
+	int i, oldest = 0;
+
+	for (i = 1; i < MAX_CACHE_ENTRIES; i++) {
+		if (!vmCache[i].codeBase) {
+			oldest = i;
+			break;
+		} else if (vmCache[i].age > vmCache[oldest].age) {
+			oldest = i;
+		}
+	}
+
+	// Free existing cache entry
+	if (vmCache[oldest].codeBase) {
+		VM_Destroy_Compiled(vmCache[oldest].codeBase, vmCache[oldest].codeLength);
+		free(vmCache[oldest].instructionPointers);
+		vmCache[oldest].codeBase = NULL;
+		vmCache[oldest].checksum = 0;
+	}
+
+	vmCache[oldest].checksum = checksum;
+	vmCache[oldest].age = -1;
+	vmCache[oldest].codeLength = vm->codeLength;
+	vmCache[oldest].codeBase = vm->codeBase;
+	vmCache[oldest].instructionPointers = vm->instructionPointers;
+
+	for (i = 0; i < MAX_CACHE_ENTRIES; i++)
+		vmCache[i].age++;
+}
 
 /*
  
@@ -463,6 +536,14 @@
 	int neednilabel = 0;
 	struct timeval tvstart =  {0, 0};
 
+	if (VM_Cache_Search(vm, header)) {
+		Com_DPrintf("loaded %s from the cache\n", vm->name);
+		return;
+	}
+
+	// We need persistant instruction pointers
+	vm->instructionPointers = malloc(vm->instructionPointersLength);
+
 #ifdef USE_GAS
 	byte* compiledcode;
 	int   compiledsize;
@@ -560,7 +641,7 @@
 #endif
 
 		/* store current instruction number in r15 for debugging */
-#if 1
+#if 0
 		emit("nop");
 		emit("movq $%d, %%r15", instruction);
 		emit("nop");
@@ -988,7 +1069,7 @@
 		Com_Error(ERR_DROP, "VM_CompileX86: mprotect failed");
 #endif // USE_GAS
 
-	vm->destroy = VM_Destroy_Compiled;
+	vm->destroy = NULL;
 	
 #ifdef USE_GAS
 	entryPoint = getentrypoint(vm);
@@ -1032,21 +1113,12 @@
 		gettimeofday(&tvdone, NULL);
 		timersub(&tvdone, &tvstart, &dur);
 		Com_DPrintf( "compilation took %lu.%06lu seconds\n", dur.tv_sec, dur.tv_usec );
+
+		VM_Cache_Add(vm, header);
 	}
 }
 
 
-void VM_Destroy_Compiled(vm_t* self)
-{
-#ifdef USE_GAS
-	munmap(self->codeBase, self->codeLength);
-#elif _WIN32
-	VirtualFree(self->codeBase, 0, MEM_RELEASE);
-#else
-	munmap(self->codeBase, self->codeLength);
-#endif
-}
-
 /*
 ==============
 VM_CallCompiled
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/renderer/tr_init.c
--- a/src/renderer/tr_init.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/renderer/tr_init.c	Mon Jul 06 04:07:05 2009 +0800
@@ -104,6 +104,7 @@
 cvar_t	*r_colorbits;
 cvar_t	*r_primitives;
 cvar_t	*r_texturebits;
+cvar_t  *r_ext_multisample;
 
 cvar_t	*r_drawBuffer;
 cvar_t	*r_lightmap;
@@ -548,7 +549,7 @@
 	float		xScale, yScale;
 	int			xx, yy;
 
-	sprintf( checkname, "levelshots/%s.tga", tr.world->baseName );
+	Com_sprintf(checkname, sizeof(checkname), "levelshots/%s.tga", tr.world->baseName);
 
 	source = ri.Hunk_AllocateTempMemory( glConfig.vidWidth * glConfig.vidHeight * 3 );
 
@@ -931,6 +932,8 @@
 	r_colorbits = ri.Cvar_Get( "r_colorbits", "0", CVAR_ARCHIVE | CVAR_LATCH );
 	r_stencilbits = ri.Cvar_Get( "r_stencilbits", "8", CVAR_ARCHIVE | CVAR_LATCH );
 	r_depthbits = ri.Cvar_Get( "r_depthbits", "0", CVAR_ARCHIVE | CVAR_LATCH );
+	r_ext_multisample = ri.Cvar_Get( "r_ext_multisample", "0", CVAR_ARCHIVE | CVAR_LATCH );
+	ri.Cvar_CheckRange( r_ext_multisample, 0, 4, qtrue );
 	r_overBrightBits = ri.Cvar_Get ("r_overBrightBits", "0", CVAR_ARCHIVE | CVAR_LATCH );
 	r_ignorehwgamma = ri.Cvar_Get( "r_ignorehwgamma", "0", CVAR_ARCHIVE | CVAR_LATCH);
 	r_fullscreen = ri.Cvar_Get( "r_fullscreen", "1", CVAR_ARCHIVE );
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/renderer/tr_local.h
--- a/src/renderer/tr_local.h	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/renderer/tr_local.h	Mon Jul 06 04:07:05 2009 +0800
@@ -1005,6 +1005,7 @@
 extern cvar_t	*r_depthbits;			// number of desired depth bits
 extern cvar_t	*r_colorbits;			// number of desired color bits, only relevant for fullscreen
 extern cvar_t	*r_texturebits;			// number of desired texture bits
+extern cvar_t	*r_ext_multisample;
 										// 0 = use framebuffer depth
 										// 16 = use 16-bit textures
 										// 32 = use 32-bit textures
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/renderer/tr_main.c
--- a/src/renderer/tr_main.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/renderer/tr_main.c	Mon Jul 06 04:07:05 2009 +0800
@@ -457,7 +457,7 @@
 	float oppleg, adjleg, length;
 	int i;
 	
-	if(stereoSep == 0 && xmin != -xmax)
+	if(stereoSep == 0 && xmin == -xmax)
 	{
 		// symmetric case can be simplified
 		VectorCopy(dest->or.origin, ofsorigin);
@@ -524,9 +524,9 @@
 	if(stereoSep != 0)
 	{
 		if(dest->stereoFrame == STEREO_LEFT)
-			stereoSep = zProj / r_stereoSeparation->value;
+			stereoSep = zProj / stereoSep;
 		else if(dest->stereoFrame == STEREO_RIGHT)
-			stereoSep = zProj / -r_stereoSeparation->value;
+			stereoSep = zProj / -stereoSep;
 		else
 			stereoSep = 0;
 	}
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/renderer/tr_noise.c
--- a/src/renderer/tr_noise.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/renderer/tr_noise.c	Mon Jul 06 04:07:05 2009 +0800
@@ -45,8 +45,6 @@
 {
 	int i;
 
-	srand( 1001 );
-
 	for ( i = 0; i < NOISE_SIZE; i++ )
 	{
 		s_noise_table[i] = ( float ) ( ( ( rand() / ( float ) RAND_MAX ) * 2.0 - 1.0 ) );
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/renderer/tr_surface.c
--- a/src/renderer/tr_surface.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/renderer/tr_surface.c	Mon Jul 06 04:07:05 2009 +0800
@@ -193,7 +193,7 @@
 RB_SurfacePolychain
 =============
 */
-void RB_SurfacePolychain( srfPoly_t *p ) {
+static void RB_SurfacePolychain( srfPoly_t *p ) {
 	int		i;
 	int		numv;
 
@@ -227,7 +227,7 @@
 RB_SurfaceTriangles
 =============
 */
-void RB_SurfaceTriangles( srfTriangles_t *srf ) {
+static void RB_SurfaceTriangles( srfTriangles_t *srf ) {
 	int			i;
 	drawVert_t	*dv;
 	float		*xyz, *normal, *texCoords;
@@ -288,7 +288,7 @@
 RB_SurfaceBeam
 ==============
 */
-void RB_SurfaceBeam( void ) 
+static void RB_SurfaceBeam( void )
 {
 #define NUM_BEAM_SEGS 6
 	refEntity_t *e;
@@ -458,7 +458,7 @@
 /*
 ** RB_SurfaceRailRinges
 */
-void RB_SurfaceRailRings( void ) {
+static void RB_SurfaceRailRings( void ) {
 	refEntity_t *e;
 	int			numSegs;
 	int			len;
@@ -488,7 +488,7 @@
 /*
 ** RB_SurfaceRailCore
 */
-void RB_SurfaceRailCore( void ) {
+static void RB_SurfaceRailCore( void ) {
 	refEntity_t *e;
 	int			len;
 	vec3_t		right;
@@ -518,7 +518,7 @@
 /*
 ** RB_SurfaceLightningBolt
 */
-void RB_SurfaceLightningBolt( void ) {
+static void RB_SurfaceLightningBolt( void ) {
 	refEntity_t *e;
 	int			len;
 	vec3_t		right;
@@ -1065,7 +1065,7 @@
 }
 #endif
 
-void RB_SurfaceMesh_scalar(md3Surface_t *surface) {
+static void RB_SurfaceMesh_scalar(md3Surface_t *surface) {
 	int				j;
 	float			backlerp;
 	int				*triangles;
@@ -1106,7 +1106,7 @@
 
 }
 
-void RB_SurfaceMesh(md3Surface_t *surface) {
+static void RB_SurfaceMesh(md3Surface_t *surface) {
 #if idppc_altivec
   if (com_altivec->integer) {
     RB_SurfaceMesh_altivec( surface );
@@ -1238,7 +1238,7 @@
 	tess.numVertexes += surf->numPoints;
 }
 
-void RB_SurfaceFace( srfSurfaceFace_t *surf ) {
+static void RB_SurfaceFace( srfSurfaceFace_t *surf ) {
 #if id386_sse >= 2
 	if (com_sse->integer >= 2) {
 		RB_SurfaceFace_sse2( surf );
@@ -1286,7 +1286,7 @@
 Just copy the grid of points and triangulate
 =============
 */
-void RB_SurfaceGrid( srfGridMesh_t *cv ) {
+static void RB_SurfaceGrid( srfGridMesh_t *cv ) {
 	int		i, j;
 	float	*xyz;
 	float	*texCoords;
@@ -1453,7 +1453,7 @@
 Draws x/y/z lines from the origin for orientation debugging
 ===================
 */
-void RB_SurfaceAxis( void ) {
+static void RB_SurfaceAxis( void ) {
 	GL_Bind( tr.whiteImage );
 	qglLineWidth( 3 );
 	qglBegin( GL_LINES );
@@ -1479,7 +1479,7 @@
 Entities that have a single procedurally generated surface
 ====================
 */
-void RB_SurfaceEntity( surfaceType_t *surfType ) {
+static void RB_SurfaceEntity( surfaceType_t *surfType ) {
 	switch( backEnd.currentEntity->e.reType ) {
 	case RT_SPRITE:
 		RB_SurfaceSprite();
@@ -1503,23 +1503,23 @@
 	return;
 }
 
-void RB_SurfaceBad( surfaceType_t *surfType ) {
+static void RB_SurfaceBad( surfaceType_t *surfType ) {
 	ri.Printf( PRINT_ALL, "Bad surface tesselated.\n" );
 }
 
-void RB_SurfaceFlare(srfFlare_t *surf)
+static void RB_SurfaceFlare(srfFlare_t *surf)
 {
 	if (r_flares->integer)
 		RB_AddFlare(surf, tess.fogNum, surf->origin, surf->color, surf->normal);
 }
 
-void RB_SurfaceDisplayList( srfDisplayList_t *surf ) {
+static void RB_SurfaceDisplayList( srfDisplayList_t *surf ) {
 	// all apropriate state must be set in RB_BeginSurface
 	// this isn't implemented yet...
 	qglCallList( surf->listNum );
 }
 
-void RB_SurfaceSkip( void *surf ) {
+static void RB_SurfaceSkip( void *surf ) {
 }
 
 
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/sdl/sdl_glimp.c
--- a/src/sdl/sdl_glimp.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/sdl/sdl_glimp.c	Mon Jul 06 04:07:05 2009 +0800
@@ -287,6 +287,7 @@
 	int sdlcolorbits;
 	int colorbits, depthbits, stencilbits;
 	int tcolorbits, tdepthbits, tstencilbits;
+	int samples;
 	int i = 0;
 	SDL_Surface *vidscreen = NULL;
 	Uint32 flags = SDL_OPENGL;
@@ -370,6 +371,7 @@
 	else
 		depthbits = r_depthbits->value;
 	stencilbits = r_stencilbits->value;
+	samples = r_ext_multisample->value;
 
 	for (i = 0; i < 16; i++)
 	{
@@ -450,6 +452,11 @@
 		
 		SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
 
+		if (failSafe)
+			samples = 0;
+		SDL_GL_SetAttribute( SDL_GL_MULTISAMPLEBUFFERS, samples ? 1 : 0 );
+		SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, samples );
+
 		if( SDL_GL_SetAttribute( SDL_GL_SWAP_CONTROL, r_swapInterval->integer ) < 0 )
 			ri.Printf( PRINT_ALL, "r_swapInterval requires libSDL >= 1.2.10\n" );
 
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/server/server.h
--- a/src/server/server.h	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/server/server.h	Mon Jul 06 04:07:05 2009 +0800
@@ -212,6 +212,7 @@
 typedef struct {
 	netadr_t	adr;
 	int			challenge;
+	int			clientChallenge;	// challenge number coming from the client
 	int			time;				// time the first challenge response was sent to client
 	int			pingTime;			// time the last challenge response was sent to client
 	qboolean	connected;
@@ -312,7 +313,6 @@
 void SV_SetUserinfo( int index, const char *val );
 void SV_GetUserinfo( int index, char *buffer, int bufferSize );
 
-void SV_ChangeMaxClients( void );
 void SV_SpawnServer( char *server, qboolean killBots );
 
 
@@ -320,7 +320,7 @@
 //
 // sv_client.c
 //
-void SV_GetChallenge( netadr_t from );
+void SV_GetChallenge(netadr_t from);
 
 void SV_DirectConnect( netadr_t from );
 
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/server/sv_client.c
--- a/src/server/sv_client.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/server/sv_client.c	Mon Jul 06 04:07:05 2009 +0800
@@ -42,12 +42,21 @@
 
 When an authorizeip is returned, a challenge response will be
 sent to that ip.
+
+ioquake3: we added a possibility for clients to add a challenge
+to their packets, to make it more difficult for malicious servers
+to hi-jack client connections.
+Also, the auth stuff is completely disabled for com_standalone games
+as well as IPv6 connections, since there is no way to use the
+v4-only auth server for these new types of connections.
 =================
 */
-void SV_GetChallenge( netadr_t from ) {
+void SV_GetChallenge(netadr_t from)
+{
 	int		i;
 	int		oldest;
 	int		oldestTime;
+	const char *clientChallenge = Cmd_Argv(1);
 	challenge_t	*challenge;
 
 	oldest = 0;
@@ -72,12 +81,11 @@
 		challenge->adr = from;
 		challenge->time = svs.time;
 		challenge->connected = qfalse;
-		i = oldest;
 	}
 
 	// send the challengeResponse
 	challenge->pingTime = svs.time;
-	NET_OutOfBandPrint( NS_SERVER, from, "challengeResponse %i", challenge->challenge );
+	NET_OutOfBandPrint( NS_SERVER, challenge->adr, "challengeResponse %i %s", challenge->challenge, clientChallenge);
 }
 
 /*
@@ -383,7 +391,7 @@
 the wrong gamestate.
 ================
 */
-void SV_SendClientGameState( client_t *client ) {
+static void SV_SendClientGameState( client_t *client ) {
 	int			start;
 	entityState_t	*base, nullstate;
 	msg_t		msg;
@@ -518,7 +526,7 @@
 Abort a download if in progress
 ==================
 */
-void SV_StopDownload_f( client_t *cl ) {
+static void SV_StopDownload_f( client_t *cl ) {
 	if (*cl->downloadName)
 		Com_DPrintf( "clientDownload: %d : file \"%s\" aborted\n", (int) (cl - svs.clients), cl->downloadName );
 
@@ -532,7 +540,7 @@
 Downloads are finished
 ==================
 */
-void SV_DoneDownload_f( client_t *cl ) {
+static void SV_DoneDownload_f( client_t *cl ) {
 	Com_DPrintf( "clientDownload: %s Done\n", cl->name);
 	// resend the game state to update any clients that entered during the download
 	SV_SendClientGameState(cl);
@@ -546,7 +554,7 @@
 the same as cl->downloadClientBlock
 ==================
 */
-void SV_NextDownload_f( client_t *cl )
+static void SV_NextDownload_f( client_t *cl )
 {
 	int block = atoi( Cmd_Argv(1) );
 
@@ -575,7 +583,7 @@
 SV_BeginDownload_f
 ==================
 */
-void SV_BeginDownload_f( client_t *cl ) {
+static void SV_BeginDownload_f( client_t *cl ) {
 
 	// Kill any existing download
 	SV_CloseDownload( cl );
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/server/sv_init.c
--- a/src/server/sv_init.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/server/sv_init.c	Mon Jul 06 04:07:05 2009 +0800
@@ -217,7 +217,7 @@
 baseline will be transmitted
 ================
 */
-void SV_CreateBaseline( void ) {
+static void SV_CreateBaseline( void ) {
 	sharedEntity_t *svent;
 	int				entnum;	
 
@@ -237,41 +237,11 @@
 
 
 /*
-===============
-SV_Startup
-
-Called when a host starts a map when it wasn't running
-one before.  Successive map or map_restart commands will
-NOT cause this to be called, unless the game is exited to
-the menu system first.
-===============
-*/
-void SV_Startup( void ) {
-	if ( svs.initialized ) {
-		Com_Error( ERR_FATAL, "SV_Startup: svs.initialized" );
-	}
-
-	SV_ChangeMaxClients();
-	svs.initialized = qtrue;
-
-	// Don't respect sv_killserver unless a server is actually running
-	if ( sv_killserver->integer ) {
-		Cvar_Set( "sv_killserver", "0" );
-	}
-
-	Cvar_Set( "sv_running", "1" );
-	
-	// Join the ipv6 multicast group now that a map is running so clients can scan for us on the local network.
-	NET_JoinMulticast6();
-}
-
-
-/*
 ==================
 SV_ChangeMaxClients
 ==================
 */
-void SV_ChangeMaxClients( void ) {
+static void SV_ChangeMaxClients( void ) {
 	int		oldMaxClients;
 	int		i, j;
 	client_t	*oldClients = NULL;
@@ -350,12 +320,42 @@
 	}
 }
 
+
+/*
+===============
+SV_Startup
+
+Called when a host starts a map when it wasn't running
+one before.  Successive map or map_restart commands will
+NOT cause this to be called, unless the game is exited to
+the menu system first.
+===============
+*/
+static void SV_Startup( void ) {
+	if ( svs.initialized ) {
+		Com_Error( ERR_FATAL, "SV_Startup: svs.initialized" );
+	}
+
+	SV_ChangeMaxClients();
+	svs.initialized = qtrue;
+
+	// Don't respect sv_killserver unless a server is actually running
+	if ( sv_killserver->integer ) {
+		Cvar_Set( "sv_killserver", "0" );
+	}
+
+	Cvar_Set( "sv_running", "1" );
+	
+	// Join the ipv6 multicast group now that a map is running so clients can scan for us on the local network.
+	NET_JoinMulticast6();
+}
+
 /*
 ================
 SV_ClearServer
 ================
 */
-void SV_ClearServer(void) {
+static void SV_ClearServer(void) {
 	int i;
 
 	for ( i = 0 ; i < MAX_CONFIGSTRINGS ; i++ ) {
@@ -373,7 +373,7 @@
 Touch the cgame.qvm and ui.qvm so that a pure client can load it if it's in a seperate pk3, and so it gets on the download list
 ================
 */
-void SV_TouchCGame(void) {
+static void SV_TouchCGame(void) {
 	fileHandle_t	f;
 
 	FS_FOpenFileRead( "vm/cgame.qvm", &f, qfalse );
@@ -468,7 +468,6 @@
 	Cvar_Set("cl_paused", "0");
 
 	// get a new checksum feed and restart the file system
-	srand(Com_Milliseconds());
 	sv.checksumFeed = ( ((int) rand() << 16) ^ rand() ) ^ Com_Milliseconds();
 	FS_Restart( sv.checksumFeed );
 
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/server/sv_main.c
--- a/src/server/sv_main.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/server/sv_main.c	Mon Jul 06 04:07:05 2009 +0800
@@ -76,7 +76,7 @@
 Converts newlines to "\n" so a line prints nicer
 ===============
 */
-char	*SV_ExpandNewlines( char *in ) {
+static char	*SV_ExpandNewlines( char *in ) {
 	static	char	string[1024];
 	int		l;
 
@@ -99,10 +99,11 @@
 ======================
 SV_ReplacePendingServerCommands
 
-  This is ugly
+FIXME: This is ugly
 ======================
 */
-int SV_ReplacePendingServerCommands( client_t *client, const char *cmd ) {
+#if 0 // unused
+static int SV_ReplacePendingServerCommands( client_t *client, const char *cmd ) {
 	int i, index, csnum1, csnum2;
 
 	for ( i = client->reliableSent+1; i <= client->reliableSequence; i++ ) {
@@ -119,6 +120,7 @@
 	}
 	return qfalse;
 }
+#endif
 
 /*
 ======================
@@ -229,52 +231,91 @@
 #define	HEARTBEAT_MSEC	300*1000
 #define	HEARTBEAT_GAME	"Tremulous"
 void SV_MasterHeartbeat( void ) {
-	static netadr_t	adr[MAX_MASTER_SERVERS];
+	static netadr_t	adr[MAX_MASTER_SERVERS][2]; // [2] for v4 and v6 address for the same address string.
 	int			i;
 	int			res;
+	int			netenabled;
+
+	netenabled = Cvar_VariableIntegerValue("net_enabled");
 
 	// "dedicated 1" is for lan play, "dedicated 2" is for inet public play
-	if ( !com_dedicated || com_dedicated->integer != 2 ) {
+	if (!com_dedicated || com_dedicated->integer != 2 || !(netenabled & (NET_ENABLEV4 | NET_ENABLEV6)))
 		return;		// only dedicated servers send heartbeats
-	}
 
 	// if not time yet, don't send anything
-	if ( svs.time < svs.nextHeartbeatTime ) {
+	if ( svs.time < svs.nextHeartbeatTime )
 		return;
-	}
+
 	svs.nextHeartbeatTime = svs.time + HEARTBEAT_MSEC;
 
-
 	// send to group masters
-	for ( i = 0 ; i < MAX_MASTER_SERVERS ; i++ ) {
-		if ( !sv_master[i]->string[0] ) {
+	for (i = 0; i < MAX_MASTER_SERVERS; i++)
+	{
+		if(!sv_master[i]->string[0])
 			continue;
-		}
 
 		// see if we haven't already resolved the name
 		// resolving usually causes hitches on win95, so only
 		// do it when needed
-		if ( sv_master[i]->modified ) {
+		if(sv_master[i]->modified || (adr[i][0].type == NA_BAD && adr[i][1].type == NA_BAD))
+		{
 			sv_master[i]->modified = qfalse;
-	
-			Com_Printf( "Resolving %s\n", sv_master[i]->string );
-			res = NET_StringToAdr( sv_master[i]->string, &adr[i], NA_UNSPEC );
-			if ( !res ) {
-				Com_Printf( "Couldn't resolve address: %s\n", sv_master[i]->string );
+			
+			if(netenabled & NET_ENABLEV4)
+			{
+				Com_Printf("Resolving %s (IPv4)\n", sv_master[i]->string);
+				res = NET_StringToAdr(sv_master[i]->string, &adr[i][0], NA_IP);
+
+				if(res == 2)
+				{
+					// if no port was specified, use the default master port
+					adr[i][0].port = BigShort(PORT_MASTER);
+				}
+				
+				if(res)
+					Com_Printf( "%s resolved to %s\n", sv_master[i]->string, NET_AdrToStringwPort(adr[i][0]));
+				else
+					Com_Printf( "%s has no IPv4 address.\n", sv_master[i]->string);
+			}
+			
+			if(netenabled & NET_ENABLEV6)
+			{
+				Com_Printf("Resolving %s (IPv6)\n", sv_master[i]->string);
+				res = NET_StringToAdr(sv_master[i]->string, &adr[i][1], NA_IP6);
+
+				if(res == 2)
+				{
+					// if no port was specified, use the default master port
+					adr[i][1].port = BigShort(PORT_MASTER);
+				}
+				
+				if(res)
+					Com_Printf( "%s resolved to %s\n", sv_master[i]->string, NET_AdrToStringwPort(adr[i][1]));
+				else
+					Com_Printf( "%s has no IPv6 address.\n", sv_master[i]->string);
+			}
+
+			if(adr[i][0].type == NA_BAD && adr[i][1].type == NA_BAD)
+			{
+				// if the address failed to resolve, clear it
+				// so we don't take repeated dns hits
+				Com_Printf("Couldn't resolve address: %s\n", sv_master[i]->string);
+				Cvar_Set(sv_master[i]->name, "");
+				sv_master[i]->modified = qfalse;
 				continue;
 			}
-			if ( res == 2 ) {
-				// if no port was specified, use the default master port
-				adr[i].port = BigShort( PORT_MASTER );
-			}
-			Com_Printf( "%s resolved to %s\n", sv_master[i]->string, NET_AdrToStringwPort(adr[i]));
 		}
 
 
 		Com_Printf ("Sending heartbeat to %s\n", sv_master[i]->string );
+
 		// this command should be changed if the server info / status format
 		// ever incompatably changes
-		NET_OutOfBandPrint( NS_SERVER, adr[i], "heartbeat %s\n", HEARTBEAT_GAME );
+
+		if(adr[i][0].type != NA_BAD)
+			NET_OutOfBandPrint( NS_SERVER, adr[i][0], "heartbeat %s\n", HEARTBEAT_GAME );
+		if(adr[i][1].type != NA_BAD)
+			NET_OutOfBandPrint( NS_SERVER, adr[i][1], "heartbeat %s\n", HEARTBEAT_GAME );
 	}
 }
 
@@ -347,7 +388,7 @@
 the simple info query.
 ================
 */
-void SVC_Status( netadr_t from ) {
+static void SVC_Status( netadr_t from ) {
 	char	player[1024];
 	char	status[MAX_MSGLEN];
 	int		i;
@@ -452,7 +493,7 @@
 
 ================
 */
-void SV_FlushRedirect( char *outputbuf ) {
+static void SV_FlushRedirect( char *outputbuf ) {
 	NET_OutOfBandPrint( NS_SERVER, svs.redirectAddress, "print\n%s", outputbuf );
 }
 
@@ -465,7 +506,7 @@
 Redirect all printfs
 ===============
 */
-void SVC_RemoteCommand( netadr_t from, msg_t *msg ) {
+static void SVC_RemoteCommand( netadr_t from, msg_t *msg ) {
 	qboolean	valid;
 	unsigned int time;
 	char		remaining[1024];
@@ -555,7 +596,7 @@
 connectionless packets.
 =================
 */
-void SV_ConnectionlessPacket( netadr_t from, msg_t *msg ) {
+static void SV_ConnectionlessPacket( netadr_t from, msg_t *msg ) {
 	char	*s;
 	char	*c;
 
@@ -577,7 +618,7 @@
   } else if (!Q_stricmp(c, "getinfo")) {
 		SVC_Info( from );
 	} else if (!Q_stricmp(c, "getchallenge")) {
-		SV_GetChallenge( from );
+		SV_GetChallenge(from);
 	} else if (!Q_stricmp(c, "connect")) {
 		SV_DirectConnect( from );
 	} else if (!Q_stricmp(c, "rcon")) {
@@ -664,7 +705,7 @@
 Updates the cl->ping variables
 ===================
 */
-void SV_CalcPings( void ) {
+static void SV_CalcPings( void ) {
 	int			i, j;
 	client_t	*cl;
 	int			total, count;
@@ -720,7 +761,7 @@
 if necessary
 ==================
 */
-void SV_CheckTimeouts( void ) {
+static void SV_CheckTimeouts( void ) {
 	int		i;
 	client_t	*cl;
 	int			droppoint;
@@ -761,7 +802,7 @@
 SV_CheckPaused
 ==================
 */
-qboolean SV_CheckPaused( void ) {
+static qboolean SV_CheckPaused( void ) {
 	int		count;
 	client_t	*cl;
 	int		i;
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/server/sv_net_chan.c
--- a/src/server/sv_net_chan.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/server/sv_net_chan.c	Mon Jul 06 04:07:05 2009 +0800
@@ -37,26 +37,27 @@
 static void SV_Netchan_Encode( client_t *client, msg_t *msg ) {
 	long reliableAcknowledge, i, index;
 	byte key, *string;
-        int	srdc, sbit, soob;
-        
+	int	srdc, sbit;
+	qboolean soob;
+
 	if ( msg->cursize < SV_ENCODE_START ) {
 		return;
 	}
 
-        srdc = msg->readcount;
-        sbit = msg->bit;
-        soob = msg->oob;
-        
-        msg->bit = 0;
-        msg->readcount = 0;
-        msg->oob = 0;
-        
+	srdc = msg->readcount;
+	sbit = msg->bit;
+	soob = msg->oob;
+
+	msg->bit = 0;
+	msg->readcount = 0;
+	msg->oob = qfalse;
+
 	reliableAcknowledge = MSG_ReadLong(msg);
 
-        msg->oob = soob;
-        msg->bit = sbit;
-        msg->readcount = srdc;
-        
+	msg->oob = soob;
+	msg->bit = sbit;
+	msg->readcount = srdc;
+
 	string = (byte *)client->lastClientCommandString;
 	index = 0;
 	// xor the client challenge with the netchan sequence number
@@ -90,23 +91,24 @@
 */
 static void SV_Netchan_Decode( client_t *client, msg_t *msg ) {
 	int serverId, messageAcknowledge, reliableAcknowledge;
-	int i, index, srdc, sbit, soob;
+	int i, index, srdc, sbit;
+	qboolean soob;
 	byte key, *string;
 
-        srdc = msg->readcount;
-        sbit = msg->bit;
-        soob = msg->oob;
-        
-        msg->oob = 0;
-        
-        serverId = MSG_ReadLong(msg);
+	srdc = msg->readcount;
+	sbit = msg->bit;
+	soob = msg->oob;
+
+	msg->oob = qfalse;
+
+	serverId = MSG_ReadLong(msg);
 	messageAcknowledge = MSG_ReadLong(msg);
 	reliableAcknowledge = MSG_ReadLong(msg);
 
-        msg->oob = soob;
-        msg->bit = sbit;
-        msg->readcount = srdc;
-        
+	msg->oob = soob;
+	msg->bit = sbit;
+	msg->readcount = srdc;
+
 	string = (byte *)client->reliableCommands[ reliableAcknowledge & (MAX_RELIABLE_COMMANDS-1) ];
 	index = 0;
 	//
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/server/sv_world.c
--- a/src/server/sv_world.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/server/sv_world.c	Mon Jul 06 04:07:05 2009 +0800
@@ -104,7 +104,7 @@
 Builds a uniformly subdivided tree for the given world size
 ===============
 */
-worldSector_t *SV_CreateworldSector( int depth, vec3_t mins, vec3_t maxs ) {
+static worldSector_t *SV_CreateworldSector( int depth, vec3_t mins, vec3_t maxs ) {
 	worldSector_t	*anode;
 	vec3_t		size;
 	vec3_t		mins1, maxs1, mins2, maxs2;
@@ -380,7 +380,7 @@
 
 ====================
 */
-void SV_AreaEntities_r( worldSector_t *node, areaParms_t *ap ) {
+static void SV_AreaEntities_r( worldSector_t *node, areaParms_t *ap ) {
 	svEntity_t	*check, *next;
 	sharedEntity_t *gcheck;
 	int			count;
@@ -508,7 +508,7 @@
 
 ====================
 */
-void SV_ClipMoveToEntities( moveclip_t *clip ) {
+static void SV_ClipMoveToEntities( moveclip_t *clip ) {
 	int			i, num;
 	int			touchlist[MAX_GENTITIES];
 	sharedEntity_t *touch;
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/sys/con_tty.c
--- a/src/sys/con_tty.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/sys/con_tty.c	Mon Jul 06 04:07:05 2009 +0800
@@ -50,6 +50,7 @@
 =============================================================
 */
 
+static qboolean stdin_active;
 // general flag to tell about tty console mode
 static qboolean ttycon_on = qfalse;
 static int ttycon_hide = 0;
@@ -202,6 +203,7 @@
 void CON_Init( void )
 {
 	struct termios tc;
+	const char* term = getenv("TERM");
 
 	// If the process is backgrounded (running non interactively)
 	// then SIGTTIN or SIGTOU is emitted, if not caught, turns into a SIGSTP
@@ -211,10 +213,12 @@
 	// Make stdin reads non-blocking
 	fcntl( 0, F_SETFL, fcntl( 0, F_GETFL, 0 ) | O_NONBLOCK );
 
-	if (isatty(STDIN_FILENO)!=1 || isatty(STDOUT_FILENO)!=1 || isatty(STDERR_FILENO)!=1)
+	if (isatty(STDIN_FILENO)!=1 || isatty(STDOUT_FILENO)!=1 || isatty(STDERR_FILENO)!=1 ||
+	    (term && (!strcmp(term, "raw") || !strcmp(term, "dumb"))))
 	{
-		Com_DPrintf( "stdin/stdout/stderr are not tty, tty console mode disabled\n");
+		Com_DPrintf( "tty console mode disabled\n");
 		ttycon_on = qfalse;
+		stdin_active = qtrue;
 		return;
 	}
 
@@ -344,18 +348,11 @@
 
 		return NULL;
 	}
-	else
+	else if (stdin_active)
 	{
 		int     len;
 		fd_set  fdset;
 		struct timeval timeout;
-		static qboolean stdin_active;
-
-		if (!com_dedicated || !com_dedicated->value)
-			return NULL;
-
-		if (!stdin_active)
-			return NULL;
 
 		FD_ZERO(&fdset);
 		FD_SET(0, &fdset); // stdin
@@ -379,6 +376,7 @@
 
 		return text;
 	}
+	return NULL;
 }
 
 /*
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/sys/sys_main.c
--- a/src/sys/sys_main.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/sys/sys_main.c	Mon Jul 06 04:07:05 2009 +0800
@@ -48,6 +48,9 @@
 #ifdef USE_CURSES
 static qboolean nocurses = qfalse;
 #endif
+#ifdef _WIN32
+qboolean win32_showconsole = qfalse;
+#endif
 
 /*
 =================
@@ -473,6 +476,17 @@
 		}
 	}
 #endif
+
+#ifdef _WIN32
+	for (i = 1; i < argc; i++)
+	{
+		if( !strcmp( argv[i], "+showconsole" ) )
+		{
+			win32_showconsole = qtrue;
+			break;
+		}
+	}
+#endif
 }
 
 #ifndef DEFAULT_BASEDIR
@@ -525,8 +539,6 @@
 	// Run time
 	const SDL_version *ver = SDL_Linked_Version( );
 
-#define STRING(s) #s
-#define XSTRING(s) STRING(s)
 #define MINSDL_VERSION \
 	XSTRING(MINSDL_MAJOR) "." \
 	XSTRING(MINSDL_MINOR) "." \
@@ -554,6 +566,8 @@
 	{
 		if( !strcmp( argv[ i ], "+nocurses" ) )
 			continue;
+		if( !strcmp( argv[ i ], "+showconsole" ) )
+			continue;
 		Q_strcat( commandLine, sizeof( commandLine ), argv[ i ] );
 		Q_strcat( commandLine, sizeof( commandLine ), " " );
 	}
diff -r 91f0a3d9f930 -r 4b5fc919fd59 src/sys/sys_win32.c
--- a/src/sys/sys_win32.c	Sat Jun 06 02:45:31 2009 +0800
+++ b/src/sys/sys_win32.c	Mon Jul 06 04:07:05 2009 +0800
@@ -644,4 +644,9 @@
 
 	// Handle Ctrl-C or other console termination
 	SetConsoleCtrlHandler( CON_CtrlHandler, TRUE );
+
+	// Optionally show the console
+	extern qboolean win32_showconsole;
+	if (win32_showconsole)
+		AllocConsole();
 }
