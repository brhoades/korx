diff -r 11104731f8c9 -r 87f98d895296 .hgtags
--- a/.hgtags	Thu Feb 19 05:06:14 2009 +0800
+++ b/.hgtags	Sun Mar 29 01:15:08 2009 +0800
@@ -4,3 +4,4 @@
 00bbd0fc4f6cb563c29d7e17ba6a46d2f19111b8 0.0.2
 c9615b43aa75e07559c60c1b6a8f70b4e981cc9a 0.0.3
 766004a14b15a0c8c641b7decace3ad714a84dc3 0.9
+4135d88d07f11cc9e0527d4e6b1f389b8f4b961c 0.99
diff -r 11104731f8c9 -r 87f98d895296 Makefile
--- a/Makefile	Thu Feb 19 05:06:14 2009 +0800
+++ b/Makefile	Sun Mar 29 01:15:08 2009 +0800
@@ -1,5 +1,5 @@
 #
-# Tremfusion Makefile
+# TremFusion Makefile
 #
 # GNU Make required
 #
@@ -40,12 +40,14 @@
   BUILD_GAME_QVM   = 1
 endif
 
-# SMP only works on Mac and Windows
+# SMP only works on Mac, Linux and Windows
 ifneq ($(PLATFORM),darwin)
 ifneq ($(PLATFORM),mingw32)
+ifneq ($(PLATFORM),linux)
   BUILD_CLIENT_SMP = 0
 endif
 endif
+endif
 
 #############################################################################
 #
@@ -85,10 +87,6 @@
 endif
 export CROSS_COMPILING
 
-ifndef COPYDIR
-  COPYDIR="/usr/local/games/tremulous"
-endif
-
 ifndef MOUNT_DIR
   MOUNT_DIR=src
 endif
@@ -97,6 +95,10 @@
   BUILD_DIR=build
 endif
 
+ifndef INSTALL_PREFIX
+  INSTALL_PREFIX = "/usr/local"
+endif
+
 ifndef GENERATE_DEPENDENCIES
   GENERATE_DEPENDENCIES=1
 endif
@@ -163,14 +165,14 @@
 endif
 
 ifndef USE_OLD_HOMEPATH
-  USE_OLD_HOMEPATH=1
+  USE_OLD_HOMEPATH=0
 endif
 
 ifndef USE_SSE
   ifeq ($(ARCH),x86_64)
     USE_SSE=2
   else
-    USE_SSE=0
+    USE_SSE=1
   endif
 endif
 
@@ -219,7 +221,7 @@
 endif
 
 # version info
-VERSION_NUMBER=0.9
+VERSION_NUMBER=0.99
 
 ifeq ($(USE_SCM_VERSION),1)
   # For svn
@@ -343,6 +345,10 @@
     BASE_CFLAGS += -maltivec
     HAVE_VM_COMPILED=true
   endif
+  ifeq ($(ARCH),sparc)
+    OPTIMIZE += -mtune=ultrasparc3 -mv8plus
+    HAVE_VM_COMPILED=true
+  endif
   endif
   endif
 
@@ -351,8 +357,6 @@
   else
     ifeq ($(USE_SSE),1)
       BASE_CFLAGS += -msse -mfpmath=sse
-    else
-      BASE_CFLAGS += -U__SSE__ -U__SSE2__
     endif
   endif
 
@@ -364,7 +368,9 @@
   SHLIBCFLAGS=-fPIC
   SHLIBLDFLAGS=-shared $(LDFLAGS) --no-allow-shlib-undefined
 
-  THREAD_LIBS=-lpthread
+  BASE_CFLAGS+=-I/usr/X11R6/include
+  THREAD_LDFLAGS=-L/usr/X11R6/$(LIB)
+  THREAD_LIBS=-lpthread -lX11
   LIBS=-ldl -lm
 
   CLIENT_LIBS += $(shell sdl-config --libs) -lGL
@@ -874,7 +880,6 @@
   CC=gcc
   INSTALL=ginstall
   MKDIR=gmkdir
-  COPYDIR="/usr/local/share/games/tremulous"
 
   ifneq (,$(findstring i86pc,$(shell uname -m)))
     ARCH=x86
@@ -939,7 +944,7 @@
 
   SHLIBEXT=so
   SHLIBCFLAGS=-fPIC
-  SHLIBLDFLAGS=-shared  --no-allow-shlib-undefined
+  SHLIBLDFLAGS=-shared --no-allow-shlib-undefined
 
 endif #Linux
 endif #darwin
@@ -953,18 +958,18 @@
 TARGETS =
 
 ifneq ($(BUILD_SERVER),0)
-  TARGETS += $(B)/tremded.$(ARCH)$(BINEXT)
+  TARGETS += $(B)/tremfusionded.$(ARCH)$(BINEXT)
 endif
 
 ifneq ($(BUILD_CLIENT),0)
-  TARGETS += $(B)/tremulous.$(ARCH)$(BINEXT)
+  TARGETS += $(B)/tremfusion.$(ARCH)$(BINEXT)
   ifneq ($(BUILD_CLIENT_SMP),0)
-    TARGETS += $(B)/tremulous-smp.$(ARCH)$(BINEXT)
+    TARGETS += $(B)/tremfusion-smp.$(ARCH)$(BINEXT)
   endif
 endif
 
 ifneq ($(BUILD_CLIENT_TTY),0)
-  TARGETS += $(B)/tremulous-tty.$(ARCH)$(BINEXT)
+  TARGETS += $(B)/tremfusion-tty.$(ARCH)$(BINEXT)
 endif
 
 ifneq ($(BUILD_GAME_SO),0)
@@ -1113,7 +1118,7 @@
 # an informational message, then start building
 targets: makedirs
 	@echo ""
-	@echo "Building Tremulous in $(B):"
+	@echo "Building TremFusion in $(B):"
 	@echo "  PLATFORM: $(PLATFORM)"
 	@echo "  ARCH: $(ARCH)"
 	@echo "  VERSION: $(VERSION)"
@@ -1169,6 +1174,22 @@
 	@if [ ! -d $(B)/tools/lburg ];then $(MKDIR) $(B)/tools/lburg;fi
 
 #############################################################################
+# INSTALL
+#############################################################################
+
+install: release
+	@echo ""
+	@echo "Installing TremFusion in $(INSTALL_PREFIX):"
+	@if [ ! -d $(INSTALL_PREFIX) ];then $(MKDIR) $(INSTALL_PREFIX);fi
+	@if [ ! -d $(INSTALL_PREFIX)/lib ];then $(MKDIR) $(INSTALL_PREFIX)/lib;fi
+	@if [ ! -d $(INSTALL_PREFIX)/share ];then $(MKDIR) $(INSTALL_PREFIX)/share;fi
+	@if [ ! -d $(INSTALL_PREFIX)/lib/tremfusion ];then $(MKDIR) $(INSTALL_PREFIX)/lib/tremfusion;fi
+	@if [ ! -d $(INSTALL_PREFIX)/share/tremfusion ];then $(MKDIR) $(INSTALL_PREFIX)/share/tremfusion;fi
+	@$(Q)$(INSTALL) -v $(BR)/tremfusion.$(ARCH)$(BINEXT) $(INSTALL_PREFIX)/lib/tremfusion/tremfusion
+	@$(Q)$(INSTALL) -v misc/transfer_settings.sh $(INSTALL_PREFIX)/share/tremfusion/transfer_settings.sh
+
+
+#############################################################################
 # QVM BUILD TOOLS
 #############################################################################
 
@@ -1531,6 +1552,9 @@
   ifeq ($(ARCH),ppc64)
     Q3OBJ_ += $(B)/client/vm_powerpc.o $(B)/client/vm_powerpc_asm.o
   endif
+  ifeq ($(ARCH),sparc)
+    Q3OBJ += $(B)/client/vm_sparc.o
+  endif
 endif
 
 ifeq ($(PLATFORM),mingw32)
@@ -1558,19 +1582,19 @@
 Q3TOBJ += $(subst /client/,/clienttty/,$(Q3OBJ_))
 Q3OBJ += $(Q3OBJ_)
 
-$(B)/tremulous.$(ARCH)$(BINEXT): $(Q3OBJ) $(Q3POBJ) $(LIBSDLMAIN) $(LIBOGG) $(LIBVORBIS) $(LIBVORBISFILE) $(LIBFREETYPE)
+$(B)/tremfusion.$(ARCH)$(BINEXT): $(Q3OBJ) $(Q3POBJ) $(LIBSDLMAIN) $(LIBOGG) $(LIBVORBIS) $(LIBVORBISFILE) $(LIBFREETYPE)
 	$(echo_cmd) "LD $@"
 	$(Q)$(CC) $(CLIENT_CFLAGS) $(CFLAGS) $(CLIENT_LDFLAGS) $(LDFLAGS) \
 	    -o $@ $(Q3OBJ) $(Q3POBJ) $(CLIENT_LIBS) $(LIBS) \
         $(LIBSDLMAIN) $(LIBVORBISFILE) $(LIBVORBIS) $(LIBOGG) $(LIBFREETYPE)
 
-$(B)/tremulous-smp.$(ARCH)$(BINEXT): $(Q3OBJ) $(Q3POBJ_SMP) $(LIBSDLMAIN) $(LIBOGG) $(LIBVORBIS) $(LIBVORBISFILE) $(LIBFREETYPE)
+$(B)/tremfusion-smp.$(ARCH)$(BINEXT): $(Q3OBJ) $(Q3POBJ_SMP) $(LIBSDLMAIN) $(LIBOGG) $(LIBVORBIS) $(LIBVORBISFILE) $(LIBFREETYPE)
 	$(echo_cmd) "LD $@"
 	$(Q)$(CC) $(CLIENT_CFLAGS) $(CFLAGS) $(CLIENT_LDFLAGS) $(LDFLAGS) $(THREAD_LDFLAGS) \
-       -o $@ $(Q3OBJ) $(Q3POBJ) $(CLIENT_LIBS) $(LIBS) $(THREAD_LIBS) \
+       -o $@ $(Q3OBJ) $(Q3POBJ_SMP) $(CLIENT_LIBS) $(LIBS) $(THREAD_LIBS) \
         $(LIBSDLMAIN) $(LIBVORBISFILE) $(LIBVORBIS) $(LIBOGG) $(LIBFREETYPE)
 
-$(B)/tremulous-tty.$(ARCH)$(BINEXT): $(Q3TOBJ)
+$(B)/tremfusion-tty.$(ARCH)$(BINEXT): $(Q3TOBJ)
 	$(echo_cmd) "LD $@"
 	$(Q)$(CC) $(CFLAGS) $(TTYC_CFLAGS) $(TTYC_LDFLAGS) $(LDFLAGS) \
 	    -o $@ $(Q3TOBJ) $(TTYC_LIBS) $(LIBS)
@@ -1695,6 +1719,9 @@
   ifeq ($(ARCH),ppc64)
     Q3DOBJ += $(B)/ded/vm_powerpc.o $(B)/ded/vm_powerpc_asm.o
   endif
+  ifeq ($(ARCH),sparc)
+    Q3DOBJ += $(B)/ded/vm_sparc.o
+  endif
 endif
 
 ifeq ($(PLATFORM),mingw32)
@@ -1708,14 +1735,14 @@
     $(B)/ded/con_tty.o
 endif
 
-$(B)/tremded.$(ARCH)$(BINEXT): $(Q3DOBJ)
+$(B)/tremfusionded.$(ARCH)$(BINEXT): $(Q3DOBJ)
 	$(echo_cmd) "LD $@"
 	$(Q)$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(Q3DOBJ) $(LIBS)
 
 
 
 #############################################################################
-## TREMULOUS CGAME
+## TREMFUSION CGAME
 #############################################################################
 
 CGOBJ_ = \
@@ -1767,7 +1794,7 @@
 
 
 #############################################################################
-## TREMULOUS GAME
+## TREMFUSION GAME
 #############################################################################
 
 GOBJ_ = \
@@ -1816,7 +1843,7 @@
 
 
 #############################################################################
-## TREMULOUS UI
+## TREMFUSION UI
 #############################################################################
 
 UIOBJ_ = \
@@ -2039,12 +2066,6 @@
 distclean:
 	@rm -rf $(BUILD_DIR)
 
-dist:
-	rm -rf tremulous-$(SCM_VERSION)
-	svn export . tremulous-$(SCM_VERSION)
-	tar --owner=root --group=root --force-local -cjf tremulous-$(SCM_VERSION).tar.bz2 tremulous-$(SCM_VERSION)
-	rm -rf tremulous-$(SCM_VERSION)
-
 #############################################################################
 # DEPENDENCIES
 #############################################################################
@@ -2054,6 +2075,6 @@
 -include $(OBJ_D_FILES) $(TOOLSOBJ_D_FILES)
 
 .PHONY: all clean clean2 clean-debug clean-release copyfiles \
-	debug default dist distclean makedirs \
+	debug default distclean makedirs \
 	release targets \
 	toolsclean toolsclean2 toolsclean-debug toolsclean-release
diff -r 11104731f8c9 -r 87f98d895296 emoticons/acidtube_1x1.tga
Binary file emoticons/acidtube_1x1.tga has changed
diff -r 11104731f8c9 -r 87f98d895296 emoticons/barricade_1x1.tga
Binary file emoticons/barricade_1x1.tga has changed
diff -r 11104731f8c9 -r 87f98d895296 emoticons/egg_1x1.tga
Binary file emoticons/egg_1x1.tga has changed
diff -r 11104731f8c9 -r 87f98d895296 emoticons/hive_1x1.tga
Binary file emoticons/hive_1x1.tga has changed
diff -r 11104731f8c9 -r 87f98d895296 emoticons/overmind_1x1.tga
Binary file emoticons/overmind_1x1.tga has changed
diff -r 11104731f8c9 -r 87f98d895296 emoticons/trapper_1x1.tga
Binary file emoticons/trapper_1x1.tga has changed
diff -r 11104731f8c9 -r 87f98d895296 make-macosx-ub.sh
--- a/make-macosx-ub.sh	Thu Feb 19 05:06:14 2009 +0800
+++ b/make-macosx-ub.sh	Sun Mar 29 01:15:08 2009 +0800
@@ -1,32 +1,24 @@
 #!/bin/sh
-APPBUNDLE=Tremulous.app
-BINARY=Tremulous.ub
-DEDBIN=Tremded.ub
-PKGINFO=APPLTREM
-ICNS=misc/Tremulous.icns
+APPBUNDLE=Tremfusion.app
+BINARY=Tremfusion
+DEDBIN=Tremfusionded
+PKGINFO=APPLTREMFUSION
+ICNS=misc/Tremfusion.icns
 DESTDIR=build/release-darwin-ub
 BASEDIR=base
 
 BIN_OBJ="
-	build/release-darwin-ppc/tremulous-smp.ppc
-	build/release-darwin-x86/tremulous-smp.x86
+	build/release-darwin-ppc/tremfusion-smp.ppc
+	build/release-darwin-x86/tremfusion-smp.x86
 "
 BIN_DEDOBJ="
-	build/release-darwin-ppc/tremded.ppc
-	build/release-darwin-x86/tremded.x86
-"
-BASE_OBJ="
-	build/release-darwin-ppc/$BASEDIR/cgameppc.dylib
-	build/release-darwin-x86/$BASEDIR/cgamex86.dylib
-	build/release-darwin-ppc/$BASEDIR/uippc.dylib
-	build/release-darwin-x86/$BASEDIR/uix86.dylib
-	build/release-darwin-ppc/$BASEDIR/gameppc.dylib
-	build/release-darwin-x86/$BASEDIR/gamex86.dylib
+	build/release-darwin-ppc/tremfusionded.ppc
+	build/release-darwin-x86/tremfusionded.x86
 "
 
 cd `dirname $0`
 if [ ! -f Makefile ]; then
-	echo "This script must be run from the Tremulous build directory";
+	echo "This script must be run from the Tremfusion build directory";
 	exit 1
 fi
 
@@ -121,10 +113,12 @@
 
 # ppc client and server
 (ARCH=ppc USE_OPENAL_DLOPEN=1 CC=$PPC_CC CFLAGS=$PPC_CFLAGS \
-	LDFLAGS=$PPC_LDFLAGS make -j$NCPU BUILD_CLIENT_SMP=1 $*) || exit 1;
+	LDFLAGS=$PPC_LDFLAGS make -j$NCPU BUILD_CLIENT_SMP=1 BUILD_GAME_SO=0 \
+	BUILD_GAME_QVM=0 $*) || exit 1;
 
 # intel client and server
-(ARCH=x86 CFLAGS=$X86_CFLAGS LDFLAGS=$X86_LDFLAGS make -j$NCPU BUILD_CLIENT_SMP=1 $*) || exit 1;
+(ARCH=x86 CFLAGS=$X86_CFLAGS LDFLAGS=$X86_LDFLAGS make -j$NCPU \
+	BUILD_CLIENT_SMP=1 BUILD_GAME_SO=0 BUILD_GAME_QVM=0 $*) || exit 1;
 
 echo "Creating .app bundle $DESTDIR/$APPBUNDLE"
 if [ ! -d $DESTDIR/$APPBUNDLE/Contents/MacOS/$BASEDIR ]; then
@@ -136,7 +130,7 @@
 if [ ! -d $DESTDIR/$APPBUNDLE/Contents/Resources ]; then
 	mkdir -p $DESTDIR/$APPBUNDLE/Contents/Resources
 fi
-cp $ICNS $DESTDIR/$APPBUNDLE/Contents/Resources/Tremulous.icns || exit 1;
+cp $ICNS $DESTDIR/$APPBUNDLE/Contents/Resources/Tremfusion.icns || exit 1;
 echo $PKGINFO > $DESTDIR/$APPBUNDLE/Contents/PkgInfo
 echo "
 	<?xml version=\"1.0\" encoding=\"UTF-8\"?>
@@ -152,13 +146,13 @@
 		<key>CFBundleGetInfoString</key>
 		<string>$Q3_VERSION</string>
 		<key>CFBundleIconFile</key>
-		<string>Tremulous.icns</string>
+		<string>Tremfusion.icns</string>
 		<key>CFBundleIdentifier</key>
-		<string>net.tremulous</string>
+		<string>net.tremfusion</string>
 		<key>CFBundleInfoDictionaryVersion</key>
 		<string>6.0</string>
 		<key>CFBundleName</key>
-		<string>Tremulous</string>
+		<string>Tremfusion</string>
 		<key>CFBundlePackageType</key>
 		<string>APPL</string>
 		<key>CFBundleShortVersionString</key>
@@ -176,6 +170,5 @@
 	" > $DESTDIR/$APPBUNDLE/Contents/Info.plist
 
 lipo -create -o $DESTDIR/$APPBUNDLE/Contents/MacOS/$BINARY $BIN_OBJ
-lipo -create -o $DESTDIR/$APPBUNDLE/Contents/MacOS/$DEDBIN $BIN_DEDOBJ
+lipo -create -o $DESTDIR/$DEDBIN $BIN_DEDOBJ
 cp src/libs/macosx/*.dylib $DESTDIR/$APPBUNDLE/Contents/MacOS/
-
diff -r 11104731f8c9 -r 87f98d895296 misc/SLA-dmg.sh
--- a/misc/SLA-dmg.sh	Thu Feb 19 05:06:14 2009 +0800
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,73 +0,0 @@
-#!/bin/bash
-#
-# This script appends the text from Q3A_EULA.txt to a .dmg as a SLA resource
-#
-# usage is './SLA-dmg.sh /path/to/Q3A_EULA.txt /path/to/ioquake3.dmg'
-#
-
-if [ "x$1" = "x" ] || [ "x$2" = "x" ]; then
-	echo "usage: ./SLA-dmg.sh /path/to/Q3A_EULA.txt /path/to/ioquake3.dmg"
-	exit 1;
-fi
-
-if [ ! -r $1 ]; then
-	echo "$1 is not a readable Q3A_EULA.txt file"
-	exit 1;
-fi
-if [ ! -w $2 ]; then
-	echo "$2 is not writable .dmg file"
-	exit 1;
-fi
-touch tmp.r
-if [ ! -w tmp.r ]; then
-	echo "Could not create temporary file tmp.r for writing"
-	exit 1;
-fi
-
-echo "  
-data 'LPic' (5000) {
-    \$\"0002 0011 0003 0001 0000 0000 0002 0000\"
-    \$\"0008 0003 0000 0001 0004 0000 0004 0005\"
-    \$\"0000 000E 0006 0001 0005 0007 0000 0007\"
-    \$\"0008 0000 0047 0009 0000 0034 000A 0001\"
-    \$\"0035 000B 0001 0020 000C 0000 0011 000D\"
-    \$\"0000 005B 0004 0000 0033 000F 0001 000C\"
-    \$\"0010 0000 000B 000E 0000\"
-};
-
-data 'TEXT' (5002, \"English\") {
-" > tmp.r
-
-sed -e 's/"/\\"/g' -e 's/\(.*\)$/"\1\\n"/g' $1 >> tmp.r
-
-echo "
-};
-
-resource 'STR#' (5002, \"English\") {
-    {   
-        \"English\",
-        \"Agree\",
-        \"Disagree\",
-        \"Print\",
-        \"Save...\",
-        \"IMPORTANT - Read this License Agreement carefully before clicking on \"
-        \"the \\\"Agree\\\" button.  By clicking on the \\\"Agree\\\" button, you agree \"
-        \"to be bound by the terms of the License Agreement.\",
-        \"Software License Agreement\",
-        \"This text cannot be saved. This disk may be full or locked, or the \"
-	\"file may be locked.\",
-        \"Unable to print. Make sure you have selected a printer.\"
-    }
-};
-" >> tmp.r
-
-hdiutil convert -format UDCO -o tmp.dmg $2 || exit 1
-hdiutil unflatten tmp.dmg || exit 1
-/Developer/Tools/Rez /Developer/Headers/FlatCarbon/*.r tmp.r -a -o tmp.dmg \
-	|| exit 1
-hdiutil flatten tmp.dmg || exit 1
-hdiutil internet-enable -yes tmp.dmg || exit 1
-mv tmp.dmg $2 || (echo "Could not copy tmp.dmg to $2" && exit 1)
-rm tmp.dmg
-rm tmp.r
-echo "SLA $1 successfully added to $2"
diff -r 11104731f8c9 -r 87f98d895296 misc/TremFusion.ico
Binary file misc/TremFusion.ico has changed
diff -r 11104731f8c9 -r 87f98d895296 misc/Tremfusion.icns
Binary file misc/Tremfusion.icns has changed
diff -r 11104731f8c9 -r 87f98d895296 misc/Tremulous.icns
Binary file misc/Tremulous.icns has changed
diff -r 11104731f8c9 -r 87f98d895296 misc/run-tremfusion.sh.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/misc/run-tremfusion.sh.in	Sun Mar 29 01:15:08 2009 +0800
@@ -0,0 +1,37 @@
+#!/bin/bash
+
+BINARY=@INSTALL_PREFIX@/lib/tremfusion/$(basename $0)
+BASE_PATH="/usr/share/tremulous"
+EXTRA_PATH="@INSTALL_PREFIX@/share/tremfusion"
+QUIET=0
+
+# Transfer settings if necessary
+
+if [ -d $HOME/.tremfusion ]; then
+	exec @INSTALL_PREFIX@/share/tremfusion/transfer_settings.sh >/dev/null 2>&1 || :
+fi
+
+# TremFusion binaries don't understand "regular" command line parameters. Let's
+# catch them here, to avoid accidently launching the binary.
+
+while [ "$1" != "" ]; do {
+	if [ "$1" = "+set" -o "$1" = "+connect" ]; then
+		break;
+	fi
+	case "$1" in
+		-q|--quiet)
+			QUIET=1
+			;;
+	esac
+	shift
+}; done
+
+# Ready to rumble!
+
+if [ ${QUIET} -eq 1 ]; then
+	exec ${BINARY} +set fs_basepath ${BASE_PATH} +set fs_extrapath ${EXTRA_PATH} +set fs_extrapaks z-tremfusion-menus-0.99 $* >/dev/null 2>&1
+else
+	exec ${BINARY} +set fs_basepath ${BASE_PATH} +set fs_extrapath ${EXTRA_PATH} +set fs_extrapaks z-tremfusion-menus-0.99 $*
+fi
+
+exit $?
diff -r 11104731f8c9 -r 87f98d895296 misc/sdl-win32-fixes.diff
--- a/misc/sdl-win32-fixes.diff	Thu Feb 19 05:06:14 2009 +0800
+++ b/misc/sdl-win32-fixes.diff	Sun Mar 29 01:15:08 2009 +0800
@@ -1,6 +1,6 @@
 Index: src/video/wincommon/SDL_lowvideo.h
 ===================================================================
---- src/video/wincommon/SDL_lowvideo.h	(revision 4067)
+--- src/video/wincommon/SDL_lowvideo.h	(revision 4474)
 +++ src/video/wincommon/SDL_lowvideo.h	(working copy)
 @@ -51,10 +51,13 @@
  /* Hidden "this" pointer for the video functions */
@@ -41,9 +41,9 @@
  extern LPWSTR SDL_Appname;
 Index: src/video/wincommon/SDL_sysevents.c
 ===================================================================
---- src/video/wincommon/SDL_sysevents.c	(revision 4067)
+--- src/video/wincommon/SDL_sysevents.c	(revision 4474)
 +++ src/video/wincommon/SDL_sysevents.c	(working copy)
-@@ -335,7 +335,6 @@
+@@ -363,7 +363,6 @@
  {
  	SDL_VideoDevice *this = current_video;
  	static int mouse_pressed = 0;
@@ -51,7 +51,7 @@
  #ifdef WMMSG_DEBUG
  	fprintf(stderr, "Received windows message:  ");
  	if ( msg > MAX_WMMSG ) {
-@@ -411,62 +410,41 @@
+@@ -439,62 +438,40 @@
  		break;
  
  		case WM_MOUSEMOVE: {
@@ -59,7 +59,7 @@
 -			/* Mouse is handled by DirectInput when fullscreen */
 -			if ( SDL_VideoSurface && ! DINPUT_FULLSCREEN() ) {
 -				Sint16 x, y;
- 
+-
 -				/* mouse has entered the window */
 -				if ( ! in_window ) {
  #ifdef WM_MOUSELEAVE
@@ -100,9 +100,9 @@
 -						posted = SDL_PrivateMouseMotion(0, 1, x, y);
 -					}
 -				} else {
--#ifdef _WIN32_WCE
--					if (SDL_VideoSurface)
--						GapiTransform(this->hidden->userOrientation, this->hidden->hiresFix, &x, &y);
+-#ifdef SDL_VIDEO_DRIVER_GAPI
+-					if (SDL_VideoSurface && this->hidden->gapiInfo)
+-						GapiTransform(this->hidden->gapiInfo->coordinateTransform, this->hidden->gapiInfo->hiresFix, &x, &y);
 -#endif
 -					posted = SDL_PrivateMouseMotion(0, 0, x, y);
 -				}
@@ -127,7 +127,7 @@
  		}
  		return(0);
  #endif /* WM_MOUSELEAVE */
-@@ -480,7 +458,7 @@
+@@ -508,7 +485,7 @@
  		case WM_XBUTTONDOWN:
  		case WM_XBUTTONUP: {
  			/* Mouse is handled by DirectInput when fullscreen */
@@ -136,7 +136,7 @@
  				WORD xbuttonval = 0;
  				Sint16 x, y;
  				Uint8 button, state;
-@@ -544,20 +522,8 @@
+@@ -572,20 +549,8 @@
  						mouse_pressed = 0;
  					}
  				}
@@ -147,9 +147,9 @@
 -				} else {
 -					x = (Sint16)LOWORD(lParam);
 -					y = (Sint16)HIWORD(lParam);
--#ifdef _WIN32_WCE
--					if (SDL_VideoSurface)
--						GapiTransform(this->hidden->userOrientation, this->hidden->hiresFix, &x, &y);
+-#ifdef SDL_VIDEO_DRIVER_GAPI
+-					if (SDL_VideoSurface && this->hidden->gapiInfo)
+-						GapiTransform(this->hidden->gapiInfo->coordinateTransform, this->hidden->gapiInfo->hiresFix, &x, &y);
 -#endif
 -				}
  				posted = SDL_PrivateMouseButton(
@@ -158,7 +158,7 @@
  
  				/*
  				 * MSDN says:
-@@ -578,7 +544,7 @@
+@@ -606,7 +571,7 @@
  
  #if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
  		case WM_MOUSEWHEEL: 
@@ -169,7 +169,7 @@
  					Uint8 button;
 Index: src/video/wincommon/SDL_sysmouse.c
 ===================================================================
---- src/video/wincommon/SDL_sysmouse.c	(revision 4067)
+--- src/video/wincommon/SDL_sysmouse.c	(revision 4474)
 +++ src/video/wincommon/SDL_sysmouse.c	(working copy)
 @@ -188,8 +188,7 @@
  {
@@ -235,9 +235,9 @@
  /* Check to see if we need to enter or leave mouse relative mode */
 Index: src/video/windib/SDL_dibevents.c
 ===================================================================
---- src/video/windib/SDL_dibevents.c	(revision 4067)
+--- src/video/windib/SDL_dibevents.c	(revision 4474)
 +++ src/video/windib/SDL_dibevents.c	(working copy)
-@@ -262,6 +262,36 @@
+@@ -271,6 +271,36 @@
  	return(DefWindowProc(hwnd, msg, wParam, lParam));
  }
  
@@ -274,7 +274,7 @@
  void DIB_PumpEvents(_THIS)
  {
  	MSG msg;
-@@ -271,6 +301,10 @@
+@@ -280,6 +310,10 @@
  			DispatchMessage(&msg);
  		}
  	}
@@ -285,18 +285,24 @@
  }
  
  static HKL hLayoutUS = NULL;
-@@ -494,7 +528,7 @@
+@@ -518,8 +552,13 @@
  		Uint16	wchars[2];
  
  		GetKeyboardState(keystate);
 -		if (SDL_ToUnicode((UINT)vkey, scancode, keystate, wchars, sizeof(wchars)/sizeof(wchars[0]), 0) == 1)
-+		if (SDL_ToUnicode((UINT)vkey, scancode, keystate, wchars, sizeof(wchars)/sizeof(wchars[0]), 0) > 0)
++		/* Numlock isn't taken into account in ToUnicode, so we catch that case here */
++		if ((keystate[VK_NUMLOCK] & 1) && vkey >= VK_NUMPAD0 && vkey <= VK_NUMPAD9)
  		{
++			keysym->sym = keysym->unicode = vkey - VK_NUMPAD0 + '0';
++		}
++		else if (SDL_ToUnicode((UINT)vkey, scancode, keystate, wchars, sizeof(wchars)/sizeof(wchars[0]), 0) > 0)
++		{
  			keysym->unicode = wchars[0];
  		}
+ #endif /* NO_GETKEYBOARDSTATE */
 Index: src/video/windx5/SDL_dx5events.c
 ===================================================================
---- src/video/windx5/SDL_dx5events.c	(revision 4067)
+--- src/video/windx5/SDL_dx5events.c	(revision 4474)
 +++ src/video/windx5/SDL_dx5events.c	(working copy)
 @@ -143,9 +143,14 @@
  		(DISCL_FOREGROUND|DISCL_NONEXCLUSIVE),
@@ -538,18 +544,24 @@
  		case WM_KEYUP:
  		case WM_KEYDOWN: {
  			/* Ignore windows keyboard messages */;
-@@ -840,7 +909,7 @@
+@@ -840,8 +909,13 @@
  		keysym->unicode = vkey;
  #else
  		GetKeyboardState(keystate);
 -		if (SDL_ToUnicode(vkey, scancode, keystate, wchars, sizeof(wchars)/sizeof(wchars[0]), 0) == 1)
-+		if (SDL_ToUnicode(vkey, scancode, keystate, wchars, sizeof(wchars)/sizeof(wchars[0]), 0) > 0)
++		/* Numlock isn't taken into account in ToUnicode, so we catch that case here */
++		if ((keystate[VK_NUMLOCK] & 1) && vkey >= VK_NUMPAD0 && vkey <= VK_NUMPAD9)
  		{
++			keysym->sym = keysym->unicode = vkey - VK_NUMPAD0 + '0';
++		}
++		else if (SDL_ToUnicode(vkey, scancode, keystate, wchars, sizeof(wchars)/sizeof(wchars[0]), 0) > 0)
++		{
  			keysym->unicode = wchars[0];
  		}
+ #endif /* NO_GETKEYBOARDSTATE */
 Index: src/video/windx5/directx.h
 ===================================================================
---- src/video/windx5/directx.h	(revision 4067)
+--- src/video/windx5/directx.h	(revision 4474)
 +++ src/video/windx5/directx.h	(working copy)
 @@ -72,7 +72,7 @@
  /* We need these defines to mark what version of DirectX API we use */
@@ -583,7 +595,7 @@
  #endif /* _directx_h */
 Index: configure.in
 ===================================================================
---- configure.in	(revision 4067)
+--- configure.in	(revision 4474)
 +++ configure.in	(working copy)
 @@ -2442,7 +2442,7 @@
          # Set up the system libraries we need
diff -r 11104731f8c9 -r 87f98d895296 misc/transfer_settings.sh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/misc/transfer_settings.sh	Sun Mar 29 01:15:08 2009 +0800
@@ -0,0 +1,53 @@
+#!/bin/sh
+
+# Find the path
+if [ -d "$HOME/.tremulous" ]; then
+	SRCDIR="$HOME/.tremulous"
+	DESTDIR="$HOME/.tremfusion"
+else
+	echo "Tremulous home directory could not be found."
+	exit 1
+fi
+
+echo "Tremulous home directory found at $SRCDIR"
+echo "Copying settings to $DESTDIR"
+
+mkdir -p $DESTDIR
+cd $SRCDIR
+
+# Copy directory structure
+echo "Copying directory structure..."
+find * -type d \
+	-exec mkdir $DESTDIR/{} \;
+
+# Hard link all the read-only stuff
+echo "Hard-linking large files..."
+find * \( -type f -o -type l \) \
+	\( -name \*.pk3 \
+	-o -name \*.jpg \
+	-o -name \*.tga \
+	-o -name \*.svdm_\* \
+	-o -name \*.dm_\* \
+	-o -name \*.avi \) \
+	-exec ln {} $DESTDIR/{} \;
+	
+# Copy the rest
+echo "Copying small files..."
+find * \( -type f -o -type l \) \
+	! -name \*.pk3 \
+	! -name \*.jpg \
+	! -name \*.tga \
+	! -name \*.svdm_\* \
+	! -name \*.dm_\* \
+	! -name \*.tmp \
+	! -name \*.avi \
+	-exec cp -dp {} $DESTDIR/{} \;
+
+# Fix some setting
+echo "Fixing autogen.cfg..."
+sed -e 's/seta\ cl_defaultUI\ \"[^\"]*\"//' \
+	-e 's/seta\ fs_extrapaks\ \"[^\"]*\"//' \
+	-e 's/seta\ s_alDriver\ \"[^\"]*\"//' \
+	autogen.cfg > $DESTDIR/autogen.cfg
+
+echo "Done."
diff -r 11104731f8c9 -r 87f98d895296 misc/tremfusion.desktop
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/misc/tremfusion.desktop	Sun Mar 29 01:15:08 2009 +0800
@@ -0,0 +1,9 @@
+[Desktop Entry]
+Encoding=UTF-8
+Name=TremFusion
+Comment=Enhanced Tremulous client.
+Exec=tremfusion --quiet
+Icon=tremfusion
+Terminal=false
+Type=Application
+Categories=Game;ActionGame;
diff -r 11104731f8c9 -r 87f98d895296 misc/tremfusion.ico
Binary file misc/tremfusion.ico has changed
diff -r 11104731f8c9 -r 87f98d895296 misc/tremfusion.png
Binary file misc/tremfusion.png has changed
diff -r 11104731f8c9 -r 87f98d895296 misc/tremfusion.xpm
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/misc/tremfusion.xpm	Sun Mar 29 01:15:08 2009 +0800
@@ -0,0 +1,962 @@
+/* XPM */
+static char * tremfusion_xpm[] = {
+"48 48 911 2",
+"  	c None",
+". 	c #3C727E",
+"+ 	c #2C565C",
+"@ 	c #204447",
+"# 	c #1A3A3C",
+"$ 	c #173536",
+"% 	c #1A3D3F",
+"& 	c #193C3E",
+"* 	c #163536",
+"= 	c #1E4042",
+"- 	c #2B5256",
+"; 	c #3B6C76",
+"> 	c #366A74",
+", 	c #386E76",
+"' 	c #34676F",
+") 	c #1A3F42",
+"! 	c #0E2323",
+"~ 	c #275357",
+"{ 	c #112B2C",
+"] 	c #102C2C",
+"^ 	c #133537",
+"/ 	c #133435",
+"( 	c #14383A",
+"_ 	c #0F2728",
+": 	c #0E2525",
+"< 	c #10292A",
+"[ 	c #1C3D3F",
+"} 	c #316169",
+"| 	c #143132",
+"1 	c #2B5D61",
+"2 	c #33686F",
+"3 	c #346A72",
+"4 	c #275155",
+"5 	c #2F5C62",
+"6 	c #407C8B",
+"7 	c #173638",
+"8 	c #133739",
+"9 	c #0E2424",
+"0 	c #0F2627",
+"a 	c #294F55",
+"b 	c #112A2B",
+"c 	c #254A4E",
+"d 	c #3E7786",
+"e 	c #386D79",
+"f 	c #14393B",
+"g 	c #30646B",
+"h 	c #153839",
+"i 	c #112F30",
+"j 	c #0F2829",
+"k 	c #102828",
+"l 	c #122D2E",
+"m 	c #142F30",
+"n 	c #325F67",
+"o 	c #2F5A62",
+"p 	c #23474A",
+"q 	c #123031",
+"r 	c #112C2D",
+"s 	c #102929",
+"t 	c #0F292A",
+"u 	c #113031",
+"v 	c #33646D",
+"w 	c #417885",
+"x 	c #32616A",
+"y 	c #32626C",
+"z 	c #407D8C",
+"A 	c #3E7887",
+"B 	c #295055",
+"C 	c #164548",
+"D 	c #0F2626",
+"E 	c #123132",
+"F 	c #143739",
+"G 	c #123436",
+"H 	c #1C4547",
+"I 	c #244A4D",
+"J 	c #2A5359",
+"K 	c #366973",
+"L 	c #2D5A61",
+"M 	c #1A3B3D",
+"N 	c #13383A",
+"O 	c #1D4E51",
+"P 	c #102A2B",
+"Q 	c #0F2727",
+"R 	c #102B2C",
+"S 	c #183638",
+"T 	c #274E52",
+"U 	c #2A565C",
+"V 	c #123435",
+"W 	c #1E3F42",
+"X 	c #264B50",
+"Y 	c #1F5358",
+"Z 	c #24585D",
+"` 	c #123335",
+" .	c #1A494C",
+"..	c #1B5155",
+"+.	c #19474A",
+"@.	c #28595D",
+"#.	c #17383A",
+"$.	c #29585C",
+"%.	c #215358",
+"&.	c #255054",
+"*.	c #143C3F",
+"=.	c #0F2525",
+"-.	c #163435",
+";.	c #204143",
+">.	c #1A393A",
+",.	c #18393B",
+"'.	c #2A575E",
+").	c #2E5D65",
+"!.	c #17474A",
+"~.	c #163839",
+"{.	c #3C7481",
+"].	c #295155",
+"^.	c #254E51",
+"/.	c #245053",
+"(.	c #215D61",
+"_.	c #2D6166",
+":.	c #2A5F64",
+"<.	c #337079",
+"[.	c #1D575B",
+"}.	c #25585C",
+"|.	c #265E62",
+"1.	c #205C61",
+"2.	c #275D61",
+"3.	c #153C3E",
+"4.	c #2C5F64",
+"5.	c #378291",
+"6.	c #346C74",
+"7.	c #184244",
+"8.	c #102C2D",
+"9.	c #173435",
+"0.	c #305F67",
+"a.	c #102829",
+"b.	c #2C5860",
+"c.	c #376B76",
+"d.	c #22494C",
+"e.	c #193B3D",
+"f.	c #356872",
+"g.	c #23494C",
+"h.	c #1C565B",
+"i.	c #245D62",
+"j.	c #245B60",
+"k.	c #2B5E63",
+"l.	c #34727B",
+"m.	c #2A5E63",
+"n.	c #327681",
+"o.	c #377E8D",
+"p.	c #295F63",
+"q.	c #336E78",
+"r.	c #336C74",
+"s.	c #31666E",
+"t.	c #31666C",
+"u.	c #31676E",
+"v.	c #194244",
+"w.	c #1E4B4E",
+"x.	c #1B4345",
+"y.	c #376872",
+"z.	c #31626B",
+"A.	c #143032",
+"B.	c #295156",
+"C.	c #1D3E40",
+"D.	c #153E41",
+"E.	c #235C60",
+"F.	c #2B5B61",
+"G.	c #346D74",
+"H.	c #24585C",
+"I.	c #2B5E62",
+"J.	c #387984",
+"K.	c #35737F",
+"L.	c #3B8392",
+"M.	c #2E6065",
+"N.	c #336971",
+"O.	c #347984",
+"P.	c #31656B",
+"Q.	c #245356",
+"R.	c #205357",
+"S.	c #316871",
+"T.	c #336A72",
+"U.	c #2F6167",
+"V.	c #32686E",
+"W.	c #2E6267",
+"X.	c #3B707A",
+"Y.	c #234E53",
+"Z.	c #112E2F",
+"`.	c #214447",
+" +	c #113032",
+".+	c #2A5458",
+"++	c #102D2D",
+"@+	c #17494D",
+"#+	c #1B5C61",
+"$+	c #2F6369",
+"%+	c #285E63",
+"&+	c #1A4E52",
+"*+	c #31646A",
+"=+	c #2D5E64",
+"-+	c #184C50",
+";+	c #1A4F53",
+">+	c #265A5F",
+",+	c #316870",
+"'+	c #1E484B",
+")+	c #30646A",
+"!+	c #337B87",
+"~+	c #336D75",
+"{+	c #2E6067",
+"]+	c #2B5559",
+"^+	c #183B3C",
+"/+	c #23474B",
+"(+	c #194649",
+"_+	c #224A4C",
+":+	c #2F5A60",
+"<+	c #1D5155",
+"[+	c #32686F",
+"}+	c #1D585D",
+"|+	c #254F53",
+"1+	c #215A5E",
+"2+	c #225D61",
+"3+	c #1C474A",
+"4+	c #1E5C61",
+"5+	c #367680",
+"6+	c #336C75",
+"7+	c #34717A",
+"8+	c #336970",
+"9+	c #3B7B89",
+"0+	c #36737E",
+"a+	c #347B89",
+"b+	c #337680",
+"c+	c #2A5559",
+"d+	c #3D7786",
+"e+	c #163A3B",
+"f+	c #386E79",
+"g+	c #22484B",
+"h+	c #396D76",
+"i+	c #3C7583",
+"j+	c #1E494D",
+"k+	c #225B60",
+"l+	c #2D5F65",
+"m+	c #285E62",
+"n+	c #3C8492",
+"o+	c #336B73",
+"p+	c #2A595F",
+"q+	c #398695",
+"r+	c #1F5C61",
+"s+	c #235D61",
+"t+	c #34808D",
+"u+	c #327C8A",
+"v+	c #2F7B89",
+"w+	c #307B89",
+"x+	c #348392",
+"y+	c #317F8D",
+"z+	c #347A86",
+"A+	c #2B5F64",
+"B+	c #346D76",
+"C+	c #2D5B60",
+"D+	c #264E52",
+"E+	c #0F2828",
+"F+	c #1C3E41",
+"G+	c #38707D",
+"H+	c #1F474A",
+"I+	c #347986",
+"J+	c #295D62",
+"K+	c #326A73",
+"L+	c #388190",
+"M+	c #205B60",
+"N+	c #4291A3",
+"O+	c #408FA3",
+"P+	c #34717C",
+"Q+	c #347884",
+"R+	c #348290",
+"S+	c #336F78",
+"T+	c #337A87",
+"U+	c #398E9E",
+"V+	c #388B9B",
+"W+	c #307C8A",
+"X+	c #307C8B",
+"Y+	c #338291",
+"Z+	c #378696",
+"`+	c #327782",
+" @	c #336F7A",
+".@	c #2C5E63",
+"+@	c #3E7783",
+"@@	c #3F7B8A",
+"#@	c #2E5F66",
+"$@	c #204B4E",
+"%@	c #336168",
+"&@	c #326067",
+"*@	c #33747F",
+"=@	c #31747F",
+"-@	c #336E77",
+";@	c #326E79",
+">@	c #338191",
+",@	c #377884",
+"'@	c #368A99",
+")@	c #398C9D",
+"!@	c #3A8FA0",
+"~@	c #4A9AB1",
+"{@	c #3E91A4",
+"]@	c #4192A7",
+"^@	c #418DA0",
+"/@	c #367C8A",
+"(@	c #31808E",
+"_@	c #368B9B",
+":@	c #3D90A2",
+"<@	c #338392",
+"[@	c #338493",
+"}@	c #358190",
+"|@	c #2C5D63",
+"1@	c #33646C",
+"2@	c #24494D",
+"3@	c #132F30",
+"4@	c #194143",
+"5@	c #3C7782",
+"6@	c #337987",
+"7@	c #377A86",
+"8@	c #326F79",
+"9@	c #337E8D",
+"0@	c #317F8E",
+"a@	c #408C9E",
+"b@	c #387884",
+"c@	c #3A828F",
+"d@	c #3D91A3",
+"e@	c #388D9D",
+"f@	c #357781",
+"g@	c #1D4346",
+"h@	c #2A575B",
+"i@	c #356A71",
+"j@	c #326D76",
+"k@	c #377E8B",
+"l@	c #3A7681",
+"m@	c #4E9EB7",
+"n@	c #367681",
+"o@	c #3C8696",
+"p@	c #378494",
+"q@	c #327B87",
+"r@	c #305F65",
+"s@	c #3E7D8D",
+"t@	c #122D2D",
+"u@	c #386C78",
+"v@	c #164649",
+"w@	c #275055",
+"x@	c #366971",
+"y@	c #346C75",
+"z@	c #5BABCD",
+"A@	c #4293A8",
+"B@	c #3C899B",
+"C@	c #4899B0",
+"D@	c #509DBB",
+"E@	c #38737E",
+"F@	c #4291A4",
+"G@	c #3E91A3",
+"H@	c #346F79",
+"I@	c #3F92A5",
+"J@	c #4A9BB2",
+"K@	c #3A6C75",
+"L@	c #458495",
+"M@	c #2E6168",
+"N@	c #398392",
+"O@	c #336B75",
+"P@	c #398B9C",
+"Q@	c #2F646C",
+"R@	c #1A3C3E",
+"S@	c #366870",
+"T@	c #1C5054",
+"U@	c #2A545A",
+"V@	c #376E77",
+"W@	c #3C889A",
+"X@	c #4999B0",
+"Y@	c #4295A9",
+"Z@	c #397884",
+"`@	c #428FA3",
+" #	c #5CACCD",
+".#	c #4E9DB6",
+"+#	c #316B74",
+"@#	c #4697AC",
+"##	c #3E90A3",
+"$#	c #3A8D9E",
+"%#	c #4393A8",
+"&#	c #398797",
+"*#	c #33808C",
+"=#	c #32646A",
+"-#	c #2C565B",
+";#	c #2F707A",
+">#	c #327B88",
+",#	c #3C7581",
+"'#	c #2F5A61",
+")#	c #2B545B",
+"!#	c #36666D",
+"~#	c #1D5053",
+"{#	c #3D7380",
+"]#	c #3D7885",
+"^#	c #4C9DB5",
+"/#	c #57A6C6",
+"(#	c #55A6C6",
+"_#	c #5EABCE",
+":#	c #275257",
+"<#	c #29565B",
+"[#	c #3E7B8C",
+"}#	c #40889B",
+"|#	c #4294A8",
+"1#	c #4898AF",
+"2#	c #4797AE",
+"3#	c #51A0BB",
+"4#	c #4C9CB5",
+"5#	c #36747F",
+"6#	c #3A6F7A",
+"7#	c #1F4144",
+"8#	c #438394",
+"9#	c #2F5E65",
+"0#	c #2F7A88",
+"a#	c #346972",
+"b#	c #488596",
+"c#	c #28555A",
+"d#	c #23484B",
+"e#	c #2B595E",
+"f#	c #285054",
+"g#	c #427C89",
+"h#	c #3F92A6",
+"i#	c #3F90A3",
+"j#	c #327D8C",
+"k#	c #254B4E",
+"l#	c #214042",
+"m#	c #234C50",
+"n#	c #3B808E",
+"o#	c #4D9AB5",
+"p#	c #4C9DB7",
+"q#	c #4697AB",
+"r#	c #448A9E",
+"s#	c #3B8C9D",
+"t#	c #376C75",
+"u#	c #2A5257",
+"v#	c #2D5C62",
+"w#	c #36676E",
+"x#	c #2F7A89",
+"y#	c #357785",
+"z#	c #376D76",
+"A#	c #325A5F",
+"B#	c #254E52",
+"C#	c #284F53",
+"D#	c #3B717C",
+"E#	c #3C8EA0",
+"F#	c #438EA2",
+"G#	c #32656D",
+"H#	c #3A6E78",
+"I#	c #41737E",
+"J#	c #234345",
+"K#	c #31747E",
+"L#	c #29595F",
+"M#	c #4495AA",
+"N#	c #368493",
+"O#	c #4F9EB9",
+"P#	c #4C9BB3",
+"Q#	c #396C75",
+"R#	c #3E7A89",
+"S#	c #21484B",
+"T#	c #326268",
+"U#	c #377078",
+"V#	c #499AB2",
+"W#	c #34646B",
+"X#	c #3D7582",
+"Y#	c #3C7582",
+"Z#	c #325E66",
+"`#	c #3A6F79",
+" $	c #388999",
+".$	c #4B9AB1",
+"+$	c #285459",
+"@$	c #407F90",
+"#$	c #38676F",
+"$$	c #4B9AB2",
+"%$	c #4A99B0",
+"&$	c #2E6269",
+"*$	c #3B7682",
+"=$	c #1F484B",
+"-$	c #35636C",
+";$	c #255356",
+">$	c #4B8EA3",
+",$	c #346F77",
+"'$	c #3A8B9C",
+")$	c #357C88",
+"!$	c #4494A9",
+"~$	c #3C7F8C",
+"{$	c #3F7480",
+"]$	c #3B7883",
+"^$	c #4091A4",
+"/$	c #2C5C61",
+"($	c #4B99B2",
+"_$	c #4897AE",
+":$	c #2E5A60",
+"<$	c #427E8E",
+"[$	c #2E5D63",
+"}$	c #3D7782",
+"|$	c #4491A5",
+"1$	c #3B8798",
+"2$	c #317C8A",
+"3$	c #2D575C",
+"4$	c #306267",
+"5$	c #378594",
+"6$	c #39747F",
+"7$	c #317E8D",
+"8$	c #4594A9",
+"9$	c #3F8C9D",
+"0$	c #34636D",
+"a$	c #376B75",
+"b$	c #3C818F",
+"c$	c #3F889A",
+"d$	c #4B9CB5",
+"e$	c #4697AD",
+"f$	c #3B8898",
+"g$	c #305C62",
+"h$	c #427E8D",
+"i$	c #2C595D",
+"j$	c #328291",
+"k$	c #2C595F",
+"l$	c #417684",
+"m$	c #468190",
+"n$	c #437D8A",
+"o$	c #366E78",
+"p$	c #2C5C62",
+"q$	c #2F7380",
+"r$	c #306770",
+"s$	c #275256",
+"t$	c #19383A",
+"u$	c #2C5A5F",
+"v$	c #3A7A86",
+"w$	c #3E747F",
+"x$	c #2A5558",
+"y$	c #3C6C76",
+"z$	c #346E77",
+"A$	c #4E9FB9",
+"B$	c #3B8E9F",
+"C$	c #386A72",
+"D$	c #4394A8",
+"E$	c #4294A9",
+"F$	c #377D89",
+"G$	c #357A87",
+"H$	c #30717C",
+"I$	c #2F7987",
+"J$	c #306E78",
+"K$	c #35676F",
+"L$	c #23494D",
+"M$	c #2E5B61",
+"N$	c #3A707C",
+"O$	c #3C7580",
+"P$	c #376B74",
+"Q$	c #32646C",
+"R$	c #316065",
+"S$	c #437F90",
+"T$	c #387C88",
+"U$	c #376A73",
+"V$	c #3C7783",
+"W$	c #3F8C9E",
+"X$	c #3A808E",
+"Y$	c #295458",
+"Z$	c #2C555B",
+"`$	c #37737E",
+" %	c #3B8EA0",
+".%	c #388C9D",
+"+%	c #378B9B",
+"@%	c #358796",
+"#%	c #317884",
+"$%	c #326069",
+"%%	c #366974",
+"&%	c #3E7885",
+"*%	c #4797AD",
+"=%	c #3D7F8D",
+"-%	c #3E707C",
+";%	c #3B737F",
+">%	c #3B737E",
+",%	c #368494",
+"'%	c #357783",
+")%	c #2C595E",
+"!%	c #407B89",
+"~%	c #34656C",
+"{%	c #34666C",
+"]%	c #3E7B88",
+"^%	c #4394A9",
+"/%	c #348696",
+"(%	c #32818F",
+"_%	c #328392",
+":%	c #31818F",
+"<%	c #2B5B62",
+"[%	c #376C77",
+"}%	c #427F8E",
+"|%	c #2F5B62",
+"1%	c #3B7E8C",
+"2%	c #37656C",
+"3%	c #316068",
+"4%	c #376D75",
+"5%	c #36656D",
+"6%	c #264B4E",
+"7%	c #3B737D",
+"8%	c #3C7480",
+"9%	c #397F8C",
+"0%	c #458292",
+"a%	c #2B565B",
+"b%	c #386C77",
+"c%	c #417B89",
+"d%	c #31666D",
+"e%	c #39737E",
+"f%	c #315D62",
+"g%	c #3F7B89",
+"h%	c #327884",
+"i%	c #2F7683",
+"j%	c #22484C",
+"k%	c #306B74",
+"l%	c #377783",
+"m%	c #30626B",
+"n%	c #356E78",
+"o%	c #3B747F",
+"p%	c #37676F",
+"q%	c #335E64",
+"r%	c #336D77",
+"s%	c #265256",
+"t%	c #396F78",
+"u%	c #376C76",
+"v%	c #35656C",
+"w%	c #224A4D",
+"x%	c #34636A",
+"y%	c #386B74",
+"z%	c #3A707A",
+"A%	c #1B555A",
+"B%	c #2F585E",
+"C%	c #31646D",
+"D%	c #30656E",
+"E%	c #418899",
+"F%	c #35727D",
+"G%	c #356D76",
+"H%	c #3F7786",
+"I%	c #366C75",
+"J%	c #326770",
+"K%	c #4998AF",
+"L%	c #316066",
+"M%	c #397581",
+"N%	c #3B7985",
+"O%	c #2E4A4D",
+"P%	c #326771",
+"Q%	c #306369",
+"R%	c #3D7E8C",
+"S%	c #458FA4",
+"T%	c #3E7683",
+"U%	c #437F8E",
+"V%	c #37707A",
+"W%	c #244A4E",
+"X%	c #295A5E",
+"Y%	c #3E7682",
+"Z%	c #1D4245",
+"`%	c #386A73",
+" &	c #3F7783",
+".&	c #3C8291",
+"+&	c #305E66",
+"@&	c #24474A",
+"#&	c #133031",
+"$&	c #234A4E",
+"%&	c #27494B",
+"&&	c #418698",
+"*&	c #3A636A",
+"=&	c #3D7581",
+"-&	c #3A717C",
+";&	c #376A74",
+">&	c #1D4649",
+",&	c #34727D",
+"'&	c #1E474A",
+")&	c #33646E",
+"!&	c #32636A",
+"~&	c #3A7380",
+"{&	c #458394",
+"]&	c #3D8290",
+"^&	c #39676E",
+"/&	c #3A7884",
+"(&	c #21494C",
+"_&	c #183739",
+":&	c #274B4E",
+"<&	c #3A646B",
+"[&	c #316269",
+"}&	c #33626A",
+"|&	c #378998",
+"1&	c #397580",
+"2&	c #386E77",
+"3&	c #428698",
+"4&	c #3C8595",
+"5&	c #224C4F",
+"6&	c #3B727C",
+"7&	c #4E9DB8",
+"8&	c #2E585F",
+"9&	c #3D7783",
+"0&	c #3A6D76",
+"a&	c #3F8494",
+"b&	c #365D62",
+"c&	c #3B696F",
+"d&	c #315C63",
+"e&	c #477680",
+"f&	c #306169",
+"g&	c #406E77",
+"h&	c #3A727F",
+"i&	c #305E64",
+"j&	c #396E77",
+"k&	c #31808F",
+"l&	c #34686E",
+"m&	c #265156",
+"n&	c #3F7A87",
+"o&	c #2E6369",
+"p&	c #346770",
+"q&	c #468596",
+"r&	c #2B585E",
+"s&	c #224244",
+"t&	c #3C707A",
+"u&	c #3F7C89",
+"v&	c #438190",
+"w&	c #35666E",
+"x&	c #3B727D",
+"y&	c #3E7C8C",
+"z&	c #376870",
+"A&	c #396F79",
+"B&	c #3F7079",
+"C&	c #2F575C",
+"D&	c #265356",
+"E&	c #29575D",
+"F&	c #31646B",
+"G&	c #2D5A5F",
+"H&	c #3E7A86",
+"I&	c #346F78",
+"J&	c #2E6066",
+"K&	c #37727D",
+"L&	c #447D8B",
+"M&	c #386A74",
+"N&	c #306168",
+"O&	c #35676E",
+"P&	c #3D6E77",
+"Q&	c #3D7684",
+"R&	c #427E8C",
+"S&	c #28565A",
+"T&	c #1B4F53",
+"U&	c #275E62",
+"V&	c #3E7784",
+"W&	c #398291",
+"X&	c #428899",
+"Y&	c #418393",
+"Z&	c #457F8D",
+"`&	c #377580",
+" *	c #3D656B",
+".*	c #38717B",
+"+*	c #3F7988",
+"@*	c #3A7886",
+"#*	c #33676E",
+"$*	c #295E63",
+"%*	c #33666D",
+"&*	c #448495",
+"**	c #33656C",
+"=*	c #3F7C8A",
+"-*	c #43879A",
+";*	c #478192",
+">*	c #36707A",
+",*	c #40656C",
+"'*	c #3F92A4",
+")*	c #397782",
+"!*	c #3F7A88",
+"~*	c #3F747E",
+"{*	c #2F5C63",
+"]*	c #2E5E66",
+"^*	c #378898",
+"/*	c #275559",
+"(*	c #386770",
+"_*	c #26565A",
+":*	c #2A5B61",
+"<*	c #396B74",
+"[*	c #265559",
+"}*	c #1F4D50",
+"|*	c #3A7682",
+"1*	c #3B8D9E",
+"2*	c #1B3E40",
+"3*	c #37585C",
+"4*	c #315F66",
+"5*	c #25484B",
+"6*	c #3A676F",
+"7*	c #447581",
+"8*	c #32656C",
+"9*	c #32636B",
+"0*	c #3F6971",
+"a*	c #368290",
+"b*	c #388C9C",
+"c*	c #3C8D9D",
+"d*	c #2F636A",
+"e*	c #34656D",
+"f*	c #2C585D",
+"g*	c #35717B",
+"h*	c #2D5358",
+"i*	c #214F53",
+"j*	c #397481",
+"k*	c #2F737F",
+"l*	c #30737F",
+"m*	c #336972",
+"n*	c #28565B",
+"o*	c #2F5D65",
+"p*	c #376267",
+"q*	c #467C89",
+"r*	c #366B72",
+"s*	c #356066",
+"t*	c #33727C",
+"u*	c #317987",
+"v*	c #326971",
+"w*	c #1D5256",
+"x*	c #285155",
+"y*	c #2E5C64",
+"z*	c #1E484C",
+"A*	c #27595E",
+"B*	c #3A6A73",
+"C*	c #2A585E",
+"D*	c #214C4F",
+"E*	c #38717E",
+"F*	c #39727D",
+"G*	c #3D8EA0",
+"H*	c #3C8D9E",
+"I*	c #337580",
+"J*	c #32808F",
+"K*	c #1F4D51",
+"L*	c #1B3C3F",
+"M*	c #325356",
+"N*	c #2B5458",
+"O*	c #375D62",
+"P*	c #3E8DA0",
+"Q*	c #3A8696",
+"R*	c #336D76",
+"S*	c #386D78",
+"T*	c #245457",
+"U*	c #2E5B63",
+"V*	c #26585D",
+"W*	c #204F52",
+"X*	c #3A707B",
+"Y*	c #1E494C",
+"Z*	c #1E575B",
+"`*	c #2F6268",
+" =	c #1A5357",
+".=	c #274A4D",
+"+=	c #324F52",
+"@=	c #2D5E63",
+"#=	c #265054",
+"$=	c #316972",
+"%=	c #328391",
+"&=	c #2B585D",
+"*=	c #336B76",
+"==	c #1B484B",
+"-=	c #284E52",
+";=	c #3B7381",
+">=	c #204649",
+",=	c #327C89",
+"'=	c #1F5A5F",
+")=	c #2B6065",
+"!=	c #1B494C",
+"~=	c #33747D",
+"{=	c #348796",
+"]=	c #235D62",
+"^=	c #20585D",
+"/=	c #2F636C",
+"(=	c #2C555A",
+"_=	c #398A9B",
+":=	c #348695",
+"<=	c #368A9A",
+"[=	c #2D6066",
+"}=	c #33717B",
+"|=	c #2F6368",
+"1=	c #2A5358",
+"2=	c #3E7684",
+"3=	c #336870",
+"4=	c #28585C",
+"5=	c #2D5F66",
+"6=	c #3F8493",
+"7=	c #356E77",
+"8=	c #2B5C61",
+"9=	c #438292",
+"0=	c #316067",
+"a=	c #2B595D",
+"b=	c #316167",
+"c=	c #326066",
+"d=	c #274F53",
+"e=	c #295358",
+"f=	c #325F66",
+"g=	c #468291",
+"h=	c #407A88",
+"i=	c #305B60",
+"j=	c #48889B",
+"k=	c #418596",
+"l=	c #3D8494",
+"m=	c #4590A7",
+"n=	c #4395AA",
+"o=	c #2C5B62",
+"p=	c #346870",
+"q=	c #2E6266",
+"r=	c #2D585E",
+"s=	c #325B62",
+"t=	c #2C5A5E",
+"u=	c #34747E",
+"v=	c #356B74",
+"w=	c #3C7986",
+"x=	c #458393",
+"y=	c #3D7D8A",
+"z=	c #366F7A",
+"A=	c #184245",
+"B=	c #234B4F",
+"C=	c #1B3F42",
+"D=	c #3B8391",
+"E=	c #1A4446",
+"F=	c #27565A",
+"G=	c #386E78",
+"H=	c #305A60",
+"I=	c #3F7885",
+"J=	c #437B88",
+"K=	c #3F7F90",
+"L=	c #3D7C88",
+"M=	c #3F7580",
+"N=	c #416F79",
+"O=	c #487F8E",
+"P=	c #4A8495",
+"Q=	c #376C74",
+"R=	c #3D7481",
+"                                    . + @ # $ % & * $ = - ;                                     ",
+"                              > , ' ) ! ! ~ { ] ^ / ( _ : ! < [ }                               ",
+"                          + | 1 2 3 4 5 6   7 8 9 < ! : 0 9 ! ! ! { a                           ",
+"                          * b c d         e f g ^ h i j ! ! ! k l 9 9 m n                       ",
+"                          o               p 9 q r s ! ! t u _ v   w x y z                       ",
+"                A                       B 9 0 C ^ ! u D E F G H I J K                           ",
+"              L [                     M ! ! ! N O ! P Q ! j R 8 ! ! ! D S T                     ",
+"            U V W                 X Y Z `  .j C ..+.@.#.$.%.&.*.=.! ! ! -.;.>.l ,.'.            ",
+"          ).!.~.{.            ].^./.(._.:.<.[.}.|.1.2.3.4.5.6.7.!.8.! 9.      0.a.9 b.          ",
+"        c.d.e.f.            g.h.!.i.j.k.l.m.n.o.p.q.r.s.t.u.v.N w.x.h y.        z.9 P f.        ",
+"        A.! B.            C.D.E.F.G.H.I.J.K.L.M.N.O.P.Q.R.S.T.U.V.W.X.            Y.Z.|         ",
+"      `. +C.            .+++@+#+$+%+&+j.*+m.=+-+;+>+,+'+)+!+~+p.{+1.]+              ^+=./+      ",
+"    > (+_+            :+p.<+i.1.W.[+}+|+1+2+%.3+4+m.5+q.6+7+8+9+0+a+b+c+            d+q e+f+    ",
+"    g+& h+          i+j+k+i.l+m+k.n+o+p+2 i.$+q+r+s+t+u+v+w+x+y+z+A+B+C+              D+E+F+    ",
+"  G+8 H+            + [+I+J+K+L+M+N+O+P+Q+R+r.S+T+r.U+V+W+X+Y+Z+`+ @.@+@                { Q @@  ",
+"  #@$@%@            &@*@=@-@;@>@,@'@)@!@~@{@]@^@{+/@(@_@)@:@<@[@}@|@1@                  |+_ 2@  ",
+"  3@4@              5@6@7@8@9@0@a@b@c@d@e@f@g@h@i@j@k@l@m@n@o@p@q@r@                    s@_ t@  ",
+"u@v@w@              x@y@z@A@B@C@D@E@F@G@U+k@,@H@I@J@K@L@M@N@O@P@Q@                        R@! . ",
+"S@T@U@              V@W@X@Y@Z@`@ #.#+#@###Y+$#%#&#*#=#  r@-#;#>#,#                        '#++)#",
+"!#~#{#              ]#^#/#(#_#:#<#[#}#^#|#1#2#3#4#5#6#  7#8#9#0#a#                        b#c#d#",
+"e#f#                g#h#i#j#k#l#P m#n#o#p#{@q#r#s#t#  u#v#  w#x#y#z#                        A#I ",
+"B#C#                D#E#F#G#H#  I#J#K#L#M#|#N#O#P#Q#R#S#T#  U#V#W#X#                            ",
+"Y#Z#                `# $.$+$@$      #$S#$$%$&$%$%$*$=$-$;$>$,$'$S.                              ",
+"                    X#)$!$~$          {$]$^$/$($%$_$:$<$[$}$|$1$2$3$                            ",
+"                      4$Y+5$6$          K+7$D+p 8$9$0$  a$b$c$d$e$f$g$h$                        ",
+"                      i$y+j$k$l$m$n$o$p$q$r$s$t$u$v$w$  x$y$z$A$~@X@B$C$                        ",
+"                      , D$%$E$F$G$H$I$I$J$K$L$M$N$O$P$Q$R$S$T$U$V$W$X$B+                    Y$Z$",
+"                      `$|# %.%+%M#E#@%#%9#  $%@ %%&%*%=%-%2@;%  >%,%'%)%!%u@                ~%{%",
+"                      ]%^%/%(%0#_%:%I$<%  [%}%|%1%2%3%4%5%6%7%8%' 9%]+0%a%b%              c%d%e%",
+"f%n                   g%h%0#:%W+i%j%k%l%m%n%h+o%%$p%q%r%T.s%  t%%$u%  v%w%                x%%+y%",
+"z%A%B%                  C%D%E%F%G%H%I%J%K%%$L%M%N%O%5#P%2%Q%!%R%S%T%U%V%W%                c+X%Y%",
+"  %+Z%                      `%     &.&+&B.@&#&$&%&&&!#B#*&k$=&5#-&  ;&V$                  w.>&  ",
+"  ,&'&)&                    !&M$~&{&]&^&/&(&2%_&:&g+<&[&}&        :+|&1&                k$`+2&  ",
+"  3&4&5&                    6&7&8&  9&0&a&b&c&d&e&f&g&h&i&        j&k&l&                m&,+n&  ",
+"    o&[.p&                  q&r&s&t&u&v&w&x&y&z&  A&B&            C&T.D&              E&F&G&    ",
+"    H&I&J&                    K&P$w$L&7%M&N&O&P&  Q&            R&f#=@S&              T&U&V&    ",
+"      z#W&{+                  X&Y&Z&5@`& *[@.*        N$    +*M@@*9+Y+#*            <#$*%*      ",
+"      &***k$b%                =*-*;*>*N%,*'*)*  !*G&  ]+~*{*]*^*1#K%5./*          (*_*:*        ",
+"        <*[*}*M%              |*1*.+|%2*3*4*5*6*7*8*{&9*0*a*b*c*}#B$d*e*        V&f*g*-&        ",
+"          h*p+i*              j*B$k*4*l*m*n*o*p*q*r*s*B.O&t*u*v*w*x*y*          z*A*B*          ",
+"            C*l+D*E*          F*G*H*I*J*F$K*p+L*M*N*O*:@P*Q*R*D*S*            {+T*U*            ",
+"              <#V*W*X*          D+Y*Z*=@`* =.=+=@=#=$=%=^%A@&=                J&*=              ",
+"                w@==-=            ;=>=,='=)=S#!=r.~={=t.]=^=;&                /=                ",
+"                                    (=_=!+:=<=*@)=[=}=u.|=1=        2=                          ",
+"                                    6 3=4=m&5=6=W.7=l.O.8=    9=0=a=b=                          ",
+"                              c=d=e=f=g=  h=i=j=k=l=m=n=o=a%L%p=q=k$r=                          ",
+"                              s=t=u=v=w=x=y=z=_+A=B=C=D=E=/$F=G=H=I=                            ",
+"                                  =*J=]%K=L=M=N=O=P=`#*$Q=L%R=                                  "};
diff -r 11104731f8c9 -r 87f98d895296 misc/tremulous.ico
Binary file misc/tremulous.ico has changed
diff -r 11104731f8c9 -r 87f98d895296 misc/tremulous.xpm
--- a/misc/tremulous.xpm	Thu Feb 19 05:06:14 2009 +0800
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,90 +0,0 @@
-/* XPM */
-static char * tremulous_xpm[] = {
-"48 48 39 1",
-" 	c None",
-".	c #0F0F0F",
-"+	c #181818",
-"@	c #000000",
-"#	c #282828",
-"$	c #212121",
-"%	c #060606",
-"&	c #1D1D1D",
-"*	c #252525",
-"=	c #080808",
-"-	c #0E0E0E",
-";	c #050505",
-">	c #0B0B0B",
-",	c #0C0C0C",
-"'	c #232323",
-")	c #1F1F1F",
-"!	c #030303",
-"~	c #0D0D0D",
-"{	c #040404",
-"]	c #020202",
-"^	c #141414",
-"/	c #1E1E1E",
-"(	c #131313",
-"_	c #111111",
-":	c #010101",
-"<	c #191919",
-"[	c #090909",
-"}	c #292929",
-"|	c #070707",
-"1	c #121212",
-"2	c #1B1B1B",
-"3	c #161616",
-"4	c #0A0A0A",
-"5	c #222222",
-"6	c #242424",
-"7	c #1A1A1A",
-"8	c #151515",
-"9	c #101010",
-"0	c #171717",
-"                                                ",
-"                         ...                    ",
-"                       +@@@@@#                  ",
-"                      $@@@@@@%                  ",
-"                     &@@@@@@@@               *  ",
-"  =-                 ;@@@@@@@@>             ,@- ",
-"  @@'                ;@@@@@@@@@            ,@@  ",
-"  )@!                ;@@@@@@@@@           ~@@;  ",
-"   ;@{               ]@@@@@@@@@~         ,@@;   ",
-"   ^@@]             /@@@@@@@@@@@(       -@@;    ",
-"    .@@;            /@@@@@@@@@@@       -@@@/    ",
-"     _@@]           /@@@@@@@@@@@     #:@@@_     ",
-"      @@@;          /@@@@@@@@@@<     :@@@-      ",
-"       :@@!          ]@@@@@@@@@     @@@@-       ",
-"       $@@@;         ;@@@@@@@@[   ~]@@@-        ",
-"        %@@@;       }!@@@@@@@@- }|@@@@,         ",
-"         !@@@;     1@@@@@@@@@@ 2@@@@@~          ",
-"          ;@@@%    [@@@@@@@@@@@@@@@@,           ",
-"           @@@@{|||:@@@@@@@@@@@@@@!-            ",
-"           -@@@@@@@@@@@@@@@@@@@@@]              ",
-"            .@@@@@@@@@@@@@@@@@@@{               ",
-"              ]@@@@@@@@@@@@@@@@@                ",
-"               .@@@@@@@@@@@@@@@@                ",
-"                +@@@@@@@@@@@@@@@@@@@@@@@@@@/    ",
-"                 =@@@@@@@@@@@@@@@@@@@@@@@@@/    ",
-"               .=@@@@@@@@@@@@@@@@@@%            ",
-"             ,@@@@@@@@@@@@@@@@@@@@@             ",
-"        2>]@@@@@@@@@@@@@@@@@@@@@@@3             ",
-"      *:@@@@@@@@@@@@@@@@@@@@@@@@@^              ",
-"      @@@|||  4]@@@@@@@@@@@@@@@@@               ",
-"      556       _@@@@@@@@@@@@@@@@3              ",
-"                 >@@@@@@@@@@@@@@@@+             ",
-"                 ;@@@@@@@@@@@@@@@@@7            ",
-"                &@@@@@@@@@@@@@@@@@@@+           ",
-"                @@@@@@@@@@@@@@@@@@@@@/          ",
-"               8@@@@@@@@@@@@@@@[  =@@|          ",
-"               ;@@:::@@@@@@@@@[    %@@[         ",
-"               @@9   (@@@@@@@4      =@@         ",
-"              ,@@      {:@@:         {@!        ",
-"              !@@        <<          3@@0       ",
-"              !@-                     3@@6      ",
-"              ]@(                      (@[      ",
-"             7@@                        ]@      ",
-"             7@@                         *      ",
-"             7@}                                ",
-"             7@                                 ",
-"              .                                 ",
-"                                                "};
diff -r 11104731f8c9 -r 87f98d895296 src/asm/ftola.s
--- a/src/asm/ftola.s	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/asm/ftola.s	Sun Mar 29 01:15:08 2009 +0800
@@ -15,7 +15,7 @@
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
-along with Foobar; if not, write to the Free Software
+along with Tremfusion; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 ===========================================================================
 */
diff -r 11104731f8c9 -r 87f98d895296 src/asm/matha.s
--- a/src/asm/matha.s	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/asm/matha.s	Sun Mar 29 01:15:08 2009 +0800
@@ -15,7 +15,7 @@
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
-along with Foobar; if not, write to the Free Software
+along with Tremfusion; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 ===========================================================================
 */
diff -r 11104731f8c9 -r 87f98d895296 src/asm/snapvectora.s
--- a/src/asm/snapvectora.s	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/asm/snapvectora.s	Sun Mar 29 01:15:08 2009 +0800
@@ -15,7 +15,7 @@
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
-along with Foobar; if not, write to the Free Software
+along with Tremfusion; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 ===========================================================================
 */
diff -r 11104731f8c9 -r 87f98d895296 src/asm/snd_mixa.s
--- a/src/asm/snd_mixa.s	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/asm/snd_mixa.s	Sun Mar 29 01:15:08 2009 +0800
@@ -15,7 +15,7 @@
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
-along with Foobar; if not, write to the Free Software
+along with Tremfusion; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 ===========================================================================
 */
diff -r 11104731f8c9 -r 87f98d895296 src/cgame/cg_consolecmds.c
--- a/src/cgame/cg_consolecmds.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/cgame/cg_consolecmds.c	Sun Mar 29 01:15:08 2009 +0800
@@ -173,6 +173,35 @@
   trap_SendClientCommand( command );
 }
 
+void CG_ClientList_f( void )
+{
+  clientInfo_t *ci;
+  int i;
+  int count = 0;
+
+  for( i = 0; i < MAX_CLIENTS; i++ ) 
+  {
+    ci = &cgs.clientinfo[ i ];
+    if( !ci->infoValid ) 
+      continue;
+
+    switch( ci->team ) 
+    {
+      case TEAM_ALIENS:
+        Com_Printf( "%2i ^1A   ^7%s^7\n", i, ci->name );
+        break;
+      case TEAM_HUMANS:
+        Com_Printf( "%2i ^4H   ^7%s^7\n", i, ci->name );
+        break;
+      default:
+        Com_Printf( "%2i ^3S   ^7%s^7\n", i, ci->name );
+        break;
+    }
+    count++;
+  }
+  Com_Printf( "Listed %2i clients\n", count );
+}
+
 static void CG_SquadMark_f( void )
 {
   centity_t *cent;
@@ -220,6 +249,7 @@
   { "destroyTestPS", CG_DestroyTestPS_f },
   { "testTS", CG_TestTS_f },
   { "destroyTestTS", CG_DestroyTestTS_f },
+  { "clientlist", CG_ClientList_f },
   { "reloadhud", CG_LoadHudMenu },
   { "squadmark", CG_SquadMark_f },
 };
diff -r 11104731f8c9 -r 87f98d895296 src/cgame/cg_draw.c
--- a/src/cgame/cg_draw.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/cgame/cg_draw.c	Sun Mar 29 01:15:08 2009 +0800
@@ -1666,6 +1666,29 @@
   }
 }
 
+#define FOLLOWING_STRING "Following: "
+#define CHASING_STRING "Chasing: "
+/*
+==================
+CG_DrawFollow
+==================
+*/
+static void CG_DrawFollow( rectDef_t *rect, float text_x, float text_y,
+    vec4_t color, float scale, int textalign, int textvalign, int textStyle )
+{
+  float tx, ty;
+  char  *text;
+
+  if( cg.clientNum == cg.snap->ps.clientNum )
+    return; // not following anyone
+
+  text = va( "%s%s", ( cg.chaseFollow ) ? CHASING_STRING : FOLLOWING_STRING,
+             cgs.clientinfo[ cg.snap->ps.clientNum ].name );
+  CG_AlignText( rect, text, scale, 0, 0, textalign, textvalign, &tx, &ty );
+  UI_Text_Paint( text_x + tx, text_y + ty, scale, color, text, 0, 0,
+                 textStyle );
+}
+
 /*
 ==================
 CG_DrawTeamLabel
@@ -2264,7 +2287,7 @@
   int     color;
   vec4_t  adjustedColor;
   float   vscale;
-  vec4_t  white = { 1.0f, 1.0f, 1.0f, 1.0f };
+  char    *ping;
 
   if( cg.snap->ps.pm_type == PM_INTERMISSION )
     return;
@@ -2387,19 +2410,18 @@
   trap_R_SetColor( NULL );
 
   if( cg_nopredict.integer || cg_synchronousClients.integer )
-    UI_Text_Paint( ax, ay, 0.5, white, "snc", 0, 0, ITEM_TEXTSTYLE_NORMAL );
+    ping = "snc";
   else
-  {
-    char        *s;
+    ping = va( "%d", cg.ping );
+  ax = rect->x + ( rect->w / 2.0f ) -
+       ( UI_Text_Width( ping, scale, 0 ) / 2.0f ) + text_x;
+  ay = rect->y + ( rect->h / 2.0f ) +
+       ( UI_Text_Height( ping, scale, 0 ) / 2.0f ) + text_y;
 
-    s = va( "%d", cg.ping );
-    ax = rect->x + ( rect->w / 2.0f ) - ( UI_Text_Width( s, scale, 0 ) / 2.0f ) + text_x;
-    ay = rect->y + ( rect->h / 2.0f ) + ( UI_Text_Height( s, scale, 0 ) / 2.0f ) + text_y;
-
-    Vector4Copy( textColor, adjustedColor );
-    adjustedColor[ 3 ] = 0.5f;
-    UI_Text_Paint( ax, ay, scale, adjustedColor, s, 0, 0, ITEM_TEXTSTYLE_NORMAL );
-  }
+  Vector4Copy( textColor, adjustedColor );
+  adjustedColor[ 3 ] = 0.5f;
+  UI_Text_Paint( ax, ay, scale, adjustedColor, ping, 0, 0,
+                 ITEM_TEXTSTYLE_NORMAL );
 
   CG_DrawDisconnect( );
 }
@@ -2625,6 +2647,27 @@
   trap_R_SetColor( NULL );
 }
 
+
+/*
+=====================
+CG_DrawPlayerScore
+=====================
+*/
+static void CG_DrawPlayerScore( rectDef_t *rect, float scale, int textalign, vec4_t color )
+{
+  const char    *text;
+  float         maxX;
+  float         tx = rect->x, ty = rect->y;
+  maxX = rect->x + rect->w;
+  text = va( "%d", cg.snap->ps.persistant[ PERS_SCORE ] );
+
+  if( UI_Text_Width( text, scale, 0 ) < rect->w ) 
+    CG_AlignText( rect, text, scale, 0.0f, 0.0f, textalign, VALIGN_CENTER, &tx, &ty );
+
+  UI_Text_Paint_Limit( &maxX, tx, ty, scale, color, text, 0, 0);
+  trap_R_SetColor( NULL );
+}
+
 /*
 =====================
 CG_DrawCrosshairNames
@@ -2779,9 +2822,6 @@
 {
   rectDef_t rect;
 
-  if( cg_drawStatus.integer == 0 )
-    return;
-
   rect.x = x;
   rect.y = y;
   rect.w = w;
@@ -2881,12 +2921,19 @@
     case CG_PLAYER_LOCATION:
       CG_DrawLocation( &rect, scale, textalign, foreColor );
       break;
+    case CG_FOLLOW:
+      CG_DrawFollow( &rect, text_x, text_y, foreColor, scale,
+                     textalign, textvalign, textStyle );
+      break;
     case CG_PLAYER_CROSSHAIRNAMES:
       CG_DrawCrosshairNames( &rect, scale, textStyle );
       break;
     case CG_PLAYER_CROSSHAIR:
       CG_DrawCrosshair( &rect, foreColor );
       break;
+    case CG_PLAYER_SCORE:
+      CG_DrawPlayerScore( &rect, scale, textalign, foreColor );
+      break;
     case CG_STAGE_REPORT_TEXT:
       CG_DrawStageReport( &rect, text_x, text_y, foreColor, scale, textalign, textvalign, textStyle );
       break;
@@ -3374,46 +3421,12 @@
 */
 static void CG_DrawIntermission( void )
 {
-  if( cg_drawStatus.integer )
-    Menu_Paint( Menus_FindByName( "default_hud" ), qtrue );
+  Menu_Paint( Menus_FindByName( "default_hud" ), qtrue );
 
   cg.scoreFadeTime = cg.time;
   cg.scoreBoardShowing = CG_DrawScoreboard( );
 }
 
-#define FOLLOWING_STRING "Following: "
-#define CHASING_STRING "Chasing: "
-
-/*
-=================
-CG_DrawFollow
-=================
-*/
-static qboolean CG_DrawFollow( void )
-{
-  float       w;
-  vec4_t      color;
-  char        buffer[ MAX_STRING_CHARS ];
-
-  if( cg.snap->ps.clientNum == cg.clientNum )
-    return qfalse;
-
-  color[ 0 ] = 1;
-  color[ 1 ] = 1;
-  color[ 2 ] = 1;
-  color[ 3 ] = 1;
-
-  if( !cg.chaseFollow ) 
-    strcpy( buffer, FOLLOWING_STRING );
-  else 
-    strcpy( buffer, CHASING_STRING );
-  strcat( buffer, cgs.clientinfo[ cg.snap->ps.clientNum ].name );
-
-  w = UI_Text_Width( buffer, 0.7f, 0 );
-  UI_Text_Paint( 320 - w / 2, 400, 0.7f, color, buffer, 0, 0, ITEM_TEXTSTYLE_SHADOWED );
-
-  return qtrue;
-}
 
 /*
 =================
@@ -3468,7 +3481,6 @@
 
 //==================================================================================
 
-#define SPECTATOR_STRING "SPECTATOR"
 /*
 =================
 CG_Draw2D
@@ -3476,11 +3488,7 @@
 */
 static void CG_Draw2D( void )
 {
-  vec4_t    color;
-  float     w;
-  menuDef_t *menu = NULL, *defaultMenu;
-
-  color[ 0 ] = color[ 1 ] = color[ 2 ] = color[ 3 ] = 1.0f;
+  menuDef_t *menu = NULL;
 
   // if we are taking a levelshot for the menu, don't draw anything
   if( cg.levelShot )
@@ -3497,32 +3505,24 @@
 
   CG_DrawLighting( );
 
+  if( cg.snap->ps.persistant[ PERS_SPECSTATE ] == SPECTATOR_NOT )
+    menu = Menus_FindByName( BG_ClassConfig( cg.predictedPlayerState.stats
+                                                 [ STAT_CLASS ] )->hudName );
+  if( !menu )
+    menu = Menus_FindByName( "default_hud" );
+  if( !menu ) // still couldn't find it
+    CG_Error( "Default HUD could not be found" );
 
-  defaultMenu = Menus_FindByName( "default_hud" );
-
-  if( cg.snap->ps.persistant[ PERS_SPECSTATE ] != SPECTATOR_NOT )
-  {
-    w = UI_Text_Width( SPECTATOR_STRING, 0.7f, 0 );
-    UI_Text_Paint( 320 - w / 2, 440, 0.7f, color, SPECTATOR_STRING, 0, 0, ITEM_TEXTSTYLE_SHADOWED );
-  }
-  else
-    menu = Menus_FindByName( BG_ClassConfig( cg.predictedPlayerState.stats[ STAT_CLASS ] )->hudName );
-
-  if( menu && !( cg.snap->ps.stats[ STAT_STATE ] & SS_HOVELING ) &&
+  if( !( cg.snap->ps.stats[ STAT_STATE ] & SS_HOVELING ) &&
       ( cg.snap->ps.stats[ STAT_HEALTH ] > 0 ) )
   {
     CG_DrawBuildableStatus( );
-    CG_DrawTeamStatus( );
-    if( cg_drawStatus.integer )
-      Menu_Paint( menu, qtrue );
+  }
 
-  }
-  else if( cg_drawStatus.integer )
-    Menu_Paint( defaultMenu, qtrue );
+  Menu_Paint( menu, qtrue );
 
   CG_DrawVote( );
   CG_DrawTeamVote( );
-  CG_DrawFollow( );
   CG_DrawQueue( );
 
   // don't draw center string if scoreboard is up
diff -r 11104731f8c9 -r 87f98d895296 src/cgame/cg_ents.c
--- a/src/cgame/cg_ents.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/cgame/cg_ents.c	Sun Mar 29 01:15:08 2009 +0800
@@ -270,7 +270,7 @@
   }
 
 
-  if( cent->currentState.eType == ET_PLAYER )
+  /*if( cent->currentState.eType == ET_PLAYER )
   {
     centity_t *pcent = cent;
 
@@ -291,10 +291,10 @@
            Distance( front, back ) > LEVEL2_AREAZAP_CUTOFF )
         {
           CG_DestroyTrailSystem( &pcent->level2ZapTS[ i ] );
-}
+        }
       }
     }
-  }    
+  } */
 }
 
 
@@ -811,6 +811,64 @@
 
 /*
 =========================
+CG_Lev2ZapChain
+=========================
+*/
+static void CG_Lev2ZapChain( centity_t *cent )
+{
+  int           i;
+  entityState_t *es;
+  centity_t     *source = NULL, *target = NULL;
+
+  es = &cent->currentState;
+
+
+  //FIXME: find a better way to send zap targets
+  for( i = 0; i <= 2; i++ )
+  {
+    switch( i )
+    {
+      case 0:
+        if( es->time <= 0 )
+          continue;
+
+        source = &cg_entities[ es->misc ];
+        target = &cg_entities[ es->time ];
+        break;
+
+      case 1:
+        if( es->time2 <= 0 )
+          continue;
+
+        source = &cg_entities[ es->time ];
+        target = &cg_entities[ es->time2 ];
+        break;
+
+      case 2:
+        if( es->constantLight <= 0 )
+          continue;
+
+        source = &cg_entities[ es->time ];
+        target = &cg_entities[ es->constantLight ];
+        break;
+
+    }
+
+    if( !CG_IsTrailSystemValid( &cent->level2ZapTS[ i ] ) )
+      cent->level2ZapTS[ i ] = CG_SpawnNewTrailSystem( cgs.media.level2ZapTS );
+
+    if( CG_IsTrailSystemValid( &cent->level2ZapTS[ i ] ) )
+    {
+      CG_SetAttachmentCent( &cent->level2ZapTS[ i ]->frontAttachment, source );
+      CG_SetAttachmentCent( &cent->level2ZapTS[ i ]->backAttachment, target );
+      CG_AttachToCent( &cent->level2ZapTS[ i ]->frontAttachment );
+      CG_AttachToCent( &cent->level2ZapTS[ i ]->backAttachment );
+    }
+  }
+}
+
+/*
+=========================
 CG_AdjustPositionForMover
 
 Also called by client movement prediction code
@@ -1005,8 +1063,21 @@
 */
 static void CG_CEntityPVSLeave( centity_t *cent )
 {
+  int           i;
+  entityState_t *es = &cent->currentState;
+
   if( cg_debugPVS.integer )
     CG_Printf( "Entity %d left PVS\n", cent->currentState.number );
+  switch( es->eType )
+  {
+    case ET_LEV2_ZAP_CHAIN:
+      for( i = 0; i <= 2; i++ )
+      {
+        if( CG_IsTrailSystemValid( &cent->level2ZapTS[ i ] ) )
+          CG_DestroyTrailSystem( &cent->level2ZapTS[ i ] );
+      }
+      break;
+  }
 }
 
 
@@ -1090,6 +1161,9 @@
     case ET_LIGHTFLARE:
       CG_LightFlare( cent );
       break;
+    case ET_LEV2_ZAP_CHAIN:
+      CG_Lev2ZapChain( cent );
+      break;
     case ET_LOCATION:
       CG_LinkLocation( cent );
       break;
diff -r 11104731f8c9 -r 87f98d895296 src/cgame/cg_local.h
--- a/src/cgame/cg_local.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/cgame/cg_local.h	Sun Mar 29 01:15:08 2009 +0800
@@ -1473,7 +1473,6 @@
 extern  vmCvar_t    cg_crosshairSize;
 extern  vmCvar_t    cg_drawAmmoStack;
 extern  vmCvar_t    cg_draw2D;
-extern  vmCvar_t    cg_drawStatus;
 extern  vmCvar_t    cg_animSpeed;
 extern  vmCvar_t    cg_debugAnim;
 extern  vmCvar_t    cg_debugPosition;
@@ -2084,10 +2083,6 @@
 // used for the weapon select and zoom
 void          trap_SetUserCmdValue( int stateValue, float sensitivityScale );
 
-// aids for VM testing
-void          testPrintInt( char *string, int i );
-void          testPrintFloat( char *string, float f );
-
 int           trap_MemoryRemaining( void );
 void          trap_R_RegisterFont(const char *fontName, int pointSize, fontInfo_t *font);
 qboolean      trap_Key_IsDown( int keynum );
diff -r 11104731f8c9 -r 87f98d895296 src/cgame/cg_main.c
--- a/src/cgame/cg_main.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/cgame/cg_main.c	Sun Mar 29 01:15:08 2009 +0800
@@ -121,7 +121,6 @@
 vmCvar_t  cg_crosshairSize;
 vmCvar_t  cg_drawAmmoStack;
 vmCvar_t  cg_draw2D;
-vmCvar_t  cg_drawStatus;
 vmCvar_t  cg_animSpeed;
 vmCvar_t  cg_debugAnim;
 vmCvar_t  cg_debugPosition;
@@ -245,7 +244,6 @@
   { &cg_stereoSeparation, "cg_stereoSeparation", "0.4", CVAR_ARCHIVE  },
   { &cg_shadows, "cg_shadows", "1", CVAR_ARCHIVE  },
   { &cg_draw2D, "cg_draw2D", "1", CVAR_ARCHIVE  },
-  { &cg_drawStatus, "cg_drawStatus", "1", CVAR_ARCHIVE  },
   { &cg_drawTimer, "cg_drawTimer", "1", CVAR_ARCHIVE  },
   { &cg_drawClock, "cg_drawClock", "1", CVAR_ARCHIVE  },
   { &cg_drawFPS, "cg_drawFPS", "1", CVAR_ARCHIVE  },
@@ -331,13 +329,14 @@
 
   { &cg_debugVoices, "cg_debugVoices", "0", 0 },
   
-  { &ui_currentClass, "ui_currentClass", "0", 0 },
-  { &ui_carriage, "ui_carriage", "", 0 },
-  { &ui_stage, "ui_stage", "0", 0 },
-  { &ui_dialog, "ui_dialog", "Text not set", 0 },
-  { &ui_voteActive, "ui_voteActive", "0", 0 },
-  { &ui_humanTeamVoteActive, "ui_humanTeamVoteActive", "0", 0 },
-  { &ui_alienTeamVoteActive, "ui_alienTeamVoteActive", "0", 0 },
+  // communication cvars set by the cgame to be read by ui
+  { &ui_currentClass, "ui_currentClass", "0", CVAR_ROM },
+  { &ui_carriage, "ui_carriage", "", CVAR_ROM },
+  { &ui_stage, "ui_stage", "0", CVAR_ROM },
+  { &ui_dialog, "ui_dialog", "Text not set", CVAR_ROM },
+  { &ui_voteActive, "ui_voteActive", "0", CVAR_ROM },
+  { &ui_humanTeamVoteActive, "ui_humanTeamVoteActive", "0", CVAR_ROM },
+  { &ui_alienTeamVoteActive, "ui_alienTeamVoteActive", "0", CVAR_ROM },
 
   { &cg_debugRandom, "cg_debugRandom", "0", 0 },
   
@@ -1930,6 +1929,15 @@
   // get the gamestate from the client system
   trap_GetGameState( &cgs.gameState );
 
+  // copy vote display strings so they don't show up blank if we see 
+  // the same one directly after connecting
+  Q_strncpyz( cgs.voteString, CG_ConfigString( CS_VOTE_STRING ), 
+      sizeof( cgs.voteString ) );
+  Q_strncpyz( cgs.teamVoteString[ 0 ], CG_ConfigString( CS_TEAMVOTE_STRING + 0 ), 
+      sizeof( cgs.teamVoteString[ 0 ] ) );
+  Q_strncpyz( cgs.teamVoteString[ 1 ], CG_ConfigString( CS_TEAMVOTE_STRING + 1 ),
+      sizeof( cgs.teamVoteString[ 1 ] ) );
+
   // check version
   s = CG_ConfigString( CS_GAME_VERSION );
 
diff -r 11104731f8c9 -r 87f98d895296 src/cgame/cg_public.h
--- a/src/cgame/cg_public.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/cgame/cg_public.h	Sun Mar 29 01:15:08 2009 +0800
@@ -190,11 +190,7 @@
   CG_ATAN2,
   CG_SQRT,
   CG_FLOOR,
-  CG_CEIL,
-
-  CG_TESTPRINTINT,
-  CG_TESTPRINTFLOAT,
-  CG_ACOS
+  CG_CEIL
 } cgameImport_t;
 
 
diff -r 11104731f8c9 -r 87f98d895296 src/cgame/cg_servercmds.c
--- a/src/cgame/cg_servercmds.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/cgame/cg_servercmds.c	Sun Mar 29 01:15:08 2009 +0800
@@ -588,14 +588,14 @@
     
     case MN_B_NOROOM:
       longMsg   = "There is no room to build here. Move until the structure turns "
-                  "translucent green indicating a valid build location.";
+                  "translucent green, indicating a valid build location.";
       shortMsg  = "There is no room to build here";
       type      = DT_BUILD;
       break;
 
     case MN_B_NORMAL:
       longMsg   = "Cannot build on this surface. The surface is too steep or "
-                  "unsuitable to build on. Please choose another site for this "
+                  "unsuitable for building. Please choose another site for this "
 	                "structure.";
       shortMsg  = "Cannot build on this surface";
       type      = DT_BUILD;
@@ -763,7 +763,7 @@
 
     case MN_A_NOOVMND:
       longMsg   = "There is no Overmind. An Overmind must be built to control "
-                  "the structure you tried to place";
+                  "the structure you tried to place.";
       shortMsg  = "There is no Overmind";
       type      = DT_BUILD;
       break;
@@ -798,9 +798,8 @@
 
     case MN_A_TOOCLOSE:
       longMsg   = "This location is too close to the enemy to evolve. Move away "
-                  "until you are no longer aware of the enemy's presence and try "
-	                "again.";
-      shortMsg  = "This location is too close to the enemy to evolve";
+                  "from the enemy's presence and try again.";
+      shortMsg  = "This location is too close to the enemy to evolve\n";
       type      = DT_ARMOURYEVOLVE;
       break;
 
diff -r 11104731f8c9 -r 87f98d895296 src/cgame/cg_syscalls.asm
--- a/src/cgame/cg_syscalls.asm	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/cgame/cg_syscalls.asm	Sun Mar 29 01:15:08 2009 +0800
@@ -112,6 +112,4 @@
 equ sqrt                              -207
 equ floor                             -208
 equ ceil                              -209
-equ testPrintInt                      -210
-equ testPrintFloat                    -211
 
diff -r 11104731f8c9 -r 87f98d895296 src/cgame/cg_syscalls.c
--- a/src/cgame/cg_syscalls.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/cgame/cg_syscalls.c	Sun Mar 29 01:15:08 2009 +0800
@@ -442,16 +442,6 @@
   syscall( CG_SETUSERCMDVALUE, stateValue, PASSFLOAT( sensitivityScale ) );
 }
 
-void    testPrintInt( char *string, int i )
-{
-  syscall( CG_TESTPRINTINT, string, i );
-}
-
-void    testPrintFloat( char *string, float f )
-{
-  syscall( CG_TESTPRINTFLOAT, string, PASSFLOAT(f) );
-}
-
 int trap_MemoryRemaining( void )
 {
   return syscall( CG_MEMORY_REMAINING );
diff -r 11104731f8c9 -r 87f98d895296 src/cgame/cg_tutorial.c
--- a/src/cgame/cg_tutorial.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/cgame/cg_tutorial.c	Sun Mar 29 01:15:08 2009 +0800
@@ -270,7 +270,7 @@
 static void CG_AlienLevel0Text( char *text, playerState_t *ps )
 {
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      "Touch a human to damage it\n" );
+      "Touch humans to damage them\n" );
 
   Q_strcat( text, MAX_TUTORIAL_TEXT,
       va( "Press %s to walk on walls\n",
@@ -285,7 +285,7 @@
 static void CG_AlienLevel1Text( char *text, playerState_t *ps )
 {
   Q_strcat( text, MAX_TUTORIAL_TEXT,
-      "Touch a human to grab it\n" );
+      "Touch humans to grab them\n" );
 
   Q_strcat( text, MAX_TUTORIAL_TEXT,
       va( "Press %s to swipe\n",
diff -r 11104731f8c9 -r 87f98d895296 src/client/cl_cgame.c
--- a/src/client/cl_cgame.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/client/cl_cgame.c	Sun Mar 29 01:15:08 2009 +0800
@@ -496,17 +496,15 @@
 		if ( com_sse->integer >= 1 ) {
 			return CM_TempBoxModel_sse( vec3Load(VMA(1)), vec3Load(VMA(2)), /*int capsule*/ qfalse );
 		}
-#else
+#endif
 		return CM_TempBoxModel( VMA(1), VMA(2), /*int capsule*/ qfalse );
-#endif
 	case CG_CM_TEMPCAPSULEMODEL:
 #if id386_sse >= 1
 		if ( com_sse->integer >= 1 ) {
 			return CM_TempBoxModel_sse( vec3Load(VMA(1)), vec3Load(VMA(2)), /*int capsule*/ qtrue );
 		}
-#else
+#endif
 		return CM_TempBoxModel( VMA(1), VMA(2), /*int capsule*/ qtrue );
-#endif
 	case CG_CM_POINTCONTENTS:
 		return CM_PointContents( VMA(1), args[2] );
 	case CG_CM_TRANSFORMEDPOINTCONTENTS:
@@ -647,10 +645,9 @@
 
 	case CG_GETDEMOSTATE:
 		return CL_DemoState( );
+	// unused
 	case CG_GETDEMOPOS:
-		return CL_DemoPos( );
 	case CG_GETDEMONAME:
-		CL_DemoName( VMA(1), args[2] );
 		return 0;
 
 	case CG_KEY_KEYNUMTOSTRINGBUF:
@@ -701,8 +698,6 @@
 		return FloatAsInt( floor( VMF(1) ) );
 	case CG_CEIL:
 		return FloatAsInt( ceil( VMF(1) ) );
-	case CG_ACOS:
-		return FloatAsInt( Q_acos( VMF(1) ) );
 
 	case CG_S_STOPBACKGROUNDTRACK:
 		S_StopBackgroundTrack();
diff -r 11104731f8c9 -r 87f98d895296 src/client/cl_console.c
--- a/src/client/cl_console.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/client/cl_console.c	Sun Mar 29 01:15:08 2009 +0800
@@ -48,8 +48,6 @@
 	float	finalFrac;		// 0.0 to 1.0 lines of console to display
 
 	int		vislines;		// in scanlines
-
-	vec4_t	color;
 } console_t;
 
 extern	console_t	con;
@@ -112,11 +110,8 @@
 	prompt.active = qfalse;
 	Field_Clear( &chatField );
 	chatField.widthInChars = 30;
-	if( Cmd_Argc( ) > 1 )
-		chatField.cursor = Q_snprintf( chatField.buffer, sizeof( chatField.buffer ), "%s ", Cmd_Args( ) );
-	else
-		chatField.cursor = 0;
-
+	Q_strncpyz( chatField.buffer, Cmd_Args( ), sizeof( chatField.buffer ) );
+	chatField.cursor = strlen( chatField.buffer );
 	Key_SetCatcher( Key_GetCatcher( ) ^ KEYCATCH_MESSAGE );
 }
 
@@ -133,11 +128,8 @@
 	prompt.active = qfalse;
 	Field_Clear( &chatField );
 	chatField.widthInChars = 25;
-	if( Cmd_Argc( ) > 1 )
-		chatField.cursor = Q_snprintf( chatField.buffer, sizeof( chatField.buffer ), "%s ", Cmd_Args( ) );
-	else
-		chatField.cursor = 0;
-
+	Q_strncpyz( chatField.buffer, Cmd_Args( ), sizeof( chatField.buffer ) );
+	chatField.cursor = strlen( chatField.buffer );
 	Key_SetCatcher( Key_GetCatcher( ) ^ KEYCATCH_MESSAGE );
 }
 
@@ -158,11 +150,8 @@
 	prompt.active = qfalse;
 	Field_Clear( &chatField );
 	chatField.widthInChars = 30;
-	if( Cmd_Argc( ) > 1 )
-		chatField.cursor = Q_snprintf( chatField.buffer, sizeof( chatField.buffer ), "%s ", Cmd_Args( ) );
-	else
-		chatField.cursor = 0;
-
+	Q_strncpyz( chatField.buffer, Cmd_Args( ), sizeof( chatField.buffer ) );
+	chatField.cursor = strlen( chatField.buffer );
 	Key_SetCatcher( Key_GetCatcher( ) ^ KEYCATCH_MESSAGE );
 }
 
@@ -183,11 +172,8 @@
 	prompt.active = qfalse;
 	Field_Clear( &chatField );
 	chatField.widthInChars = 30;
-	if( Cmd_Argc( ) > 1 )
-		chatField.cursor = Q_snprintf( chatField.buffer, sizeof( chatField.buffer ), "%s ", Cmd_Args( ) );
-	else
-		chatField.cursor = 0;
-
+	Q_strncpyz( chatField.buffer, Cmd_Args( ), sizeof( chatField.buffer ) );
+	chatField.cursor = strlen( chatField.buffer );
 	Key_SetCatcher( Key_GetCatcher( ) ^ KEYCATCH_MESSAGE );
 }
 
@@ -204,11 +190,8 @@
 	prompt.active = qfalse;
 	Field_Clear( &chatField );
 	chatField.widthInChars = 25;
-	if( Cmd_Argc( ) > 1 )
-		chatField.cursor = Q_snprintf( chatField.buffer, sizeof( chatField.buffer ), "%s ", Cmd_Args( ) );
-	else
-		chatField.cursor = 0;
-
+	Q_strncpyz( chatField.buffer, Cmd_Args( ), sizeof( chatField.buffer ) );
+	chatField.cursor = strlen( chatField.buffer );
 	Key_SetCatcher( Key_GetCatcher( ) ^ KEYCATCH_MESSAGE );
 }
 
@@ -253,12 +236,8 @@
 	chat_clans = qtrue;
 	prompt.active = qfalse;
 	Field_Clear( &chatField );
-	chatField.widthInChars = 25;
-	if( Cmd_Argc( ) > 1 )
-		chatField.cursor = Q_snprintf( chatField.buffer, sizeof( chatField.buffer ), "%s ", Cmd_Args( ) );
-	else
-		chatField.cursor = 0;
-
+	Q_strncpyz( chatField.buffer, Cmd_Args( ), sizeof( chatField.buffer ) );
+	chatField.cursor = strlen( chatField.buffer );
 	Key_SetCatcher( Key_GetCatcher( ) ^ KEYCATCH_MESSAGE );
 }
 
@@ -343,75 +322,56 @@
 
 /*
 ================
-Con_Grep_f
+Con_Search_f
 
-Find all console lines containing a string
+Scroll up to the first console line containing a string
 ================
 */
-void Con_Grep_f (void)
+void Con_Search_f (void)
 {
-	int		l, x, i;
+	int		l, i, x;
 	short	*line;
-	char	buffer[1024];
-	char	buffer2[1024];
-	char	printbuf[CON_TEXTSIZE];
-	char	*search;
-	char	lastcolor;
+	char	buffer[MAXPRINTMSG];
+	int		direction;
+	int		c = Cmd_Argc();
 
-	if (Cmd_Argc() != 2)
-	{
-		Com_Printf ("usage: grep <string>\n");
+	if (c < 2) {
+		Com_Printf ("usage: %s <string1> <string2> <...>\n", Cmd_Argv(0));
 		return;
 	}
 
-	// skip empty lines
-	for (l = con.current - con.totallines + 1 ; l <= con.current ; l++)
-	{
-		line = con.text + (l%con.totallines)*con.linewidth;
-		for (x=0 ; x<con.linewidth ; x++)
-			if ((line[x] & 0xff) != ' ')
-				break;
-		if (x != con.linewidth)
-			break;
+	if (!Q_stricmp(Cmd_Argv(0), "searchDown")) {
+		direction = 1;
+	} else {
+		direction = -1;
 	}
 
-	// check the remaining lines
+	// check the lines
 	buffer[con.linewidth] = 0;
-	search = Cmd_Argv( 1 );
-	printbuf[0] = '\0';
-	lastcolor = 7;
-	for ( ; l <= con.current ; l++)
-	{
+	for (l = con.display - 1 + direction; l <= con.current && con.current - l < con.totallines; l += direction) {
 		line = con.text + (l%con.totallines)*con.linewidth;
-		for(i=0,x=0; i<con.linewidth; i++)
-		{
-			if (line[i] >> 8 != lastcolor)
-			{
-				lastcolor = line[i] >> 8;
-				buffer[x++] = Q_COLOR_ESCAPE;
-				buffer[x++] = lastcolor + '0';
-			}
-			buffer[x++] = line[i] & 0xff;
-		}
-		for (x=con.linewidth-1 ; x>=0 ; x--)
-		{
+		for (i = 0; i < con.linewidth; i++)
+			buffer[i] = line[i] & 0xff;
+		for (x = con.linewidth - 1 ; x >= 0 ; x--) {
 			if (buffer[x] == ' ')
 				buffer[x] = 0;
 			else
 				break;
 		}
-		strcpy(buffer2, buffer);
-		Q_CleanStr(buffer2);
-		if (Q_stristr(buffer2, search))
-		{
-			strcat( printbuf, buffer );
-			strcat( printbuf, "\n" );
+		// Don't search commands
+		if (!Q_stricmpn(buffer, Q_CleanStr(va("%s", cl_consolePrompt->string)), Q_PrintStrlen(cl_consolePrompt->string)))
+			continue;
+		for (i = 1; i < c; i++) {
+			if (Q_stristr(buffer, Cmd_Argv(i))) {
+				con.display = l + 1;
+				if (con.display > con.current)
+					con.display = con.current;
+				return;
+			}
 		}
 	}
-	if ( printbuf[0] )
-		Com_Printf( "%s", printbuf );
 }
-						
+
 /*
 ================
 Con_ClearNotify
@@ -547,7 +507,8 @@
 	Cmd_AddCommand ("clear", Con_Clear_f);
 	Cmd_AddCommand ("condump", Con_Dump_f);
 	Cmd_SetCommandCompletionFunc( "condump", Cmd_CompleteTxtName );
-	Cmd_AddCommand ("grep", Con_Grep_f);
+	Cmd_AddCommand ("search", Con_Search_f);
+	Cmd_AddCommand ("searchDown", Con_Search_f);
 }
 
 
@@ -582,6 +543,7 @@
 	int		c, l;
 	int		color;
 	qboolean skipnotify = qfalse;		// NERVE - SMF
+	static qboolean is_new_line = qtrue;
 	
 	CL_WriteClientChatLog( txt );
 	
@@ -618,20 +580,19 @@
 	}
 	
 	if (!con.initialized) {
-		con.color[0] = 
-		con.color[1] = 
-		con.color[2] =
-		con.color[3] = 1.0f;
 		con.linewidth = -1;
 		Con_CheckResize ();
 		con.initialized = qtrue;
 	}
 
-	if( !skipnotify && !( Key_GetCatcher( ) & KEYCATCH_CONSOLE ) ) {
+	if( !skipnotify ) {
 		Cmd_SaveCmdContext( );
 
 		// feed the text to cgame
-		Cmd_TokenizeString( txt );
+		if( is_new_line && ( com_timestamps && com_timestamps->integer ) )
+			Cmd_TokenizeString( txt + 16 );
+		else
+			Cmd_TokenizeString( txt );
 		CL_GameConsoleText( );
 
 		Cmd_RestoreCmdContext( );
@@ -681,6 +642,7 @@
 			break;
 		}
 	}
+	is_new_line = txt[strlen(txt) - 1] == '\n';
 }
 
 
@@ -703,20 +665,21 @@
 void Con_DrawInput (void) {
 	int		y;
 	char	prompt[ MAX_STRING_CHARS ];
+	qtime_t realtime;
 
 	if ( cls.state != CA_DISCONNECTED && !(Key_GetCatcher( ) & KEYCATCH_CONSOLE ) ) {
 		return;
 	}
 
+	Com_RealTime( &realtime );
+
 	y = con.vislines - ( SCR_ConsoleFontCharHeight() * 2 ) + 2 ;
 
-	re.SetColor( con.color );
+	Com_sprintf( prompt,  sizeof( prompt ), "^0[^3%02d%c%02d^0]^7 %s", realtime.tm_hour, (realtime.tm_sec & 1) ? ':' : ' ', realtime.tm_min, cl_consolePrompt->string );
 
-	Q_strncpyz( prompt, cl_consolePrompt->string, sizeof( prompt ) );
+	SCR_DrawSmallStringExt( con.xadjust + cl_conXOffset->integer, y, prompt, colorWhite, qfalse, qfalse );
+
 	Q_CleanStr( prompt );
-
-	SCR_DrawSmallStringExt( con.xadjust + cl_conXOffset->integer, y, cl_consolePrompt->string, colorWhite, qfalse, qfalse );
-
 	Field_Draw( &g_consoleField, con.xadjust + cl_conXOffset->integer + SCR_ConsoleFontStringWidth(prompt, strlen(prompt)), y, qtrue, qtrue );
 }
 
diff -r 11104731f8c9 -r 87f98d895296 src/client/cl_curl.c
--- a/src/client/cl_curl.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/client/cl_curl.c	Sun Mar 29 01:15:08 2009 +0800
@@ -268,7 +268,7 @@
 		qcurl_easy_setopt(clc.downloadCURL, CURLOPT_VERBOSE, 1);
 	qcurl_easy_setopt(clc.downloadCURL, CURLOPT_URL, clc.downloadURL);
 	qcurl_easy_setopt(clc.downloadCURL, CURLOPT_TRANSFERTEXT, 0);
-	Com_sprintf(referer, sizeof(referer), "ioQ3://%s", NET_AdrToString(clc.serverAddress));
+	Com_sprintf(referer, sizeof(referer), "Tremulous://%s", NET_AdrToString(clc.serverAddress));
 	qcurl_easy_setopt(clc.downloadCURL, CURLOPT_REFERER, referer);
 	Com_sprintf(useragent, sizeof(useragent), "%s %s", Q3_VERSION, qcurl_version());
 	qcurl_easy_setopt(clc.downloadCURL, CURLOPT_USERAGENT, useragent);
diff -r 11104731f8c9 -r 87f98d895296 src/client/cl_keys.c
--- a/src/client/cl_keys.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/client/cl_keys.c	Sun Mar 29 01:15:08 2009 +0800
@@ -397,8 +397,9 @@
 ================
 */
 void Field_Paste( field_t *edit ) {
+	void Console_Key (int key);
 	char	*cbd;
-	int		pasteLen, i;
+	int		pasteLen, i, lineCounter = 0;
 
 	cbd = Sys_GetClipboardData();
 
@@ -409,8 +410,15 @@
 	// send as if typed, so insert / overstrike works properly
 	pasteLen = strlen( cbd );
 	for ( i = 0 ; i < pasteLen ; i++ ) {
-		Field_CharEvent( edit, cbd[i] );
+		// dont press enter if theres nothing after
+		if ( cbd[i] == '\n' && (i+1) < pasteLen ) {
+			Console_Key( '\n' );
+			lineCounter++;
+		} else
+			Field_CharEvent( edit, cbd[i] );
 	}
+	if ( lineCounter )
+		Console_Key( '\n' );
 
 	Z_Free( cbd );
 }
@@ -526,6 +534,11 @@
 		return;
 	}
 
+	if ( ch == 'e' - 'a' + 1 ) {	// ctrl-w deletes the last word
+		Field_WordDelete( edit );
+		return;
+	}
+
 	//
 	// ignore any other non printable chars
 	//
@@ -603,9 +616,9 @@
 			if ( !g_consoleField.buffer[0] ) {
 				return;	// empty lines just scroll the console without adding to history
 			} else {
-				Cbuf_AddText ("cmd say ");
+				Cbuf_AddText ("say \""); // use say instead of cmd say to allow printing URLs
 				Cbuf_AddText( g_consoleField.buffer );
-				Cbuf_AddText ("\n");
+				Cbuf_AddText ("\"\n");
 			}
 		}
 
@@ -729,16 +742,7 @@
 				char clantagDecolored[ 32 ];
 				Q_strncpyz(clantagDecolored, cl_clantag->string, sizeof( clantagDecolored ) );
 				Q_CleanStr(clantagDecolored);
-
-				if( strlen(clantagDecolored) > 2 && strlen(clantagDecolored) < 11 ) {
-					Com_sprintf( buffer, sizeof( buffer ), "m \"%s\" \"%s\"\n", clantagDecolored, chatField.buffer );
-				} else {
-					//string isnt long enough
-					Com_Printf ( "^3Error: Your clantag has to be between 3 and 10 chars long. Current value is:^7 %s^7\n", clantagDecolored );
-					Key_SetCatcher( Key_GetCatcher( ) & ~KEYCATCH_MESSAGE );
-					Field_Clear( &chatField );
-					return;
-				}
+				Com_sprintf( buffer, sizeof( buffer ), "m \"%s\" \"%s\"\n", clantagDecolored, chatField.buffer );
 
 			} else if (prompt.active) {
 
@@ -748,7 +752,7 @@
 
 			} else {
 				Com_sprintf( buffer, sizeof( buffer ), "say \"%s\"\n", chatField.buffer );
-				Hist_Add( buffer );
+				Hist_Add( chatField.buffer );
 			}
 
 			if ( !prompt.active )
diff -r 11104731f8c9 -r 87f98d895296 src/client/cl_main.c
--- a/src/client/cl_main.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/client/cl_main.c	Sun Mar 29 01:15:08 2009 +0800
@@ -1171,36 +1171,6 @@
 	}
 }
 
-/*
-==================
-CL_DemoPos
-
-Returns the current position of the demo
-==================
-*/
-int CL_DemoPos( void ) {
-	if( clc.demoplaying || clc.demorecording ) {
-		return FS_FTell( clc.demofile );
-	} else {
-		return 0;
-	}
-}
-
-/*
-==================
-CL_DemoName
-
-Returns the name of the demo
-==================
-*/
-void CL_DemoName( char *buffer, int size ) {
-	if( clc.demoplaying || clc.demorecording ) {
-		Q_strncpyz( buffer, clc.demoName, size );
-	} else if( size >= 1 ) {
-		buffer[ 0 ] = '\0';
-	}
-}
-
 //======================================================================
 
 /*
@@ -1776,7 +1746,7 @@
 		}
 	}
 	
-	NET_SendPacket (NS_CLIENT, strlen(message)+1, message, to, 0);
+	NET_SendPacket (NS_CLIENT, strlen(message)+1, message, to);
 }
 
 /*
@@ -3453,7 +3423,7 @@
 	cl_alienConfig = Cvar_Get ("cl_alienConfig", "", CVAR_ARCHIVE);
 	cl_spectatorConfig = Cvar_Get ("cl_spectatorConfig", "", CVAR_ARCHIVE);
 
-	cl_defaultUI = Cvar_Get ("cl_defaultUI", "base", CVAR_ARCHIVE);
+	cl_defaultUI = Cvar_Get ("cl_defaultUI", "tremfusion", CVAR_ARCHIVE);
 	Cvar_Set ("fs_game", cl_defaultUI->string);
 	Com_StartupVariable( "fs_game" );
 	FS_ConditionalRestart (clc.checksumFeed);
@@ -4015,9 +3985,9 @@
 			to.port = BigShort( (short)(PORT_SERVER + j) );
 
 			to.type = NA_BROADCAST;
-			NET_SendPacket( NS_CLIENT, strlen( message ), message, to, 0 );
+			NET_SendPacket( NS_CLIENT, strlen( message ), message, to );
 			to.type = NA_MULTICAST6;
-			NET_SendPacket( NS_CLIENT, strlen( message ), message, to, 0 );
+			NET_SendPacket( NS_CLIENT, strlen( message ), message, to );
 		}
 	}
 }
diff -r 11104731f8c9 -r 87f98d895296 src/client/cl_net_chan.c
--- a/src/client/cl_net_chan.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/client/cl_net_chan.c	Sun Mar 29 01:15:08 2009 +0800
@@ -133,7 +133,7 @@
 =================
 */
 void CL_Netchan_TransmitNextFragment( netchan_t *chan ) {
-	Netchan_TransmitNextFragment( chan, 0 );
+	Netchan_TransmitNextFragment( chan );
 }
 
 /*
@@ -145,7 +145,7 @@
 	MSG_WriteByte( msg, clc_EOF );
 
 	CL_Netchan_Encode( msg );
-	Netchan_Transmit( chan, msg->cursize, msg->data, 0 );
+	Netchan_Transmit( chan, msg->cursize, msg->data );
 }
 
 extern 	int oldsize;
diff -r 11104731f8c9 -r 87f98d895296 src/client/client.h
--- a/src/client/client.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/client/client.h	Sun Mar 29 01:15:08 2009 +0800
@@ -473,8 +473,6 @@
 void CL_NextDemo( void );
 void CL_ReadDemoMessage( void );
 demoState_t CL_DemoState( void );
-int CL_DemoPos( void );
-void CL_DemoName( char *buffer, int size );
 void CL_StopRecord_f( void );
 
 void CL_InitDownloads(void);
diff -r 11104731f8c9 -r 87f98d895296 src/client/qal.c
--- a/src/client/qal.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/client/qal.c	Sun Mar 29 01:15:08 2009 +0800
@@ -159,7 +159,7 @@
 		if( (OpenALLib = Sys_LoadLibrary(fn)) == 0 )
 		{
 #ifdef ALDRIVER_FALLBACK
-			// On some linux distributions there is no libopenal.so.0, but only libopenal.so.1. That one works too.
+			// On some linux distributions there is no libopenal.so.1, but only libopenal.so.0. That one works too.
 			if( (OpenALLib = Sys_LoadLibrary(ALDRIVER_FALLBACK)) == 0 )
 			{
 				return qfalse;
diff -r 11104731f8c9 -r 87f98d895296 src/client/qal.h
--- a/src/client/qal.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/client/qal.h	Sun Mar 29 01:15:08 2009 +0800
@@ -54,8 +54,8 @@
 #elif defined(MACOS_X)
 #define ALDRIVER_DEFAULT "/System/Library/Frameworks/OpenAL.framework/OpenAL"
 #else
-#define ALDRIVER_DEFAULT "libopenal.so.0"
-#define ALDRIVER_FALLBACK "libopenal.so.1"
+#define ALDRIVER_DEFAULT "libopenal.so.1"
+#define ALDRIVER_FALLBACK "libopenal.so.0"
 #endif
 
 #ifdef USE_OPENAL_DLOPEN
diff -r 11104731f8c9 -r 87f98d895296 src/client/snd_dma.c
--- a/src/client/snd_dma.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/client/snd_dma.c	Sun Mar 29 01:15:08 2009 +0800
@@ -42,6 +42,7 @@
 void S_Base_StopAllSounds(void);
 void S_Base_StopBackgroundTrack( void );
 
+float			s_gain;
 snd_stream_t	*s_backgroundStream = NULL;
 static char		s_backgroundLoop[MAX_QPATH];
 //static char		s_backgroundMusic[MAX_QPATH]; //TTimo: unused
@@ -125,32 +126,41 @@
 static
 void S_Base_StartCapture( void )
 {
-	// !!! FIXME: write me.
+#ifdef USE_OPENAL
+	S_AL_StartCapture();
+#endif
 }
 
 static
 int S_Base_AvailableCaptureSamples( void )
 {
-	// !!! FIXME: write me.
+#ifdef USE_OPENAL
+	return S_AL_AvailableCaptureSamples();
+#else
 	return 0;
+#endif
 }
 
 static
 void S_Base_Capture( int samples, byte *data )
 {
-	// !!! FIXME: write me.
+#ifdef USE_OPENAL
+	S_AL_Capture( samples, data );
+#endif
 }
 
 static
 void S_Base_StopCapture( void )
 {
-	// !!! FIXME: write me.
+#ifdef USE_OPENAL
+	S_AL_StopCapture();
+#endif
 }
 
 static
 void S_Base_MasterGain( float val )
 {
-	// !!! FIXME: write me.
+	s_gain = val;
 }
 #endif
 
@@ -1506,6 +1516,7 @@
 	if ( r ) {
 		s_soundStarted = 1;
 		s_soundMuted = 1;
+		s_gain = 1.0f;
 //		s_numSfx = 0;
 
 		Com_Memset(sfxHash, 0, sizeof(sfx_t *)*LOOP_HASH);
@@ -1541,6 +1552,9 @@
 	si->SoundList = S_Base_SoundList;
 
 #ifdef USE_VOIP
+#ifdef USE_OPENAL
+	S_AL_InitCapture( qfalse );
+#endif
 	si->StartCapture = S_Base_StartCapture;
 	si->AvailableCaptureSamples = S_Base_AvailableCaptureSamples;
 	si->Capture = S_Base_Capture;
diff -r 11104731f8c9 -r 87f98d895296 src/client/snd_local.h
--- a/src/client/snd_local.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/client/snd_local.h	Sun Mar 29 01:15:08 2009 +0800
@@ -199,6 +199,8 @@
 
 extern cvar_t *s_testsound;
 
+extern float s_gain;
+
 qboolean S_LoadSound( sfx_t *sfx );
 
 void		SND_free(sndBuffer *v);
@@ -251,3 +253,10 @@
 typedef int srcHandle_t;
 
 qboolean S_AL_Init( soundInterface_t *si );
+
+// So that we can still use OpenAL for capture when using the base driver
+void S_AL_InitCapture( qboolean usingAL );
+void S_AL_StartCapture( void );
+int S_AL_AvailableCaptureSamples( void );
+void S_AL_Capture( int samples, byte *data );
+void S_AL_StopCapture( void );
diff -r 11104731f8c9 -r 87f98d895296 src/client/snd_main.c
--- a/src/client/snd_main.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/client/snd_main.c	Sun Mar 29 01:15:08 2009 +0800
@@ -17,7 +17,7 @@
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
-along with Foobar; if not, write to the Free Software
+along with Tremfusion; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 ===========================================================================
 */
diff -r 11104731f8c9 -r 87f98d895296 src/client/snd_mix.c
--- a/src/client/snd_mix.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/client/snd_mix.c	Sun Mar 29 01:15:08 2009 +0800
@@ -921,7 +921,7 @@
 	int		ltime, count;
 	int		sampleOffset;
 
-	snd_vol = s_volume->value*255;
+	snd_vol = s_volume->value*s_gain*255;
 
 //Com_Printf ("%i to %i\n", s_paintedtime, endtime);
 	while ( s_paintedtime < endtime ) {
diff -r 11104731f8c9 -r 87f98d895296 src/client/snd_openal.c
--- a/src/client/snd_openal.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/client/snd_openal.c	Sun Mar 29 01:15:08 2009 +0800
@@ -1439,6 +1439,8 @@
 static
 void S_AL_StreamDie( int stream )
 {
+	int		numBuffers;
+
 	if ((stream < 0) || (stream >= MAX_RAW_STREAMS))
 		return;
 
@@ -1447,6 +1449,16 @@
 
 	streamPlaying[stream] = qfalse;
 	qalSourceStop(streamSources[stream]);
+
+	// Un-queue any buffers, and delete them
+	qalGetSourcei( streamSources[stream], AL_BUFFERS_PROCESSED, &numBuffers );
+	while( numBuffers-- )
+	{
+		ALuint buffer;
+		qalSourceUnqueueBuffers(streamSources[stream], 1, &buffer);
+		qalDeleteBuffers(1, &buffer);
+	}
+
 	S_AL_FreeStreamChannel(stream);
 }
 
@@ -1873,14 +1885,77 @@
 }
 
 #ifdef USE_VOIP
-static
+void S_AL_InitCapture( qboolean usingAL )
+{
+	// Load QAL if we are called from the base sound driver
+	if( !usingAL )
+	{
+		s_alDriver = Cvar_Get( "s_alDriver", ALDRIVER_DEFAULT, CVAR_ARCHIVE );
+		if( !QAL_Init( s_alDriver->string ) )
+		{
+			Com_Printf( "Failed to load library: \"%s\".\n", s_alDriver->string );
+			return;
+		}
+	}
+
+	// !!! FIXME: some of these alcCaptureOpenDevice() values should be cvars.
+	// !!! FIXME: add support for capture device enumeration.
+	// !!! FIXME: add some better error reporting.
+	s_alCapture = Cvar_Get( "s_alCapture", "1", CVAR_ARCHIVE | CVAR_LATCH );
+	if (!s_alCapture->integer)
+	{
+		Com_Printf("OpenAL capture support disabled by user (set s_alCapture to 1 and execute /snd_restart to enable)\n");
+		if( !usingAL )
+			QAL_Shutdown();
+	}
+#if USE_MUMBLE
+	else if (cl_useMumble->integer)
+	{
+		Com_Printf("OpenAL capture support disabled for Mumble support\n");
+		if( !usingAL )
+			QAL_Shutdown();
+	}
+#endif
+	else
+	{
+#ifdef MACOS_X
+		// !!! FIXME: Apple has a 1.1-compliant OpenAL, which includes
+		// !!! FIXME:  capture support, but they don't list it in the
+		// !!! FIXME:  extension string. We need to check the version string,
+		// !!! FIXME:  then the extension string, but that's too much trouble,
+		// !!! FIXME:  so we'll just check the function pointer for now.
+		if (qalcCaptureOpenDevice == NULL)
+#else
+		if (!qalcIsExtensionPresent(NULL, "ALC_EXT_capture"))
+#endif
+		{
+			Com_Printf("No ALC_EXT_capture support, can't record audio.\n");
+			if( !usingAL )
+				QAL_Shutdown();
+		}
+		else
+		{
+			// !!! FIXME: 8000Hz is what Speex narrowband mode needs, but we
+			// !!! FIXME:  should probably open the capture device after
+			// !!! FIXME:  initializing Speex so we can change to wideband
+			// !!! FIXME:  if we like.
+			Com_Printf("OpenAL default capture device is '%s'\n",
+			           qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER));
+			alCaptureDevice = qalcCaptureOpenDevice(NULL, 8000, AL_FORMAT_MONO16, 1024);
+			Com_Printf( "OpenAL capture device %s.\n",
+			            (alCaptureDevice == NULL) ? "failed to open" : "opened");
+			if( !alCaptureDevice && !usingAL )
+				QAL_Shutdown();
+		}
+	}
+}
+
 void S_AL_StartCapture( void )
 {
 	if (alCaptureDevice != NULL)
 		qalcCaptureStart(alCaptureDevice);
 }
 
-static
 int S_AL_AvailableCaptureSamples( void )
 {
 	int retval = 0;
@@ -1893,7 +1968,6 @@
 	return retval;
 }
 
-static
 void S_AL_Capture( int samples, byte *data )
 {
 	if (alCaptureDevice != NULL)
@@ -2097,48 +2171,7 @@
 	qalDopplerVelocity( s_alDopplerSpeed->value );
 
 #ifdef USE_VOIP
-	// !!! FIXME: some of these alcCaptureOpenDevice() values should be cvars.
-	// !!! FIXME: add support for capture device enumeration.
-	// !!! FIXME: add some better error reporting.
-	s_alCapture = Cvar_Get( "s_alCapture", "1", CVAR_ARCHIVE | CVAR_LATCH );
-	if (!s_alCapture->integer)
-	{
-		Com_Printf("OpenAL capture support disabled by user ('+set s_alCapture 1' to enable)\n");
-	}
-#if USE_MUMBLE
-	else if (cl_useMumble->integer)
-	{
-		Com_Printf("OpenAL capture support disabled for Mumble support\n");
-	}
-#endif
-	else
-	{
-#ifdef MACOS_X
-		// !!! FIXME: Apple has a 1.1-compliant OpenAL, which includes
-		// !!! FIXME:  capture support, but they don't list it in the
-		// !!! FIXME:  extension string. We need to check the version string,
-		// !!! FIXME:  then the extension string, but that's too much trouble,
-		// !!! FIXME:  so we'll just check the function pointer for now.
-		if (qalcCaptureOpenDevice == NULL)
-#else
-		if (!qalcIsExtensionPresent(NULL, "ALC_EXT_capture"))
-#endif
-		{
-			Com_Printf("No ALC_EXT_capture support, can't record audio.\n");
-		}
-		else
-		{
-			// !!! FIXME: 8000Hz is what Speex narrowband mode needs, but we
-			// !!! FIXME:  should probably open the capture device after
-			// !!! FIXME:  initializing Speex so we can change to wideband
-			// !!! FIXME:  if we like.
-			Com_Printf("OpenAL default capture device is '%s'\n",
-			           qalcGetString(NULL, ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER));
-			alCaptureDevice = qalcCaptureOpenDevice(NULL, 8000, AL_FORMAT_MONO16, 4096);
-			Com_Printf( "OpenAL capture device %s.\n",
-			            (alCaptureDevice == NULL) ? "failed to open" : "opened");
-		}
-	}
+	S_AL_InitCapture( qtrue );
 #endif
 
 	si->Shutdown = S_AL_Shutdown;
diff -r 11104731f8c9 -r 87f98d895296 src/game/bg_pmove.c
--- a/src/game/bg_pmove.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/bg_pmove.c	Sun Mar 29 01:15:08 2009 +0800
@@ -3462,7 +3462,21 @@
   // circularly clamp the angles with deltas
   for( i = 0; i < 3; i++ )
   {
-    temp[ i ] = cmd->angles[ i ] + ps->delta_angles[ i ];
+    if( i == ROLL ) 
+    {
+      // Guard against speed hack
+      temp[ i ] = ps->delta_angles[ i ];
+
+#ifdef CGAME
+      // Assert here so that if cmd->angles[ i ] becomes non-zero
+      // for a legitimate reason we can tell where and why it's
+      // being ignored
+      assert( cmd->angles[ i ] == 0 );
+#endif
+
+    }
+    else
+      temp[ i ] = cmd->angles[ i ] + ps->delta_angles[ i ];
 
     if( i == PITCH )
     {
diff -r 11104731f8c9 -r 87f98d895296 src/game/bg_public.h
--- a/src/game/bg_public.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/bg_public.h	Sun Mar 29 01:15:08 2009 +0800
@@ -224,6 +224,7 @@
   STAT_BUILDABLE, // which ghost model to display for building
   STAT_FALLDIST,  // the distance the player fell
   STAT_VIEWLOCK   // direction to lock the view in
+  // netcode has space for 1 more
 } statIndex_t;
 
 #define SCA_WALLCLIMBER         0x00000001
@@ -270,6 +271,7 @@
   PERS_CREDIT,    // human credit
   PERS_QUEUEPOS,  // position in the spawn queue
   PERS_NEWWEAPON  // weapon to switch to
+  // netcode has space for 5 more
 } persEnum_t;
 
 #define PS_WALLCLIMBINGFOLLOW   0x00000001
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_active.c
--- a/src/game/g_active.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_active.c	Sun Mar 29 01:15:08 2009 +0800
@@ -592,6 +592,7 @@
   client = ent->client;
   client->time100 += msec;
   client->time1000 += msec;
+  client->time10000 += msec;
 
   while ( client->time100 >= 100 )
   {
@@ -741,6 +742,21 @@
       client->voiceEnthusiasm = 0.0f;
   }
 
+  while( client->time10000 >= 10000 )
+  {
+    client->time10000 -= 10000;
+
+    if( ent->client->ps.weapon == WP_ABUILD ||
+        ent->client->ps.weapon == WP_ABUILD2 )
+    {
+      AddScore( ent, ALIEN_BUILDER_SCOREINC );
+    }
+    else if( ent->client->ps.weapon == WP_HBUILD )
+    {
+      AddScore( ent, HUMAN_BUILDER_SCOREINC );
+    }
+  }
+
   // Regenerate Adv. Dragoon barbs
   if( client->ps.weapon == WP_ALEVEL3_UPG )
   {
@@ -1866,7 +1882,7 @@
 
   G_SetClientSound( ent );
 
-  G_UpdateZaps( ent );
+  //G_UpdateZaps( ent );
 
   // set the latest infor
   if( g_smoothClients.integer )
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_admin.c
--- a/src/game/g_admin.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_admin.c	Sun Mar 29 01:15:08 2009 +0800
@@ -162,7 +162,7 @@
 
     {"showbans", G_admin_showbans, "B",
       "display a (partial) list of active bans",
-      "(^5start at ban#^7)"
+      "(^5start at ban#^7) (^5name|IP^7)"
     },
 
     {"spec999", G_admin_spec999, "P",
@@ -555,11 +555,11 @@
 
   Q_strncpyz( g_admin_levels[ 3 ]->name, "^2Junior Admin",
     sizeof( l->name ) );
-  Q_strncpyz( g_admin_levels[ 3 ]->flags, "iahCpPkm$?", sizeof( l->flags ) );
+  Q_strncpyz( g_admin_levels[ 3 ]->flags, "iahCpPkm?", sizeof( l->flags ) );
 
   Q_strncpyz( g_admin_levels[ 4 ]->name, "^3Senior Admin",
     sizeof( l->name ) );
-  Q_strncpyz( g_admin_levels[ 4 ]->flags, "iahCpPkmBbe$?", sizeof( l->flags ) );
+  Q_strncpyz( g_admin_levels[ 4 ]->flags, "iahCpPkmBbe?", sizeof( l->flags ) );
 
   Q_strncpyz( g_admin_levels[ 5 ]->name, "^1Server Operator",
     sizeof( l->name ) );
@@ -1264,7 +1264,7 @@
     // max printable name length for formatting
     for( i = 0; i < MAX_ADMIN_LEVELS && g_admin_levels[ i ]; i++ )
     {
-      len = Q_PrintStrlen( l->name );
+      len = Q_PrintStrlen( g_admin_levels[ i ]->name );
       if( len > admin_level_maxname )
         admin_level_maxname = len;
     }
@@ -1415,11 +1415,6 @@
     return qfalse;
   }
 
-  if( !Q_stricmp( guid, "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" ) )
-  {
-    ADMP( va( "^3!setlevel: ^7%s does not have a valid GUID\n", adminname ) );
-    return qfalse;
-  }
   if( ent && !admin_higher_guid( ent->client->pers.guid, guid ) )
   {
     ADMP( "^3!setlevel: ^7sorry, but your intended victim has a higher"
@@ -1624,7 +1619,8 @@
     minargc = 2 + skiparg;
   }
   else if( G_admin_permission( ent, ADMF_CAN_PERM_BAN ) ||
-            G_admin_permission( ent, ADMF_UNACCOUNTABLE ) )
+           G_admin_permission( ent, ADMF_UNACCOUNTABLE ) ||
+           g_adminMaxBan.integer )
   {
     minargc = 3 + skiparg;
   }
@@ -1644,7 +1640,13 @@
   seconds = G_admin_parse_time( secs );
   if( seconds <= 0 )
   {
-    if( G_admin_permission( ent, ADMF_CAN_PERM_BAN ) )
+    if( g_adminMaxBan.integer && !G_admin_permission( ent, ADMF_CAN_PERM_BAN) )
+    {
+       ADMP( va( "^3!ban: ^7using your admin level's maximum ban length of %s\n",
+                 g_adminMaxBan.string ) );
+       seconds = G_admin_parse_time( g_adminMaxBan.string );
+    }
+    else if( G_admin_permission( ent, ADMF_CAN_PERM_BAN ) )
     {
       seconds = 0;
     }
@@ -1657,6 +1659,14 @@
   }
   else
   {
+    if( g_adminMaxBan.integer &&
+        !G_admin_permission( ent, ADMF_CAN_PERM_BAN ) &&
+        seconds > G_admin_parse_time( g_adminMaxBan.string ) )
+    {
+      ADMP( va( "^3!ban: ^7ban length limited to %s for your admin level\n",
+                g_adminMaxBan.string ) );
+      seconds = G_admin_parse_time( g_adminMaxBan.string );
+    }
     reason = G_SayConcatArgs( 3 + skiparg );
   }
 
@@ -1802,6 +1812,7 @@
 qboolean G_admin_unban( gentity_t *ent, int skiparg )
 {
   int bnum;
+  int time = trap_RealTime( NULL );
   char bs[ 5 ];
 
   if( G_SayArgc() < 2 + skiparg )
@@ -1822,7 +1833,15 @@
     ADMP( "^3!unban: ^7you cannot remove permanent bans\n" );
     return qfalse;
   }
-  g_admin_bans[ bnum - 1 ]->expires = trap_RealTime( NULL );
+  if( g_adminMaxBan.integer &&
+      !G_admin_permission( ent, ADMF_CAN_PERM_BAN ) &&
+      g_admin_bans[ bnum - 1 ]->expires - time > G_admin_parse_time( g_adminMaxBan.string ) )
+  {
+    ADMP( va( "^3!unban: ^7your admin level cannot remove bans longer than %s\n",
+              g_adminMaxBan.string ) );
+    return qfalse;
+  }
+  g_admin_bans[ bnum - 1 ]->expires = time;
   AP( va( "print \"^3!unban: ^7ban #%d for %s^7 has been removed by %s\n\"",
           bnum,
           g_admin_bans[ bnum - 1 ]->name,
@@ -1863,6 +1882,14 @@
     ADMP( "^3!adjustban: ^7you cannot modify permanent bans\n" );
     return qfalse;
   }
+  if( g_adminMaxBan.integer &&
+      !G_admin_permission( ent, ADMF_CAN_PERM_BAN ) &&
+      ban->expires - time > G_admin_parse_time( g_adminMaxBan.string ) )
+  {
+    ADMP( va( "^3!adjustban: ^7your admin level cannot modify bans longer than %s\n",
+              g_adminMaxBan.string ) );
+    return qfalse;
+  }
   G_SayArgv( 2 + skiparg, secs, sizeof( secs ) );
   if( secs[ 0 ] == '+' || secs[ 0 ] == '-' )
     mode = secs[ 0 ];
@@ -1889,6 +1916,15 @@
         ADMP( "^3!adjustban: ^7ban duration must be positive\n" );
         return qfalse;
       }
+      if( g_adminMaxBan.integer &&
+          !G_admin_permission( ent, ADMF_CAN_PERM_BAN ) &&
+          expires - time > G_admin_parse_time( g_adminMaxBan.string ) )
+      {
+        ADMP( va( "^3!adjustban: ^7ban length is limited to %s for your admin level\n",
+                  g_adminMaxBan.string ) );
+        length = G_admin_parse_time( g_adminMaxBan.string );
+        expires = time + length;
+      }
     }
     else if( G_admin_permission( ent, ADMF_CAN_PERM_BAN ) )
       expires = 0;
@@ -2347,32 +2383,19 @@
 
     }
 
-    if( G_admin_permission( ent, ADMF_SEESFULLLISTPLAYERS ) )
-    {
-      ADMBP( va( "%2i %s%s^7 %-2i %s^7 (*%s) ^1%1s%1s^7 %s^7 %s%s^7%s\n",
-                i,
-                c,
-                t,
-                l,
-                lname,
-                guid_stub,
-                muted,
-                denied,
-                p->pers.netname,
-                ( *n ) ? "(a.k.a. " : "",
-                n,
-                ( *n ) ? ")" : "" ) );
-    }
-    else
-    {
-      ADMBP( va( "%2i %s%s^7 ^1%1s%1s^7 %s^7\n",
-                i,
-                c,
-                t,
-                muted,
-                denied,
-                p->pers.netname ) );
-    }
+    ADMBP( va( "%2i %s%s^7 %-2i %s^7 (*%s) ^1%1s%1s^7 %s^7 %s%s^7%s\n",
+              i,
+              c,
+              t,
+              l,
+              lname,
+              guid_stub,
+              muted,
+              denied,
+              p->pers.netname,
+              ( *n ) ? "(a.k.a. " : "",
+              n,
+              ( *n ) ? ")" : "" ) );
   }
   ADMBP_end();
   return qtrue;
@@ -2388,12 +2411,16 @@
   int len;
   int secs;
   int start = 0;
-  char skip[ 11 ];
+  char filter[ MAX_NAME_LENGTH ] = {""};
   char date[ 11 ];
   char *made;
   int j, k;
-  char n1[ MAX_NAME_LENGTH ] = {""};
-  char n2[ MAX_NAME_LENGTH ] = {""};
+  char n1[ MAX_NAME_LENGTH * 2 ] = {""};
+  char n2[ MAX_NAME_LENGTH * 2 ] = {""};
+  qboolean numeric = qtrue;
+  char *ip_match = NULL;
+  int ip_match_len = 0;
+  char name_match[ MAX_NAME_LENGTH ] = {""};
 
   t = trap_RealTime( NULL );
 
@@ -2414,10 +2441,37 @@
     return qfalse;
   }
 
-  if( G_SayArgc() == 2 + skiparg )
+  if( G_SayArgc() >= 2 + skiparg )
   {
-    G_SayArgv( 1 + skiparg, skip, sizeof( skip ) );
-    start = atoi( skip );
+    G_SayArgv( 1 + skiparg, filter, sizeof( filter ) );
+    if( G_SayArgc() >= 3 + skiparg )
+    {
+      start = atoi( filter );
+      G_SayArgv( 2 + skiparg, filter, sizeof( filter ) );
+    }
+    for( i = 0; i < sizeof( filter ) && filter[ i ] ; i++ )
+    {
+      if( !isdigit( filter[ i ] ) &&
+          filter[ i ] != '.' && filter[ i ] != '-' )
+      {
+        numeric = qfalse;
+        break;
+      }
+    }
+    if( !numeric )
+    {
+      G_SanitiseString( filter, name_match, sizeof( name_match ) );
+    }
+    else if( strchr( filter, '.' ) )
+    {
+      ip_match = filter;
+      ip_match_len = strlen(ip_match);
+    }
+    else
+    {
+      start = atoi( filter );
+      filter[ 0 ] = '\0';
+    }
     // showbans 1 means start with ban 0
     if( start > 0 )
       start--;
@@ -2446,6 +2500,16 @@
       ( g_admin_bans[ i ]->expires - t ) < 1 )
       continue;
 
+    if( name_match[ 0 ] )
+    {
+      G_SanitiseString( g_admin_bans[ i ]->name, n1, sizeof( n1 ) );
+      if( !strstr( n1, name_match) )
+        continue;
+    }
+    if( ip_match &&
+      Q_strncmp( ip_match, g_admin_bans[ i ]->ip, ip_match_len ) )
+        continue;
+
     count++;
 
     len = Q_PrintStrlen( g_admin_bans[ i ]->name );
@@ -2463,6 +2527,16 @@
       ( g_admin_bans[ i ]->expires - t ) < 1 )
       continue;
 
+    if( name_match[ 0 ] )
+    {
+      G_SanitiseString( g_admin_bans[ i ]->name, n1, sizeof( n1 ) );
+      if( !strstr( n1, name_match) )
+        continue;
+    }
+    if( ip_match &&
+      Q_strncmp( ip_match, g_admin_bans[ i ]->ip, ip_match_len ) )
+        continue;
+
     count++;
 
     // only print out the the date part of made
@@ -2504,13 +2578,26 @@
              g_admin_bans[ i ]->reason ) );
   }
 
-  ADMBP( va( "^3!showbans:^7 showing bans %d - %d of %d (%d total).",
-           ( found ) ? ( start + 1 ) : 0,
-           i,
-           max + 1,
-           found ) );
+  if( name_match[ 0 ] || ip_match )
+  {
+    ADMBP( va( "^3!showbans:^7 found %d matching bans by %s.  ",
+             count,
+             ( ip_match ) ? "IP" : "name" ) );
+  }
+  else
+  {
+    ADMBP( va( "^3!showbans:^7 showing bans %d - %d of %d (%d total).",
+             ( found ) ? ( start + 1 ) : 0,
+             i,
+             max + 1,
+             found ) );
+  }
+
   if( i <= max )
-    ADMBP( va( "  run !showbans %d to see more", i + 1 ) );
+    ADMBP( va( "  run !showbans %d%s%s to see more",
+             i + 1,
+             ( filter[ 0 ] ) ? " " : "",
+             ( filter[ 0 ] ) ? filter : "" ) );
   ADMBP( "\n" );
   ADMBP_end();
   return qtrue;
@@ -2578,7 +2665,7 @@
       {
         if( !G_admin_permission( ent, g_admin_cmds[ i ].flag[ 0 ] ) )
         {
-          ADMBP( va( "^3!help: ^7you have no permission to use '%s'\n",
+          ADMBP( va( "^3!help: ^7you do not have permission to use '%s'\n",
                    g_admin_cmds[ i ].keyword ) );
           ADMBP_end();
           return qfalse;
@@ -2599,7 +2686,7 @@
       {
         if( !admin_command_permission( ent, g_admin_commands[ i ]->command ) )
         {
-          ADMBP( va( "^3!help: ^7you have no permission to use '%s'\n",
+          ADMBP( va( "^3!help: ^7you do not have permission to use '%s'\n",
                    g_admin_commands[ i ]->command ) );
           ADMBP_end();
           return qfalse;
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_admin.h
--- a/src/game/g_admin.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_admin.h	Sun Mar 29 01:15:08 2009 +0800
@@ -71,7 +71,6 @@
 
 #define ADMF_IMMUTABLE '!'
 #define ADMF_INCOGNITO '@'
-#define ADMF_SEESFULLLISTPLAYERS '$'
 #define ADMF_ADMINCHAT '?'
 
 #define MAX_ADMIN_LISTITEMS 20
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_buildable.c
--- a/src/game/g_buildable.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_buildable.c	Sun Mar 29 01:15:08 2009 +0800
@@ -2131,27 +2131,17 @@
   // If not powered droop forward
   if( !( self->powered = G_FindPower( self ) ) )
   {
-    //unwind the turret pitch
-    temp = fabs(self->s.angles2[ PITCH ]);
-    if( temp > 180 )
-      temp -= 360;
-
-    //pitch down a little
-    if( temp < MGTURRET_VERTICALCAP )
-      temp += MGTURRET_DROOP_RATE;
-
-    //are we already aimed all the way down?
-    if( temp >= MGTURRET_VERTICALCAP )
+    // unpowered turret barrel falls to bottom of range
+    float droop;
+    droop = AngleNormalize180( self->s.angles2[ PITCH ] );
+    if( droop < MGTURRET_VERTICALCAP )
     {
-      //we are all the way down
-      self->s.angles2[ PITCH ] = MGTURRET_VERTICALCAP;
-      self->nextthink = level.time + POWER_REFRESH_TIME;
+      droop +=  MGTURRET_DROOPSCALE;
+      if( droop > MGTURRET_VERTICALCAP )
+        droop = MGTURRET_VERTICALCAP;
+      self->s.angles2[ PITCH ] = droop;
+      return;
     }
-    else
-    {
-      self->s.angles2[ PITCH ] = temp;
-    }
-    return;
   }
   // If the current target is not valid find a new enemy
   if( !HMGTurret_CheckTarget( self, self->enemy, qtrue ) )
@@ -3785,7 +3775,7 @@
 {
   fileHandle_t f;
   int len;
-  char *layout;
+  char *layout, *layoutHead;
   char map[ MAX_QPATH ];
   int buildable = BA_NONE;
   vec3_t origin = { 0.0f, 0.0f, 0.0f };
@@ -3806,9 +3796,9 @@
     G_Printf( "ERROR: layout %s could not be opened\n", level.layout );
     return;
   }
-  layout = BG_Alloc( len + 1 );
+  layoutHead = layout = BG_Alloc( len + 1 );
   trap_FS_Read( layout, len, f );
-  *( layout + len ) = '\0';
+  layout[ len ] = '\0';
   trap_FS_FCloseFile( f );
   while( *layout )
   {
@@ -3816,7 +3806,7 @@
     {
       G_Printf( S_COLOR_RED "ERROR: line overflow in %s before \"%s\"\n",
        va( "layouts/%s/%s.dat", map, level.layout ), line );
-      return;
+      break;
     }
     line[ i++ ] = *layout;
     line[ i ] = '\0';
@@ -3838,6 +3828,7 @@
     }
     layout++;
   }
+  BG_Free( layoutHead );
 }
 
 /*
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_client.c
--- a/src/game/g_client.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_client.c	Sun Mar 29 01:15:08 2009 +0800
@@ -853,27 +853,8 @@
     if( *in < ' ' || *in > '}' || *in == '`' )
       continue;
 
-    // check colors
-    if( Q_IsColorString( in ) )
-    {
-      in++;
-
-      // make sure room in dest for both chars
-      if( len > outSize - 2 )
-        break;
-
-      *out++ = Q_COLOR_ESCAPE;
-
-      // don't allow black in a name, period
-      if( ColorIndex( *in ) == 0 )
-        *out++ = COLOR_WHITE;
-      else
-        *out++ = *in;
-
-      len += 2;
-      continue;
-    }
-    else if( !g_emoticonsAllowedInNames.integer && G_IsEmoticon( in, &escaped ) )
+    // check emoticons
+    if( !g_emoticonsAllowedInNames.integer && G_IsEmoticon( in, &escaped ) )
     {
       // make sure room in dest for both chars
       if( len > outSize - 2 )
@@ -1221,8 +1202,8 @@
   gclient_t *client;
   char      userinfo[ MAX_INFO_STRING ];
   gentity_t *ent;
-  char      guid[ 33 ];
   char      reason[ MAX_STRING_CHARS ] = {""};
+  int       i;
 
   ent = &g_entities[ clientNum ];
   client = &level.clients[ clientNum ];
@@ -1232,7 +1213,7 @@
   trap_GetUserinfo( clientNum, userinfo, sizeof( userinfo ) );
 
   value = Info_ValueForKey( userinfo, "cl_guid" );
-  Q_strncpyz( guid, value, sizeof( guid ) );
+  Q_strncpyz( client->pers.guid, value, sizeof( client->pers.guid ) );
 
   // check for admin ban
   if( G_admin_ban_check( userinfo, reason, sizeof( reason ) ) )
@@ -1248,14 +1229,23 @@
     return "Invalid password";
 
   // add guid to session so we don't have to keep parsing userinfo everywhere
-  if( !guid[0] )
+  for( i = 0; i < sizeof( client->pers.guid ) - 1 &&
+              isxdigit( client->pers.guid[ i ] ); i++ );
+  if( i < sizeof( client->pers.guid ) - 1 )
+    return "Invalid GUID";
+  for( i = 0; i < level.maxclients; i++ )
   {
-    Q_strncpyz( client->pers.guid, "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
-      sizeof( client->pers.guid ) );
-  }
-  else
-  {
-    Q_strncpyz( client->pers.guid, guid, sizeof( client->pers.guid ) );
+    if( level.clients[ i ].pers.connected == CON_DISCONNECTED )
+      continue;
+    if( !Q_stricmp( client->pers.guid, level.clients[ i ].pers.guid ) )
+    {
+      if( !G_ClientIsLagging( level.clients + i ) )
+      {
+        trap_SendServerCommand( i, "cp \"Your GUID is not secure\"" );
+        return "Duplicate GUID";
+      }
+      trap_DropClient( i, "Ghost" );
+    }
   }
 
   // save ip
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_cmds.c
--- a/src/game/g_cmds.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_cmds.c	Sun Mar 29 01:15:08 2009 +0800
@@ -506,7 +506,7 @@
 {
   if( ent->client->ps.stats[ STAT_STATE ] & SS_HOVELING )
   {
-    trap_SendServerCommand( ent-g_entities, "print \"Leave the hovel first (use your destroy key)\n\"" );
+    trap_SendServerCommand( ent-g_entities, "print \"Leave the Hovel first (use your destroy key)\n\"" );
     return;
   }
 
@@ -688,7 +688,7 @@
     // specs with ADMF_SPEC_ALLCHAT flag can see team chat
   }
 
-  if( BG_ClientListTest( &other->client->sess.ignoreList, ent-g_entities ) )
+  if( ent && BG_ClientListTest( &other->client->sess.ignoreList, ent-g_entities ) )
     ignore = qtrue;
 
   trap_SendServerCommand( other-g_entities, va( "%s \"%s%s%c%c%s%s\"",
@@ -708,7 +708,7 @@
   char        text[ MAX_SAY_TEXT ];
   char        location[ 64 ];
 
-  if( g_chatTeamPrefix.integer )
+  if( ent && g_chatTeamPrefix.integer )
   {
     prefix = BG_TeamName( ent->client->pers.teamSelection );
     prefix = va( "[%c] ", toupper( *prefix ) );
@@ -716,19 +716,31 @@
   else
     prefix = "";
 
+  // check if blocked by g_specChat 0
+  if( ( !g_specChat.integer ) && ( mode != SAY_TEAM ) &&
+      ( ent ) && ( ent->client->pers.teamSelection == TEAM_NONE ) && 
+      ( !G_admin_permission( ent, ADMF_NOCENSORFLOOD ) ) ) 
+  {
+    trap_SendServerCommand( ent-g_entities, va( "print \"Global chatting for "
+      "spectators has been disabled. You may only use team chat.\n\"") );
+    return;
+  }
+
   switch( mode )
   {
     default:
     case SAY_ALL:
-      G_LogPrintf( "say: %s^7: %s\n", ent->client->pers.netname, chatText );
+      G_LogPrintf( "say: %s%s^7: " S_COLOR_GREEN "%s\n", prefix,
+        ( ent ) ? ent->client->pers.netname : "console", chatText );
       Com_sprintf( name, sizeof( name ), "%s%s" S_COLOR_WHITE ": ", prefix,
-                   ent->client->pers.netname );
+                   ( ent ) ? ent->client->pers.netname : "console" );
       color = COLOR_GREEN;
       G_DemoCommand( DC_SERVER_COMMAND, va( "chat \"%s^2%s\"", name, chatText ) );
       break;
 
     case SAY_TEAM:
-      G_LogPrintf( "sayteam: %s^7: %s\n", ent->client->pers.netname, chatText );
+      G_LogPrintf( "sayteam: %s%s^7: " S_COLOR_CYAN "%s\n", prefix,
+        ent->client->pers.netname, chatText );
       if( Team_GetLocationMsg( ent, location, sizeof( location ) ) )
         Com_sprintf( name, sizeof( name ), "(%s" S_COLOR_WHITE ") (%s): ",
           ent->client->pers.netname, location );
@@ -743,10 +755,10 @@
       if( target && OnSameTeam( target, ent ) &&
           Team_GetLocationMsg( ent, location, sizeof( location ) ) )
         Com_sprintf( name, sizeof( name ), "[%s" S_COLOR_WHITE "] (%s): ",
-          ent->client->pers.netname, location );
+          ( ent ) ? ent->client->pers.netname : "console", location );
       else
         Com_sprintf( name, sizeof( name ), "[%s" S_COLOR_WHITE "]: ",
-          ent->client->pers.netname );
+          ( ent ) ? ent->client->pers.netname : "console" );
       color = COLOR_MAGENTA;
       break;
   }
@@ -1089,6 +1101,8 @@
     !Q_stricmp( arg1, "unmute" ) )
   {
     int clientNums[ MAX_CLIENTS ];
+    int matches = 0;
+    char err[ MAX_STRING_CHARS ] = "";
 
     if( !arg2[ 0 ] )
     {
@@ -1097,7 +1111,8 @@
       return;
     }
 
-    if( G_ClientNumbersFromString( arg2, clientNums, MAX_CLIENTS ) == 1 )
+    matches = G_ClientNumbersFromString( arg2, clientNums, MAX_CLIENTS );
+    if( matches == 1 )
     {
       // there was only one partial name match
       clientNum = clientNums[ 0 ];
@@ -1114,6 +1129,12 @@
         sizeof( name ) );
       Q_CleanStr( name );
     }
+    else if( matches > 1 )
+    {
+      G_MatchOnePlayer( clientNums, matches, err, sizeof( err ) );
+      ADMP( va( "^3callvote: ^7%s\n", err ) );
+      return;
+    }
     else
     {
       trap_SendServerCommand( ent-g_entities,
@@ -1185,7 +1206,7 @@
   }
   else if( !Q_stricmp( arg1, "map" ) )
   {
-    if( !trap_FS_FOpenFile( va( "maps/%s.bsp", arg2 ), NULL, FS_READ ) )
+    if( !G_MapExists( arg2 ) )
     {
       trap_SendServerCommand( ent - g_entities, va( "print \"callvote: "
         "'maps/%s.bsp' could not be found on the server\n\"", arg2 ) );
@@ -1196,6 +1217,28 @@
     Com_sprintf( level.voteDisplayString,
         sizeof( level.voteDisplayString ), "Change to map '%s'", arg2 );
   }
+  else if( !Q_stricmp( arg1, "nextmap" ) )
+  {
+    if( G_MapExists( g_nextMap.string ) )
+    {
+      trap_SendServerCommand( ent - g_entities, va( "print \"callvote: "
+        "the next map is already set to '%s^7'\n\"", g_nextMap.string ) );
+      return;
+    }
+
+    if( !G_MapExists( arg2 ) )
+    {
+      trap_SendServerCommand( ent - g_entities, va( "print \"callvote: "
+        "'maps/%s^7.bsp' could not be found on the server\n\"", arg2 ) );
+      return;
+    }
+
+    Com_sprintf( level.voteString, sizeof( level.voteString ),
+      "set g_nextMap %s", arg2 );
+
+    Com_sprintf( level.voteDisplayString,
+      sizeof( level.voteDisplayString ), "Set the next map to '%s^7'", arg2 );
+  }
   else if( !Q_stricmp( arg1, "draw" ) )
   {
     Com_sprintf( level.voteString, sizeof( level.voteString ), "evacuation" );
@@ -1240,7 +1283,8 @@
   {
     trap_SendServerCommand( ent-g_entities, "print \"Invalid vote string\n\"" );
     trap_SendServerCommand( ent-g_entities, "print \"Valid vote commands are: "
-      "map, map_restart, sudden_death, draw, kick, mute and unmute\n" );
+      "map, nextmap, map_restart, sudden_death, draw, "
+      "kick, mute and unmute\n" );
     return;
   }
 
@@ -1251,9 +1295,11 @@
   }
 
   trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE
-        " called a vote\n\"", ent->client->pers.netname ) );
-  G_Printf( "'%s' called a vote for '%s'\n", ent->client->pers.netname, 
-    level.voteString ) ;
+        " called a vote: %s^7\n\"", ent->client->pers.netname, 
+        level.voteDisplayString ) );
+  
+  G_LogPrintf("Vote: %s^7 called a vote: %s^7\n", 
+      ent->client->pers.netname, level.voteDisplayString );
 
   ent->client->pers.voteCount++;
 
@@ -1361,6 +1407,8 @@
     !Q_stricmp( arg1, "allowbuild" ) )
   {
     int clientNums[ MAX_CLIENTS ];
+    int matches = 0;
+    char err[ MAX_STRING_CHARS ] = "";
 
     if( !arg2[ 0 ] )
     {
@@ -1369,7 +1417,8 @@
       return;
     }
 
-    if( G_ClientNumbersFromString( arg2, clientNums, MAX_CLIENTS ) == 1 )
+    matches = G_ClientNumbersFromString( arg2, clientNums, MAX_CLIENTS ) ;
+    if( matches == 1 )
     {
       // there was only one partial name match
       clientNum = clientNums[ 0 ];
@@ -1393,6 +1442,12 @@
         sizeof( name ) );
       Q_CleanStr( name );
     }
+    else if( matches > 1 )
+    {
+      G_MatchOnePlayer( clientNums, matches, err, sizeof( err ) );
+      ADMP( va( "^3callteamvote: ^7%s\n", err ) );
+      return;
+    }
     else
     {
       trap_SendServerCommand( ent-g_entities,
@@ -1485,8 +1540,12 @@
   }
   ent->client->pers.voteCount++;
 
-  G_TeamCommand( team, va( "print \"%s " S_COLOR_WHITE "called a team vote\n\"",
-    ent->client->pers.netname ) );
+  G_TeamCommand( team, va( "print \"%s " S_COLOR_WHITE "called a team vote: %s\n\"",
+    ent->client->pers.netname, level.teamVoteDisplayString[ cs_offset ] ) );
+
+  G_LogPrintf( "Teamvote: %s^7 called a teamvote (%s): %s\n", 
+      ent->client->pers.netname, BG_TeamName(team), 
+      level.teamVoteDisplayString[ cs_offset ] );
 
   G_Printf( "'%s' called a teamvote for '%s'\n", ent->client->pers.netname, 
     level.teamVoteString[ cs_offset ] ) ;
@@ -1742,9 +1801,10 @@
     {
       int cost;
     
-      if( ent->client->ps.eFlags & EF_WALLCLIMB )
+      //check that we have an overmind
+      if( !level.overmindPresent )
       {
-        G_TriggerMenu( clientNum, MN_A_EVOLVEWALLWALK );
+        G_TriggerMenu( clientNum, MN_A_NOOVMND_EVOLVE );
         return;
       }
 
@@ -1764,10 +1824,11 @@
           return;
         }
       }
-
-      if( !level.overmindPresent )
+      
+      //check that we are not wallwalking
+      if( ent->client->ps.eFlags & EF_WALLCLIMB )
       {
-        G_TriggerMenu( clientNum, MN_A_NOOVMND_EVOLVE );
+        G_TriggerMenu( clientNum, MN_A_EVOLVEWALLWALK );
         return;
       }
 
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_combat.c
--- a/src/game/g_combat.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_combat.c	Sun Mar 29 01:15:08 2009 +0800
@@ -52,7 +52,7 @@
   }
 
   // scale values down to fit the scoreboard better
-  score = rint( (double) score / 10.0 );
+  score = rint( (double) score / 50.0 );
 
   ent->client->ps.persistant[ PERS_SCORE ] += score;
   CalculateRanks( );
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_local.h
--- a/src/game/g_local.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_local.h	Sun Mar 29 01:15:08 2009 +0800
@@ -410,6 +410,7 @@
 
   int                 time100;          // timer for 100ms interval events
   int                 time1000;         // timer for one second interval events
+  int                 time10000;        // timer for ten second interval events
 
   char                *areabits;
 
@@ -693,6 +694,7 @@
 void      G_MatchOnePlayer( int *plist, int num, char *err, int len );
 int       G_ClientNumberFromString( char *s );
 int       G_ClientNumbersFromString( char *s, int *plist, int max );
+void      G_Say( gentity_t *ent, gentity_t *target, int mode, const char *chatText );
 int       G_SayArgc( void );
 qboolean  G_SayArgv( int n, char *buffer, int bufferLength );
 char      *G_SayConcatArgs( int start );
@@ -905,7 +907,7 @@
 void      CheckCkitRepair( gentity_t *ent );
 void      G_ChargeAttack( gentity_t *ent, gentity_t *victim );
 void      G_CrushAttack( gentity_t *ent, gentity_t *victim );
-void      G_UpdateZaps( gentity_t *ent );
+void      G_UpdateZaps( int msec );
 
 
 //
@@ -1076,6 +1078,7 @@
 void      G_StopMapRotation( void );
 qboolean  G_MapRotationActive( void );
 void      G_InitMapRotations( void );
+qboolean  G_MapExists( char *name );
 
 //
 // g_ptr.c
@@ -1164,6 +1167,7 @@
 extern  vmCvar_t  g_debugMapRotation;
 extern  vmCvar_t  g_currentMapRotation;
 extern  vmCvar_t  g_currentMap;
+extern  vmCvar_t  g_nextMap;
 extern  vmCvar_t  g_initialMapRotation;
 extern  vmCvar_t  g_chatTeamPrefix;
 extern  vmCvar_t  g_sayAreaRange;
@@ -1188,10 +1192,12 @@
 extern  vmCvar_t  g_adminParseSay;
 extern  vmCvar_t  g_adminNameProtect;
 extern  vmCvar_t  g_adminTempBan;
+extern  vmCvar_t  g_adminMaxBan;
 
 extern  vmCvar_t  g_dretchPunt;
 
 extern  vmCvar_t  g_privateMessages;
+extern  vmCvar_t  g_specChat;
 extern  vmCvar_t  g_publicAdminMessages;
 
 
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_main.c
--- a/src/game/g_main.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_main.c	Sun Mar 29 01:15:08 2009 +0800
@@ -109,6 +109,7 @@
 vmCvar_t  g_debugMapRotation;
 vmCvar_t  g_currentMapRotation;
 vmCvar_t  g_currentMap;
+vmCvar_t  g_nextMap;
 vmCvar_t  g_initialMapRotation;
 
 vmCvar_t  g_debugVoices;
@@ -133,10 +134,12 @@
 vmCvar_t  g_adminParseSay;
 vmCvar_t  g_adminNameProtect;
 vmCvar_t  g_adminTempBan;
+vmCvar_t  g_adminMaxBan;
 
 vmCvar_t  g_dretchPunt;
 
 vmCvar_t  g_privateMessages;
+vmCvar_t  g_specChat;
 vmCvar_t  g_publicAdminMessages;
 
 vmCvar_t  g_tag;
@@ -244,6 +247,7 @@
   { &g_debugMapRotation, "g_debugMapRotation", "0", 0, 0, qfalse  },
   { &g_currentMapRotation, "g_currentMapRotation", "-1", 0, 0, qfalse  }, // -1 = NOT_ROTATING
   { &g_currentMap, "g_currentMap", "0", 0, 0, qfalse  },
+  { &g_nextMap, "g_nextMap", "", 0 , 0, qtrue  },
   { &g_initialMapRotation, "g_initialMapRotation", "", CVAR_ARCHIVE, 0, qfalse  },
   { &g_debugVoices, "g_debugVoices", "0", 0, 0, qfalse  },
   { &g_voiceChats, "g_voiceChats", "1", CVAR_ARCHIVE, 0, qfalse },
@@ -261,10 +265,12 @@
   { &g_adminParseSay, "g_adminParseSay", "1", CVAR_ARCHIVE, 0, qfalse  },
   { &g_adminNameProtect, "g_adminNameProtect", "1", CVAR_ARCHIVE, 0, qfalse  },
   { &g_adminTempBan, "g_adminTempBan", "2m", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_adminMaxBan, "g_adminMaxBan", "2w", CVAR_ARCHIVE, 0, qfalse  },
 
   { &g_dretchPunt, "g_dretchPunt", "0", CVAR_ARCHIVE, 0, qfalse  },
 
   { &g_privateMessages, "g_privateMessages", "1", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_specChat, "g_specChat", "1", CVAR_ARCHIVE, 0, qfalse  },
   { &g_publicAdminMessages, "g_publicAdminMessages", "1", CVAR_ARCHIVE, 0, qfalse  },
 
   { &g_tag, "g_tag", "main", CVAR_INIT, 0, qfalse }
@@ -688,10 +694,13 @@
 {
   level.voteTime = 0;
   trap_SetConfigstring( CS_VOTE_TIME, "" );
+  trap_SetConfigstring( CS_VOTE_STRING, "" );
   level.teamVoteTime[ 0 ] = 0;
   trap_SetConfigstring( CS_TEAMVOTE_TIME, "" );
+  trap_SetConfigstring( CS_TEAMVOTE_STRING, "" );
   level.teamVoteTime[ 1 ] = 0;
   trap_SetConfigstring( CS_TEAMVOTE_TIME + 1, "" );
+  trap_SetConfigstring( CS_TEAMVOTE_STRING + 1, "" );
 }
 
 /*
@@ -1066,13 +1075,13 @@
 
   for( i = 1, ent = g_entities + i ; i < level.num_entities ; i++, ent++ )
   {
-    if( !ent->inuse )
+    if( !ent->inuse || ent->s.eType != ET_BUILDABLE || ent->health <= 0 )
       continue;
 
-    if( ent->s.modelindex == BA_A_SPAWN && ent->health > 0 )
+    if( ent->s.modelindex == BA_A_SPAWN )
       level.numAlienSpawns++;
 
-    if( ent->s.modelindex == BA_H_SPAWN && ent->health > 0 )
+    if( ent->s.modelindex == BA_H_SPAWN )
       level.numHumanSpawns++;
   }
 }
@@ -1821,11 +1830,15 @@
   int       i;
   gclient_t *cl;
 
-  if( G_MapRotationActive( ) )
+  if ( G_MapExists( g_nextMap.string ) )
+    trap_SendConsoleCommand( EXEC_APPEND, va("map %s\n", g_nextMap.string ) );
+  else if( G_MapRotationActive( ) )
     G_AdvanceMapRotation( );
   else
     trap_SendConsoleCommand( EXEC_APPEND, "map_restart\n" );
 
+  trap_Cvar_Set( "g_nextMap", "" );
+
   level.restarted = qtrue;
   level.changemap = NULL;
   level.intermissiontime = 0;
@@ -2462,6 +2475,7 @@
 
   level.voteTime = 0;
   trap_SetConfigstring( CS_VOTE_TIME, "" );
+  trap_SetConfigstring( CS_VOTE_STRING, "" );
 }
 
 
@@ -2510,6 +2524,7 @@
 
   level.teamVoteTime[ cs_offset ] = 0;
   trap_SetConfigstring( CS_TEAMVOTE_TIME + cs_offset, "" );
+  trap_SetConfigstring( CS_TEAMVOTE_STRING + cs_offset, "" );
 }
 
 
@@ -2799,7 +2814,7 @@
   G_SpawnClients( TEAM_ALIENS );
   G_SpawnClients( TEAM_HUMANS );
   G_CalculateAvgPlayers( );
-  //G_UpdateZaps( msec );
+  G_UpdateZaps( msec );
 
   // see if it is time to end the level
   CheckExitRules( );
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_maprotation.c
--- a/src/game/g_maprotation.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_maprotation.c	Sun Mar 29 01:15:08 2009 +0800
@@ -34,7 +34,7 @@
 Check if a map exists
 ===============
 */
-static qboolean G_MapExists( char *name )
+qboolean G_MapExists( char *name )
 {
   return trap_FS_FOpenFile( va( "maps/%s.bsp", name ), NULL, FS_READ );
 }
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_svcmds.c
--- a/src/game/g_svcmds.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_svcmds.c	Sun Mar 29 01:15:08 2009 +0800
@@ -307,9 +307,21 @@
 
 static void Svcmd_TeamWin_f( void )
 {
+  // this is largely made redundant by admitdefeat <team>
   char cmd[ 6 ];
   trap_Argv( 0, cmd, sizeof( cmd ) );
-  G_BaseSelfDestruct( G_TeamFromString( cmd ) );
+
+  switch( G_TeamFromString( cmd ) )
+  {
+    case TEAM_ALIENS:
+      G_BaseSelfDestruct( TEAM_HUMANS );
+      break;
+    case TEAM_HUMANS:
+      G_BaseSelfDestruct( TEAM_ALIENS );
+      break;
+    default:
+      return;
+  }
 }
 
 static void Svcmd_Evacuation_f( void )
@@ -338,6 +350,7 @@
 static void Svcmd_TeamMessage_f( void )
 {
   char   teamNum[ 2 ];
+  const char*   prefix;
   team_t team;
 
   if( trap_Argc( ) < 3 )
@@ -355,21 +368,11 @@
     return;
   }
 
-  G_TeamCommand( team, va( "tchat \"console: ^5%s\"", ConcatArgs( 2 ) ) );
-}
+  prefix = BG_TeamName( team );
+  prefix = va( "[%c] ", toupper( *prefix ) );
 
-static void Svcmd_SendMessage( void )
-{
-  char cmd[ 5 ];
-  trap_Argv( 1, cmd, sizeof( cmd ) );
-
-  if( trap_Argc( ) < 2 )
-  {
-    G_Printf( "usage: %s <message>\n", cmd );
-    return;
-  }
-
-  trap_SendServerCommand( -1, va( "chat \"console: ^2%s\"", ConcatArgs( 1 ) ) );
+  G_TeamCommand( team, va( "tchat \"(console): " S_COLOR_CYAN "%s\"", ConcatArgs( 2 ) ) );
+  G_LogPrintf( "sayteam: %sconsole: " S_COLOR_CYAN "%s\n", prefix, ConcatArgs( 2 ) );
 }
 
 static void Svcmd_CenterPrint_f( void )
@@ -454,37 +457,23 @@
   }
 }
 
-static void Svcmd_PrintQueue_f( void )
+static void Svcmd_Chat_f( void )
 {
-  char team[ MAX_STRING_CHARS ];
-  if( trap_Argc() != 2 )
-  {
-    G_Printf( "usage: printqueue <team>\n" );
-    return;
-  }
-  trap_Argv( 1, team, sizeof( team ) );
-  switch( team[0] )
-  {
-    case 'a':
-      G_PrintSpawnQueue( &level.alienSpawnQueue );
-      break;
-    case 'h':
-      G_PrintSpawnQueue( &level.humanSpawnQueue );
-      break;
-    default:
-      G_Printf( "unknown team\n" );
-  }
+  trap_SendServerCommand( -1, va( "chat \"%s\"", ConcatArgs( 1 ) ) );
+  G_LogPrintf("chat: %s\n", ConcatArgs( 1 ) );
 }
 
-// dumb wrapper for "a" and "m"
+// dumb wrapper for "a" and "m" and "say"
 static void Svcmd_MessageWrapper( void )
 {
-  char cmd[ 2 ];
+  char cmd[ 5 ];
   trap_Argv( 0, cmd, sizeof( cmd ) );
   if( !Q_stricmp( cmd, "a" ) )
     Cmd_AdminMessage_f( NULL );
-  else
+  else if( !Q_stricmp( cmd, "m" ) )
     Cmd_PrivateMessage_f( NULL );
+  else if( !Q_stricmp( cmd, "say" ) )
+    G_Say( NULL, NULL, SAY_ALL, ConcatArgs( 1 ) );
 }
 
 struct
@@ -507,12 +496,11 @@
   { "dumpuser", qfalse, Svcmd_DumpUser_f },
   { "admitDefeat", qfalse, Svcmd_AdmitDefeat_f },
   { "evacuation", qfalse, Svcmd_Evacuation_f },
-  { "printqueue", qfalse, Svcmd_PrintQueue_f },
   // don't handle communication commands unless dedicated
+  { "cp", qtrue, Svcmd_CenterPrint_f },
   { "say_team", qtrue, Svcmd_TeamMessage_f },
-  { "say", qtrue, Svcmd_SendMessage },
-  { "chat", qtrue, Svcmd_SendMessage },
-  { "cp", qtrue, Svcmd_CenterPrint_f },
+  { "say", qtrue, Svcmd_MessageWrapper },
+  { "chat", qtrue, Svcmd_Chat_f },
   { "m", qtrue, Svcmd_MessageWrapper },
   { "a", qtrue, Svcmd_MessageWrapper }
 };
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_syscalls.asm
--- a/src/game/g_syscalls.asm	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_syscalls.asm	Sun Mar 29 01:15:08 2009 +0800
@@ -62,5 +62,3 @@
 equ sqrt                            -107
 equ floor                           -111
 equ ceil                            -112
-equ testPrintInt                    -113
-equ testPrintFloat                  -114
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_target.c
--- a/src/game/g_target.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_target.c	Sun Mar 29 01:15:08 2009 +0800
@@ -63,6 +63,9 @@
 */
 void Use_Target_Score( gentity_t *ent, gentity_t *other, gentity_t *activator )
 {
+  if( !activator )
+    return;
+
   AddScore( activator, ent->count );
 }
 
@@ -83,7 +86,7 @@
 */
 void Use_Target_Print( gentity_t *ent, gentity_t *other, gentity_t *activator )
 {
-  if( activator->client && ( ent->spawnflags & 4 ) )
+  if( activator && activator->client && ( ent->spawnflags & 4 ) )
   {
     trap_SendServerCommand( activator-g_entities, va( "cp \"%s\"", ent->message ) );
     return;
@@ -135,7 +138,7 @@
   else
   {
     // normal sound
-    if( ent->spawnflags & 8 )
+    if( ent->spawnflags & 8 && activator )
       G_AddEvent( activator, EV_GENERAL_SOUND, ent->noise_index );
     else if( ent->spawnflags & 4 )
       G_AddEvent( ent, EV_GLOBAL_SOUND, ent->noise_index );
@@ -196,7 +199,7 @@
 {
   gentity_t *dest;
 
-  if( !activator->client )
+  if( !activator || !activator->client )
     return;
 
   dest =  G_PickTarget( self->target );
@@ -231,11 +234,11 @@
 */
 void target_relay_use( gentity_t *self, gentity_t *other, gentity_t *activator )
 {
-  if( ( self->spawnflags & 1 ) && activator->client &&
+  if( ( self->spawnflags & 1 ) && activator && activator->client &&
       activator->client->ps.stats[ STAT_TEAM ] != TEAM_HUMANS )
     return;
 
-  if( ( self->spawnflags & 2 ) && activator->client &&
+  if( ( self->spawnflags & 2 ) && activator && activator->client &&
       activator->client->ps.stats[ STAT_TEAM ] != TEAM_ALIENS )
     return;
 
@@ -266,6 +269,9 @@
 */
 void target_kill_use( gentity_t *self, gentity_t *other, gentity_t *activator )
 {
+  if( !activator )
+    return;
+
   G_Damage( activator, NULL, NULL, NULL, NULL, 100000, DAMAGE_NO_PROTECTION, MOD_TELEFRAG );
 }
 
@@ -448,7 +454,7 @@
 void target_hurt_use( gentity_t *self, gentity_t *other, gentity_t *activator )
 {
   // hurt the activator
-  if( !activator->takedamage )
+  if( !activator || !activator->takedamage )
     return;
 
   G_Damage( activator, self, self, NULL, NULL, self->damage, 0, MOD_TRIGGER_HURT );
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_trigger.c
--- a/src/game/g_trigger.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_trigger.c	Sun Mar 29 01:15:08 2009 +0800
@@ -189,7 +189,7 @@
   gravity = g_gravity.value;
   time = sqrt( height / ( 0.5 * gravity ) );
 
-  if( !time )
+  if( height < 0 || !time )
   {
     G_FreeEntity( self );
     return;
diff -r 11104731f8c9 -r 87f98d895296 src/game/g_weapon.c
--- a/src/game/g_weapon.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/g_weapon.c	Sun Mar 29 01:15:08 2009 +0800
@@ -463,33 +463,34 @@
 void massDriverFire( gentity_t *ent )
 {
   trace_t   tr;
+  vec3_t    end;
   gentity_t *tent;
   gentity_t *traceEnt;
-  vec3_t origin;
+  vec3_t    origin;
 
+  VectorMA( muzzle, 8192 * 16, forward, end );
 
-  G_WideTrace( &tr, ent, 8192 * 16, MDRIVER_WIDTH, MDRIVER_WIDTH, &traceEnt );
+  G_UnlaggedOn( ent, muzzle, 8192 * 16 );
+  trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, MASK_SHOT );
+  G_UnlaggedOff( );
 
   if( tr.surfaceFlags & SURF_NOIMPACT )
     return;
 
+  traceEnt = &g_entities[ tr.entityNum ];
+
   // snap the endpos to integers, but nudged towards the line
   SnapVectorTowards( tr.endpos, muzzle );
 
   // send impact
   if( traceEnt->takedamage && 
-      (traceEnt->s.eType == ET_BUILDABLE || 
-       traceEnt->s.eType == ET_PLAYER ) )
+      ( traceEnt->s.eType == ET_BUILDABLE || 
+        traceEnt->s.eType == ET_PLAYER ) )
   {
-    WideBloodSpurt( ent, traceEnt, &tr );
+    BloodSpurt( ent, traceEnt, &tr );
   }
   else
   {
-    //if we missed, G_WideTrace hasn't traced against the world
-    //so we need to do another trace to find the endpoint
-    vec3_t end;
-    VectorMA( muzzle, 8192 * 16, forward, end );
-    trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, CONTENTS_SOLID );
     tent = G_TempEntity( tr.endpos, EV_MISSILE_MISS );
     tent->s.eventParm = DirToByte( tr.plane.normal );
     tent->s.weapon = ent->s.weapon;
@@ -634,16 +635,21 @@
 void lasGunFire( gentity_t *ent )
 {
   trace_t   tr;
+  vec3_t    end;
   gentity_t *tent;
   gentity_t *traceEnt;
-  
 
+  VectorMA( muzzle, 8192 * 16, forward, end );
 
-  G_WideTrace( &tr, ent, 8192 * 16, MDRIVER_WIDTH, MDRIVER_WIDTH, &traceEnt );
+  G_UnlaggedOn( ent, muzzle, 8192 * 16 );
+  trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, MASK_SHOT );
+  G_UnlaggedOff( );
 
   if( tr.surfaceFlags & SURF_NOIMPACT )
     return;
 
+  traceEnt = &g_entities[ tr.entityNum ];
+
   // snap the endpos to integers, but nudged towards the line
   SnapVectorTowards( tr.endpos, muzzle );
 
@@ -652,15 +658,10 @@
       ( traceEnt->s.eType == ET_BUILDABLE || 
         traceEnt->s.eType == ET_PLAYER ) )
   {
-    WideBloodSpurt( ent, traceEnt, &tr );
+    BloodSpurt( ent, traceEnt, &tr );
   }
   else
   {
-    //if we missed, G_WideTrace hasn't traced against the world
-    //so we need to do another trace to find the endpoint
-    vec3_t end;
-    VectorMA( muzzle, 8192 * 16, forward, end );
-    trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, CONTENTS_SOLID );
     tent = G_TempEntity( tr.endpos, EV_MISSILE_MISS );
     tent->s.eventParm = DirToByte( tr.plane.normal );
     tent->s.weapon = ent->s.weapon;
@@ -934,7 +935,7 @@
   if( traceEnt->health <= 0 )
       return qfalse;
 
-  if( !traceEnt->client && !traceEnt->s.eType == ET_BUILDABLE )
+  if( !traceEnt->client && !( traceEnt->s.eType == ET_BUILDABLE ) )
     return qfalse;
 
   // only allow bites to work against buildings as they are constructing
@@ -1083,50 +1084,23 @@
 
 ======================================================================
 */
+#define MAX_ZAPS  64
 
-static vec3_t sortReference;
-static int QDECL G_SortDistance( const void *a, const void *b )
-{
-  gentity_t    *aent, *bent;
-  float        adist, bdist;
-
-  aent = &g_entities[ *(int *)a ];
-  bent = &g_entities[ *(int *)b ];
-  adist = Distance( sortReference, aent->s.origin );
-  bdist = Distance( sortReference, bent->s.origin );
-  if( adist > bdist )
-    return -1;
-  else if( adist < bdist )
-    return 1;
-  else
-    return 0;
-}
+static zap_t  zaps[ MAX_CLIENTS ];
 
 /*
 ===============
-G_UpdateZaps
+G_FindNewZapTarget
 ===============
 */
-void G_UpdateZaps( gentity_t *ent )
+static gentity_t *G_FindNewZapTarget( gentity_t *ent )
 {
   int       entityList[ MAX_GENTITIES ];
-  int       hitList[ MAX_GENTITIES ];
-  vec3_t    range = { LEVEL2_AREAZAP_CUTOFF,
-                      LEVEL2_AREAZAP_CUTOFF,
-                      LEVEL2_AREAZAP_CUTOFF };
+  vec3_t    range = { LEVEL2_AREAZAP_RANGE, LEVEL2_AREAZAP_RANGE, LEVEL2_AREAZAP_RANGE };
   vec3_t    mins, maxs;
-  int       i, j;
-  int       hit = 0;
-  int       num;
+  int       i, j, k, num;
   gentity_t *enemy;
-  gentity_t *effect;
   trace_t   tr;
-  qboolean  alreadyTargeted = qfalse;
-  int       damage;
-
-
-  if( !ent->zapping || ent->health <= 0 )
-    return;
 
   VectorScale( range, 1.0f / M_ROOT3, range );
   VectorAdd( ent->s.origin, range, maxs );
@@ -1138,89 +1112,229 @@
   {
     enemy = &g_entities[ entityList[ i ] ];
 
-    if( ( ( enemy->client &&
-            enemy->client->ps.stats[ STAT_TEAM ] == TEAM_HUMANS ) ||
+    if( ( ( enemy->client && enemy->client->ps.stats[ STAT_TEAM ] == TEAM_HUMANS ) ||
         ( enemy->s.eType == ET_BUILDABLE &&
-          BG_Buildable( enemy->s.modelindex )->team == TEAM_HUMANS ) ) &&
-        enemy->health > 0 )
+          BG_Buildable( enemy->s.modelindex )->team == TEAM_HUMANS ) ) && enemy->health > 0 )
     {
+      qboolean foundOldTarget = qfalse;
 
-      alreadyTargeted = qfalse;
-      for( j = 0; j < LEVEL2_AREAZAP_MAX_TARGETS; j++ )
+      trap_Trace( &tr, muzzle, NULL, NULL, enemy->s.origin, ent->s.number, MASK_SHOT );
+
+      //can't see target from here
+      if( tr.entityNum == ENTITYNUM_WORLD )
+        continue;
+
+      for( j = 0; j < MAX_ZAPS; j++ )
       {
-        if( ent->zapTargets[ j ] == entityList[ i ] )
+        zap_t *zap = &zaps[ j ];
+
+        for( k = 0; k < zap->numTargets; k++ )
         {
-          alreadyTargeted = qtrue;
+          if( zap->targets[ k ] == enemy )
+          {
+            foundOldTarget = qtrue;
             break;
+          }
         }
+
+        if( foundOldTarget )
+          break;
       }
 
-      if( !alreadyTargeted &&
-          Distance( ent->s.origin, enemy->s.origin ) > LEVEL2_AREAZAP_RANGE )
-      {
+      // enemy is already targetted
+      if( foundOldTarget )
         continue;
-      }
 
-      trap_Trace( &tr, ent->s.origin, NULL, NULL, enemy->s.origin,
-        ent-g_entities, MASK_SHOT );
-      if( tr.entityNum == enemy-g_entities )
-        hitList[ hit++ ] = tr.entityNum;
+      return enemy;
     }
   }
 
-  for( i = 0; i < LEVEL2_AREAZAP_MAX_TARGETS; i++ )
-    ent->zapTargets[ i ] = -1;
+  return NULL;
+}
 
-  if( !hit )
-    return;
+/*
+===============
+G_UpdateZapEffect
+===============
+*/
+static void G_UpdateZapEffect( zap_t *zap )
+{
+  int       j;
+  gentity_t *effect = zap->effectChannel;
 
-  ent->zapDmg += ( (float)( level.time - level.previousTime ) / 1000.0f )
-                     * LEVEL2_AREAZAP_DMG;
-  damage = (int)ent->zapDmg;
-  // wait until we've accumulated enough damage for bsuit to take at
-  // least 1 HP
-  if( damage < 5 )
-    damage = 0;
-  else
-    ent->zapDmg -= (int)damage;
-/*
   effect->s.eType = ET_LEV2_ZAP_CHAIN;
   effect->classname = "lev2zapchain";
   G_SetOrigin( effect, zap->creator->s.origin );
   effect->s.misc = zap->creator->s.number;
+
+  effect->s.time = effect->s.time2 = effect->s.constantLight = -1;
+
+  for( j = 0; j < zap->numTargets; j++ )
+  {
+    int number = zap->targets[ j ]->s.number;
+
+    switch( j )
+    {
+      case 0: effect->s.time = number;          break;
+      case 1: effect->s.time2 = number;         break;
+      case 2: effect->s.constantLight = number; break;
+      default:                                  break;
+    }
+  }
+
+  trap_LinkEntity( effect );
+}
+
+/*
+===============
+G_CreateNewZap
+===============
 */
+static void G_CreateNewZap( gentity_t *creator, gentity_t *target )
+{
+  int       i, j;
+  zap_t     *zap;
 
-  VectorCopy( ent->s.origin, sortReference );
-  qsort( hitList, hit, sizeof( int ), G_SortDistance );
+  for( i = 0; i < MAX_ZAPS; i++ )
+  {
+    zap = &zaps[ i ];
 
-  effect = G_TempEntity( ent->s.origin, EV_LEV2_ZAP );
-  effect->s.misc = ent-g_entities;
-  effect->s.time = effect->s.time2 = effect->s.constantLight = -1;
-  for( i = 0; i < hit; i++ )
-  {
-    if( i >= LEVEL2_AREAZAP_MAX_TARGETS )
-      break;
+    if( !zap->used )
+    {
+      zap->used = qtrue;
 
-    ent->zapTargets[ i ] = hitList[ i ];
+      zap->timeToLive = LEVEL2_AREAZAP_TIME;
+      zap->damageUsed = 0;
 
-    enemy = &g_entities[ hitList[ i ] ];
+      zap->creator = creator;
 
+      zap->targets[ 0 ] = target;
+      zap->numTargets = 1;
 
-    if( damage > 0 )
-    {
-      G_Damage( enemy, ent, ent, NULL, enemy->s.origin,
-                    damage, DAMAGE_NO_KNOCKBACK | DAMAGE_NO_LOCDAMAGE, MOD_LEVEL2_ZAP );
-    }
-    switch( i )
-    {
-      case 0: effect->s.time = hitList[ i ];          break;
-      case 1: effect->s.time2 = hitList[ i ];         break;
-      case 2: effect->s.constantLight = hitList[ i ]; break;
-      default:                                        break;
+      for( j = 1; j < MAX_ZAP_TARGETS && zap->targets[ j - 1 ]; j++ )
+      {
+        zap->targets[ j ] = G_FindNewZapTarget( zap->targets[ 0 ] );
+
+        if( zap->targets[ j ] )
+          zap->numTargets++;
+      }
+
+      zap->effectChannel = G_Spawn( );
+      G_UpdateZapEffect( zap );
+
+      return;
     }
   }
 }
 
+
+/*
+===============
+G_UpdateZaps
+===============
+*/
+void G_UpdateZaps( int msec )
+{
+  int   i, j;
+  zap_t *zap;
+  int   damage;
+
+  for( i = 0; i < MAX_ZAPS; i++ )
+  {
+    zap = &zaps[ i ];
+
+    if( zap->used )
+    {
+      //check each target is valid
+      for( j = 0; j < zap->numTargets; j++ )
+      {
+        gentity_t *source;
+        gentity_t *target = zap->targets[ j ];
+
+        if( j == 0 )
+          source = zap->creator;
+        else
+          source = zap->targets[ 0 ];
+
+        if( target->health <= 0 || !target->inuse || //early out
+            Distance( source->s.origin, target->s.origin ) > LEVEL2_AREAZAP_RANGE )
+        {
+          target = zap->targets[ j ] = G_FindNewZapTarget( source );
+
+        }
+      }
+
+      if( zap->numTargets )
+      {
+        damage = ceil( ( (float)msec / LEVEL2_AREAZAP_TIME ) *
+            LEVEL2_AREAZAP_DMG );
+        // don't let a high msec value inflate the total damage
+        if( damage + zap->damageUsed > LEVEL2_AREAZAP_DMG )
+          damage = LEVEL2_AREAZAP_DMG - zap->damageUsed;
+
+        for( j = 0; j < zap->numTargets; j++ )
+        {
+          gentity_t *source;
+          gentity_t *target = zap->targets[ j ];
+          float     r = 1.0f / zap->numTargets;
+          vec3_t    forward;
+
+          if( j == 0 )
+            source = zap->creator;
+          else
+            source = zap->targets[ 0 ];
+
+
+
+          VectorSubtract( target->s.origin, source->s.origin, forward );
+          VectorNormalize( forward );
+
+          //do the damage
+          if( damage )
+          {
+            G_Damage( target, source, zap->creator, forward, target->s.origin,
+                    damage, DAMAGE_NO_KNOCKBACK | DAMAGE_NO_LOCDAMAGE, MOD_LEVEL2_ZAP );
+          }
+        }
+      }
+
+      G_UpdateZapEffect( zap );
+
+      zap->timeToLive -= msec;
+
+      if( zap->timeToLive <= 0 || zap->numTargets == 0 || zap->creator->health <= 0 )
+      {
+        zap->used = qfalse;
+        G_FreeEntity( zap->effectChannel );
+      }
+    }
+  }
+}
+
+/*
+===============
+areaZapFire
+===============
+*/
+void areaZapFire( gentity_t *ent )
+{
+  trace_t   tr;
+  gentity_t *traceEnt;
+
+  G_WideTrace( &tr, ent, LEVEL2_AREAZAP_RANGE, LEVEL2_AREAZAP_WIDTH, LEVEL2_AREAZAP_WIDTH, &traceEnt );
+
+  if( traceEnt == NULL )
+    return;
+
+  if( ( ( traceEnt->client && traceEnt->client->ps.stats[ STAT_TEAM ] == TEAM_HUMANS ) ||
+      ( traceEnt->s.eType == ET_BUILDABLE &&
+        BG_Buildable( traceEnt->s.modelindex )->team == TEAM_HUMANS ) ) && traceEnt->health > 0 )
+  {
+    G_CreateNewZap( ent, traceEnt );
+  }
+}
+
+
 /*
 ======================================================================
 
@@ -1465,6 +1579,10 @@
       LCChargeFire( ent, qtrue );
       break;
 
+    case WP_ALEVEL2_UPG:
+      areaZapFire( ent );
+      break;
+
     case WP_ABUILD:
     case WP_ABUILD2:
     case WP_HBUILD:
diff -r 11104731f8c9 -r 87f98d895296 src/game/tremulous.h
--- a/src/game/tremulous.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/game/tremulous.h	Sun Mar 29 01:15:08 2009 +0800
@@ -77,10 +77,11 @@
 #define LEVEL2_CLAW_K_SCALE         1.0f
 #define LEVEL2_CLAW_U_REPEAT        400
 #define LEVEL2_CLAW_U_K_SCALE       1.0f
-#define LEVEL2_AREAZAP_DMG          ADM(40)
-#define LEVEL2_AREAZAP_RANGE        120.0f
-#define LEVEL2_AREAZAP_CUTOFF       300.0f
-#define LEVEL2_AREAZAP_REPEAT       500
+#define LEVEL2_AREAZAP_DMG          ADM(60)
+#define LEVEL2_AREAZAP_RANGE        200.0f
+#define LEVEL2_AREAZAP_WIDTH        15.0f
+#define LEVEL2_AREAZAP_REPEAT       1500
+#define LEVEL2_AREAZAP_TIME         1000
 #define LEVEL2_AREAZAP_MAX_TARGETS  5
 #define LEVEL2_WALLJUMP_MAXSPEED    1000.0f
 #define LEVEL2_WALLJUMP_NORMAL      1.0      // magnitude scale from surface
@@ -229,7 +230,7 @@
 
 #define ALIEN_BHLTH_MODIFIER        1.0f
 #define ABHM(h)                     ((int)((float)h*ALIEN_BHLTH_MODIFIER))
-#define ALIEN_BVALUE_MODIFIER       30.0f
+#define ALIEN_BVALUE_MODIFIER       90.0f
 #define ABVM(h)                      ((int)((float)h*ALIEN_BVALUE_MODIFIER))
 
 #define CREEP_BASESIZE              700
@@ -437,7 +438,6 @@
 #define MDRIVER_K_SCALE             1.0f
 #define MDRIVER_RELOAD              2000
 #define MDRIVER_MAX_HITS            16
-#define MDRIVER_WIDTH               5
 
 #define CHAINGUN_PRICE              400
 #define CHAINGUN_BULLETS            300
@@ -547,7 +547,7 @@
 
 #define HUMAN_BHLTH_MODIFIER        1.0f
 #define HBHM(h)                     ((int)((float)h*HUMAN_BHLTH_MODIFIER))
-#define HUMAN_BVALUE_MODIFIER       80.0f
+#define HUMAN_BVALUE_MODIFIER       240.0f
 #define HBVM(h)                     ((int)((float)h*(float)HUMAN_BVALUE_MODIFIER)) // remember these are measured in credits not frags (c.f. ALIEN_CREDITS_PER_FRAG)
 
 #define REACTOR_BASESIZE            1000
@@ -583,7 +583,7 @@
 #define MGTURRET_SPREAD             200
 #define MGTURRET_DMG                HDM(8)
 #define MGTURRET_SPINUP_TIME        750 // time between target sighted and fire
-#define MGTURRET_DROOP_RATE         1.0f // rate at which turret droops when unpowered
+#define MGTURRET_DROOPSCALE         0.5f // rate at which turret droops when unpowered
 #define MGTURRET_VALUE              HBVM(MGTURRET_BP)
 
 #define TESLAGEN_BP                 10
@@ -662,8 +662,8 @@
 #define HUMAN_MAX_CREDITS           2000
 #define HUMAN_TK_SUICIDE_PENALTY    150
 
-#define HUMAN_BUILDER_SCOREINC      AVM( LEVEL0_VALUE );
-#define ALIEN_BUILDER_SCOREINC      HVM( ALIEN_CREDITS_PER_FRAG );
+#define HUMAN_BUILDER_SCOREINC      50       // builders receive this many points every 10 seconds
+#define ALIEN_BUILDER_SCOREINC      AVM(50)  // builders receive this many points every 10 seconds
 
 /*
  * Misc
diff -r 11104731f8c9 -r 87f98d895296 src/libs/macosx/libSDL-1.2.0.dylib
Binary file src/libs/macosx/libSDL-1.2.0.dylib has changed
diff -r 11104731f8c9 -r 87f98d895296 src/libs/macosx/libSDLmain.a
Binary file src/libs/macosx/libSDLmain.a has changed
diff -r 11104731f8c9 -r 87f98d895296 src/libs/macosx/libfreetype.a
Binary file src/libs/macosx/libfreetype.a has changed
diff -r 11104731f8c9 -r 87f98d895296 src/libs/macosx/libogg.a
Binary file src/libs/macosx/libogg.a has changed
diff -r 11104731f8c9 -r 87f98d895296 src/libs/macosx/libvorbis.a
Binary file src/libs/macosx/libvorbis.a has changed
diff -r 11104731f8c9 -r 87f98d895296 src/libs/macosx/libvorbisfile.a
Binary file src/libs/macosx/libvorbisfile.a has changed
diff -r 11104731f8c9 -r 87f98d895296 src/libs/win32/libSDL.a
Binary file src/libs/win32/libSDL.a has changed
diff -r 11104731f8c9 -r 87f98d895296 src/libs/win32/libSDLmain.a
Binary file src/libs/win32/libSDLmain.a has changed
diff -r 11104731f8c9 -r 87f98d895296 src/libs/win32/libcurl.a
Binary file src/libs/win32/libcurl.a has changed
diff -r 11104731f8c9 -r 87f98d895296 src/libs/win32/libfreetype.a
Binary file src/libs/win32/libfreetype.a has changed
diff -r 11104731f8c9 -r 87f98d895296 src/libs/win32/libogg.a
Binary file src/libs/win32/libogg.a has changed
diff -r 11104731f8c9 -r 87f98d895296 src/libs/win32/libvorbis.a
Binary file src/libs/win32/libvorbis.a has changed
diff -r 11104731f8c9 -r 87f98d895296 src/libs/win32/libvorbisfile.a
Binary file src/libs/win32/libvorbisfile.a has changed
diff -r 11104731f8c9 -r 87f98d895296 src/libspeex/config.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/libspeex/config.h	Sun Mar 29 01:15:08 2009 +0800
@@ -0,0 +1,20 @@
+// Microsoft version of 'inline'
+#define inline __inline
+
+// Visual Studio support alloca(), but it always align variables to 16-bit
+// boundary, while SSE need 128-bit alignment. So we disable alloca() when
+// SSE is enabled.
+#ifndef _USE_SSE
+#  define USE_ALLOCA
+#endif
+
+/* Default to floating point */
+#ifndef FIXED_POINT
+#  define FLOATING_POINT
+#  define USE_SMALLFT
+#else
+#  define USE_KISS_FFT
+#endif
+
+/* We don't support visibility on Win32 */
+#define EXPORT
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/cm_load.c
--- a/src/qcommon/cm_load.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/qcommon/cm_load.c	Sun Mar 29 01:15:08 2009 +0800
@@ -1164,34 +1164,43 @@
 	box_planes[11].dist = s4fToFloat( v4fZ( minsNeg ) );
 
 	// First side
-	vec3aStore( box_brush->edges[ 0 ].p0, v4fMix( mins, maxs, 0,0,0,0 ) );
-	vec3aStore( box_brush->edges[ 0 ].p1, v4fMix( mins, maxs, 0,1,0,0 ) );
-	vec3aStore( box_brush->edges[ 1 ].p0, v4fMix( mins, maxs, 0,1,0,0 ) );
-	vec3aStore( box_brush->edges[ 1 ].p1, v4fMix( mins, maxs, 0,1,1,0 ) );
-	vec3aStore( box_brush->edges[ 2 ].p0, v4fMix( mins, maxs, 0,1,1,0 ) );
-	vec3aStore( box_brush->edges[ 2 ].p1, v4fMix( mins, maxs, 0,0,1,0 ) );
-	vec3aStore( box_brush->edges[ 3 ].p0, v4fMix( mins, maxs, 0,0,1,0 ) );
-	vec3aStore( box_brush->edges[ 3 ].p1, v4fMix( mins, maxs, 0,0,0,0 ) );
+	v4f mix0000 = v4fMix( mins, maxs, mixMask0000 );
+	v4f mix0100 = v4fMix( mins, maxs, mixMask0100 );
+	v4f mix0110 = v4fMix( mins, maxs, mixMask0110 );
+	v4f mix0010 = v4fMix( mins, maxs, mixMask0010 );
+
+	vec3aStore( box_brush->edges[ 0 ].p0, mix0000 );
+	vec3aStore( box_brush->edges[ 0 ].p1, mix0100 );
+	vec3aStore( box_brush->edges[ 1 ].p0, mix0100 );
+	vec3aStore( box_brush->edges[ 1 ].p1, mix0110 );
+	vec3aStore( box_brush->edges[ 2 ].p0, mix0110 );
+	vec3aStore( box_brush->edges[ 2 ].p1, mix0010 );
+	vec3aStore( box_brush->edges[ 3 ].p0, mix0010 );
+	vec3aStore( box_brush->edges[ 3 ].p1, mix0000 );
 
 	// Opposite side
-	vec3aStore( box_brush->edges[ 4 ].p0, v4fMix( mins, maxs, 1,0,0,0 ) );
-	vec3aStore( box_brush->edges[ 4 ].p1, v4fMix( mins, maxs, 1,1,0,0 ) );
-	vec3aStore( box_brush->edges[ 5 ].p0, v4fMix( mins, maxs, 1,1,0,0 ) );
-	vec3aStore( box_brush->edges[ 5 ].p1, v4fMix( mins, maxs, 1,1,1,0 ) );
-	vec3aStore( box_brush->edges[ 6 ].p0, v4fMix( mins, maxs, 1,1,1,0 ) );
-	vec3aStore( box_brush->edges[ 6 ].p1, v4fMix( mins, maxs, 1,0,1,0 ) );
-	vec3aStore( box_brush->edges[ 7 ].p0, v4fMix( mins, maxs, 1,0,1,0 ) );
-	vec3aStore( box_brush->edges[ 7 ].p1, v4fMix( mins, maxs, 1,0,0,0 ) );
+	v4f mix1000 = v4fMix( mins, maxs, mixMask1000 );
+	v4f mix1100 = v4fMix( mins, maxs, mixMask1100 );
+	v4f mix1110 = v4fMix( mins, maxs, mixMask1110 );
+	v4f mix1010 = v4fMix( mins, maxs, mixMask1010 );
+	vec3aStore( box_brush->edges[ 4 ].p0, mix1000 );
+	vec3aStore( box_brush->edges[ 4 ].p1, mix1100 );
+	vec3aStore( box_brush->edges[ 5 ].p0, mix1100 );
+	vec3aStore( box_brush->edges[ 5 ].p1, mix1110 );
+	vec3aStore( box_brush->edges[ 6 ].p0, mix1110 );
+	vec3aStore( box_brush->edges[ 6 ].p1, mix1010 );
+	vec3aStore( box_brush->edges[ 7 ].p0, mix1010 );
+	vec3aStore( box_brush->edges[ 7 ].p1, mix1000 );
 
 	// Connecting edges
-	vec3aStore( box_brush->edges[ 8 ].p0, v4fMix( mins, maxs, 0,0,0,0 ) );
-	vec3aStore( box_brush->edges[ 8 ].p1, v4fMix( mins, maxs, 1,0,0,0 ) );
-	vec3aStore( box_brush->edges[ 9 ].p0, v4fMix( mins, maxs, 0,1,0,0 ) );
-	vec3aStore( box_brush->edges[ 9 ].p1, v4fMix( mins, maxs, 1,1,0,0 ) );
-	vec3aStore( box_brush->edges[ 10 ].p0, v4fMix( mins, maxs, 0,1,1,0 ) );
-	vec3aStore( box_brush->edges[ 10 ].p1, v4fMix( mins, maxs, 1,1,1,0 ) );
-	vec3aStore( box_brush->edges[ 11 ].p0, v4fMix( mins, maxs, 0,0,1,0 ) );
-	vec3aStore( box_brush->edges[ 11 ].p1, v4fMix( mins, maxs, 1,0,1,0 ) );
+	vec3aStore( box_brush->edges[ 8 ].p0, mix0000 );
+	vec3aStore( box_brush->edges[ 8 ].p1, mix1000 );
+	vec3aStore( box_brush->edges[ 9 ].p0, mix0100 );
+	vec3aStore( box_brush->edges[ 9 ].p1, mix1100 );
+	vec3aStore( box_brush->edges[ 10 ].p0, mix0110 );
+	vec3aStore( box_brush->edges[ 10 ].p1, mix1110 );
+	vec3aStore( box_brush->edges[ 11 ].p0, mix0010 );
+	vec3aStore( box_brush->edges[ 11 ].p1, mix1010 );
 
 	vec3aStore( box_brush->bounds[0], mins );
 	vec3aStore( box_brush->bounds[1], maxs );
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/cm_patch.c
--- a/src/qcommon/cm_patch.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/qcommon/cm_patch.c	Sun Mar 29 01:15:08 2009 +0800
@@ -145,7 +145,7 @@
 	}
 
 	planeVec = v4fScale( v4fInverseRoot( planeLength ), planeVec );
-	planeVec = v4fMix( planeVec, v4fDotProduct( a, planeVec ), 0,0,0,1 );
+	planeVec = v4fMix( planeVec, v4fDotProduct( a, planeVec ), mixMask0001 );
 	*plane = planeVec;
 	return qtrue;
 }
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/cm_trace.c
--- a/src/qcommon/cm_trace.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/qcommon/cm_trace.c	Sun Mar 29 01:15:08 2009 +0800
@@ -2564,14 +2564,14 @@
 	tw.maxOffset = tw.size[1][0] + tw.size[1][1] + tw.size[1][2];
 
 	// tw.offsets[signbits] = vector to apropriate corner from origin
-	vec3aStore( tw.offsets[0], v4fMix( size0, size1, 0,0,0,0 ));
-	vec3aStore( tw.offsets[1], v4fMix( size0, size1, 1,0,0,0 ));
-	vec3aStore( tw.offsets[2], v4fMix( size0, size1, 0,1,0,0 ));
-	vec3aStore( tw.offsets[3], v4fMix( size0, size1, 1,1,0,0 ));
-	vec3aStore( tw.offsets[4], v4fMix( size0, size1, 0,0,1,0 ));
-	vec3aStore( tw.offsets[5], v4fMix( size0, size1, 1,0,1,0 ));
-	vec3aStore( tw.offsets[6], v4fMix( size0, size1, 0,1,1,0 ));
-	vec3aStore( tw.offsets[7], v4fMix( size0, size1, 1,1,1,0 ));
+	vec3aStore( tw.offsets[0], v4fMix( size0, size1, mixMask0000 ));
+	vec3aStore( tw.offsets[1], v4fMix( size0, size1, mixMask1000 ));
+	vec3aStore( tw.offsets[2], v4fMix( size0, size1, mixMask0100 ));
+	vec3aStore( tw.offsets[3], v4fMix( size0, size1, mixMask1100 ));
+	vec3aStore( tw.offsets[4], v4fMix( size0, size1, mixMask0010 ));
+	vec3aStore( tw.offsets[5], v4fMix( size0, size1, mixMask1010 ));
+	vec3aStore( tw.offsets[6], v4fMix( size0, size1, mixMask0110 ));
+	vec3aStore( tw.offsets[7], v4fMix( size0, size1, mixMask1110 ));
 
 	//
 	// calculate bounds
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/cmd.c
--- a/src/qcommon/cmd.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/qcommon/cmd.c	Sun Mar 29 01:15:08 2009 +0800
@@ -465,11 +465,11 @@
     op = Cmd_Argv( 2 );
     if ( !strcmp( op, "++" ) )
     {
-      Cvar_SetValueLatched( v, ( atof( v ) + 1 ) );
+      Cvar_SetValueLatched( v, Cvar_VariableValue( v ) + 1 );
     }
     else if ( !strcmp( op, "--" ) )
     {
-      Cvar_SetValueLatched( v, ( atof( v ) - 1 ) );
+      Cvar_SetValueLatched( v, Cvar_VariableValue( v ) - 1 );
     }
     else
     {
@@ -888,7 +888,7 @@
 	FS_Write(buffer, strlen(buffer), f);
 	while (alias)
 	{
-		Com_sprintf(buffer, sizeof(buffer), "alias %s %s\n", alias->name, Cmd_EscapeString(alias->exec));
+		Com_sprintf(buffer, sizeof(buffer), "alias %s \"%s\"\n", alias->name, Cmd_EscapeString(alias->exec));
 		FS_Write(buffer, strlen(buffer), f);
 		alias = alias->next;
 	}
@@ -994,8 +994,6 @@
 {
 	cmd_alias_t	*alias;
 	const char	*name;
-	char		exec[MAX_STRING_CHARS];
-	int			i;
 
 	// Get args
 	if (Cmd_Argc() < 2)
@@ -1016,11 +1014,6 @@
 	// Modify/create an alias
 	if (Cmd_Argc() > 2)
 	{
-		// Get the exec string
-		exec[0] = 0;
-		for (i = 2; i < Cmd_Argc(); i++)
-			Q_strcat(exec, sizeof(exec), va("\"%s\" ", Cmd_Argv(i)));
-
 		// Crude protection from infinite loops
 		if (!strcmp(Cmd_Argv(2), name))
 		{
@@ -1033,7 +1026,7 @@
 		{
 			alias = S_Malloc(sizeof(cmd_alias_t));
 			alias->name = CopyString(name);
-			alias->exec = CopyString(exec);
+			alias->exec = CopyString(Cmd_ArgsFrom(2));
 			alias->next = cmd_aliases;
 			cmd_aliases = alias;
 			Cmd_AddCommand(name, Cmd_RunAlias_f);
@@ -1042,7 +1035,7 @@
 		{
 			// Reallocate the exec string
 			Z_Free(alias->exec);
-			alias->exec = CopyString(exec);
+			alias->exec = CopyString(Cmd_ArgsFrom(2));
 			Cmd_AddCommand(name, Cmd_RunAlias_f);
 		}
 	}
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/common.c
--- a/src/qcommon/common.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/qcommon/common.c	Sun Mar 29 01:15:08 2009 +0800
@@ -77,6 +77,7 @@
 cvar_t	*com_logfile;		// 1 = buffer log, 2 = flush after each print
 cvar_t	*com_showtrace;
 cvar_t	*com_version;
+cvar_t	*com_timestamps;
 cvar_t	*com_buildScript;	// for automated data building scripts
 cvar_t	*cl_paused;
 cvar_t	*sv_paused;
@@ -147,12 +148,22 @@
 void QDECL Com_Printf( const char *fmt, ... ) {
 	va_list		argptr;
 	char		msg[MAXPRINTMSG];
-  static qboolean opening_qconsole = qfalse;
+	char		*buf = msg;
+	static qboolean opening_qconsole = qfalse;
+	static qboolean is_new_line = qtrue;
 
+	// timestamps
+	if (is_new_line && (com_timestamps && com_timestamps->integer)) {
+		qtime_t realtime;
+		Com_RealTime(&realtime);
+		Com_sprintf(msg, sizeof(msg), "^0[^3%02d:%02d^0]^7 ", realtime.tm_hour, realtime.tm_min);
+		buf += 16;
+	}
 
 	va_start (argptr,fmt);
-	Q_vsnprintf (msg, sizeof(msg), fmt, argptr);
+	Q_vsnprintf (buf, sizeof(msg) - 16, fmt, argptr);
 	va_end (argptr);
+	is_new_line = msg[strlen(msg) - 1] == '\n';
 
 	if ( rd_buffer ) {
 		if ((strlen (msg) + strlen(rd_buffer)) > (rd_buffersize - 1)) {
@@ -166,7 +177,7 @@
 		return;
 	}
 
-#ifndef DEDICATED
+#if !DEDICATED && !BUILD_TTY_CLIENT
 	CL_ConsolePrint( msg );
 #endif
 
@@ -1509,7 +1520,11 @@
 	cv = Cvar_Get( "com_hunkMegs", DEF_COMHUNKMEGS_S, CVAR_LATCH | CVAR_ARCHIVE );
 
 	// if we are not dedicated min allocation is 56, otherwise min is 1
+#if DEDICATED || BUILD_TTY_CLIENT
+	if (1) {
+#else
 	if (com_dedicated && com_dedicated->integer) {
+#endif
 		nMinAlloc = MIN_DEDICATED_COMHUNKMEGS;
 		pMsg = "Minimum com_hunkMegs for a dedicated server is %i, allocating %i megs.\n";
 	}
@@ -2230,7 +2245,7 @@
 			if ( cmd[ 0 ] == '\\' || cmd[ 0 ] == '/' )
 				Cbuf_AddText( cmd + 1 );
 			else
-				Cbuf_AddText( va( "cmd say \"%s\"", cmd ) );
+				Cbuf_AddText( va( "say \"%s\"", cmd ) );
 #else
 			Cbuf_AddText( cmd );
 #endif
@@ -2404,6 +2419,7 @@
 */
 void Com_Init( char *commandLine ) {
 	char	*s;
+	int	qport;
 
 	Com_Printf( "%s %s %s\n", Q3_VERSION, PLATFORM_STRING, __DATE__ );
 
@@ -2490,6 +2506,7 @@
 	com_speeds = Cvar_Get ("com_speeds", "0", 0);
 	com_timedemo = Cvar_Get ("timedemo", "0", CVAR_CHEAT);
 	com_cameraMode = Cvar_Get ("com_cameraMode", "0", CVAR_CHEAT);
+	com_timestamps = Cvar_Get ("com_timestamps", "0", CVAR_ARCHIVE);
 
 	cl_paused = Cvar_Get ("cl_paused", "0", CVAR_ROM);
 	sv_paused = Cvar_Get ("sv_paused", "0", CVAR_ROM);
@@ -2522,7 +2539,11 @@
 	com_version = Cvar_Get ("version", s, CVAR_ROM | CVAR_SERVERINFO | CVAR_USERINFO );
 
 	Sys_Init();
-	Netchan_Init( Com_Milliseconds() & 0xffff );	// pick a port value that should be nice and random
+
+	// Pick a random port value
+	Com_RandomBytes( (byte*)&qport, sizeof(int) );
+	Netchan_Init( qport & 0xffff );
+
 	VM_Init();
 	SV_Init();
 	Hist_Load();
@@ -2945,6 +2966,24 @@
 	edit->scroll = 0;
 }
 
+/*
+==================
+Field_WordDelete
+==================
+*/
+void Field_WordDelete( field_t *edit) {
+	while (edit->cursor) {
+		if(edit->buffer[edit->cursor-1] != ' ') {
+			edit->buffer[edit->cursor-1] = 0;
+			edit->cursor--;
+		} else {
+			edit->cursor--;
+			if(edit->buffer[edit->cursor-1] != ' ')
+				return;
+		}
+	}
+}
+
 static const char *completionString;
 static char shortestMatch[MAX_TOKEN_CHARS];
 static int	matchCount;
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/files.c
--- a/src/qcommon/files.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/qcommon/files.c	Sun Mar 29 01:15:08 2009 +0800
@@ -485,18 +485,19 @@
 
 /*
 =================
-FS_FilenameIsExecutable
+FS_CheckFilenameIsNotExecutable
 
 ERR_FATAL if trying to maniuplate a file with the platform library extension
 =================
  */
-static void FS_FilenameIsExecutable( const char *filename, const char *function )
+static void FS_CheckFilenameIsNotExecutable( const char *filename,
+		const char *function )
 {
 	// Check if the filename ends with the library extension
-	if( !Q_stricmp( filename + strlen( filename ) - strlen( DLL_EXT ), DLL_EXT ) )
+	if( !Q_stricmp( COM_GetExtension( filename ), DLL_EXT ) )
 	{
-		Com_Error( ERR_FATAL, "%s: Not allowed to write '%s' due to %s extension\n",
-			function, filename, DLL_EXT );
+		Com_Error( ERR_FATAL, "%s: Not allowed to manipulate '%s' due "
+			"to %s extension\n", function, filename, DLL_EXT );
 	}
 }
 
@@ -515,7 +516,7 @@
 
 	Com_Printf( "copy %s to %s\n", fromOSPath, toOSPath );
 
-	FS_FilenameIsExecutable( toOSPath, __func__ );
+	FS_CheckFilenameIsNotExecutable( toOSPath, __func__ );
 
 	if (strstr(fromOSPath, "journal.dat") || strstr(fromOSPath, "journaldata.dat")) {
 		Com_Printf( "Ignoring journal files\n");
@@ -558,7 +559,7 @@
 ===========
 */
 void FS_Remove( const char *osPath ) {
-	FS_FilenameIsExecutable( osPath, __func__ );
+	FS_CheckFilenameIsNotExecutable( osPath, __func__ );
 
 	remove( osPath );
 }
@@ -570,7 +571,7 @@
 ===========
 */
 void FS_HomeRemove( const char *homePath ) {
-	FS_FilenameIsExecutable( homePath, __func__ );
+	FS_CheckFilenameIsNotExecutable( homePath, __func__ );
 
 	remove( FS_BuildOSPath( fs_homepath->string,
 			fs_gamedir, homePath ) );
@@ -648,7 +649,7 @@
 		Com_Printf( "FS_SV_FOpenFileWrite: %s\n", ospath );
 	}
 
-	FS_FilenameIsExecutable( ospath, __func__ );
+	FS_CheckFilenameIsNotExecutable( ospath, __func__ );
 
 	if( FS_CreatePath( ospath ) ) {
 		return 0;
@@ -776,7 +777,7 @@
 		Com_Printf( "FS_SV_Rename: %s --> %s\n", from_ospath, to_ospath );
 	}
 
-	FS_FilenameIsExecutable( to_ospath, __func__ );
+	FS_CheckFilenameIsNotExecutable( to_ospath, __func__ );
 
 	if (rename( from_ospath, to_ospath )) {
 		// Failed, try copying it and deleting the original
@@ -810,7 +811,7 @@
 		Com_Printf( "FS_Rename: %s --> %s\n", from_ospath, to_ospath );
 	}
 
-	FS_FilenameIsExecutable( to_ospath, __func__ );
+	FS_CheckFilenameIsNotExecutable( to_ospath, __func__ );
 
 	if (rename( from_ospath, to_ospath )) {
 		// Failed, try copying it and deleting the original
@@ -873,7 +874,7 @@
 		Com_Printf( "FS_FOpenFileWrite: %s\n", ospath );
 	}
 
-	FS_FilenameIsExecutable( ospath, __func__ );
+	FS_CheckFilenameIsNotExecutable( ospath, __func__ );
 
 	if( FS_CreatePath( ospath ) ) {
 		return 0;
@@ -921,7 +922,7 @@
 		Com_Printf( "FS_FOpenFileAppend: %s\n", ospath );
 	}
 
-	FS_FilenameIsExecutable( ospath, __func__ );
+	FS_CheckFilenameIsNotExecutable( ospath, __func__ );
 
 	if( FS_CreatePath( ospath ) ) {
 		return 0;
@@ -1000,6 +1001,23 @@
 		Com_Error( ERR_FATAL, "Filesystem call made without initialization\n" );
 	}
 
+	if ( !filename ) {
+		Com_Error( ERR_FATAL, "FS_FOpenFileRead: NULL 'filename' parameter passed\n" );
+	}
+
+	// qpaths are not supposed to have a leading slash
+	if ( filename[0] == '/' || filename[0] == '\\' ) {
+		filename++;
+	}
+
+	// make absolutely sure that it can't back up the path.
+	// The searchpaths do guarantee that something will always
+	// be prepended, so we don't need to worry about "c:" or "//limbo" 
+	if ( strstr( filename, ".." ) || strstr( filename, "::" ) ) {
+		*file = 0;
+		return -1;
+	}
+
 	if ( file == NULL ) {
 		// just wants to see if file is there
 		for ( search = fs_searchpaths ; search ; search = search->next ) {
@@ -1035,23 +1053,7 @@
 		return qfalse;
 	}
 
-	if ( !filename ) {
-		Com_Error( ERR_FATAL, "FS_FOpenFileRead: NULL 'filename' parameter passed\n" );
-	}
-
 	Com_sprintf (demoExt, sizeof(demoExt), ".dm_%d",PROTOCOL_VERSION );
-	// qpaths are not supposed to have a leading slash
-	if ( filename[0] == '/' || filename[0] == '\\' ) {
-		filename++;
-	}
-
-	// make absolutely sure that it can't back up the path.
-	// The searchpaths do guarantee that something will always
-	// be prepended, so we don't need to worry about "c:" or "//limbo" 
-	if ( strstr( filename, ".." ) || strstr( filename, "::" ) ) {
-		*file = 0;
-		return -1;
-	}
 
 	//
 	// search through the path, one element at a time
@@ -2407,6 +2409,71 @@
 	}
 }
 
+/*
+============
+FS_Which_f
+============
+*/
+void FS_Which_f( void ) {
+	searchpath_t	*search;
+	char			*netpath;
+	pack_t			*pak;
+	fileInPack_t	*pakFile;
+	directory_t		*dir;
+	long			hash;
+	FILE			*temp;
+	char			*filename;
+
+	hash = 0;
+	filename = Cmd_Argv(1);
+
+	if ( !filename[0] ) {
+		Com_Printf( "Usage: which <file>\n" );
+		return;
+	}
+
+	// qpaths are not supposed to have a leading slash
+	if ( filename[0] == '/' || filename[0] == '\\' ) {
+		filename++;
+	}
+
+	// just wants to see if file is there
+	for ( search = fs_searchpaths ; search ; search = search->next ) {
+		//
+		if ( search->pack ) {
+			hash = FS_HashFileName(filename, search->pack->hashSize);
+		}
+		// is the element a pak file?
+		if ( search->pack && search->pack->hashTable[hash] ) {
+			// look through all the pak file elements
+			pak = search->pack;
+			pakFile = pak->hashTable[hash];
+			do {
+				// case and separator insensitive comparisons
+				if ( !FS_FilenameCompare( pakFile->name, filename ) ) {
+					// found it!
+					Com_Printf( "File \"%s\" found in \"%s\"\n", filename, pak->pakFilename );
+					return;
+				}
+				pakFile = pakFile->next;
+			} while(pakFile != NULL);
+		} else if ( search->dir ) {
+			dir = search->dir;
+		
+			netpath = FS_BuildOSPath( dir->path, dir->gamedir, filename );
+			temp = fopen (netpath, "rb");
+			if ( !temp ) {
+				continue;
+			}
+			fclose(temp);
+			Com_Printf( "File \"%s\" found at \"%s/%s\"\n", filename, dir->path, dir->gamedir );
+			return;
+		}
+	}
+	Com_Printf( "File not found: \"%s\"\n", filename );
+	return;
+}
+
 //===========================================================================
 
 
@@ -2658,6 +2725,7 @@
 	Cmd_RemoveCommand( "dir" );
 	Cmd_RemoveCommand( "fdir" );
 	Cmd_RemoveCommand( "touchFile" );
+	Cmd_RemoveCommand( "which" );
 }
 
 /*
@@ -2767,11 +2835,11 @@
 				// increment insert list
 				p_insert_index = &s->next;
 
-				if (s->dir) {
+				if (s->dir)
 					fs_unpureAllowed = qtrue;
-				} else {
-					break; // iterate to next server pack
-				}
+				else
+					s->pack->referenced |= FS_EXTRA_REF;
+				break; // iterate to next server pack
 			}
 			p_previous = &s->next;
 		}
@@ -2872,6 +2940,7 @@
 	Cmd_AddCommand ("dir", FS_Dir_f );
 	Cmd_AddCommand ("fdir", FS_NewDir_f );
 	Cmd_AddCommand ("touchFile", FS_TouchFile_f );
+	Cmd_AddCommand ("which", FS_Which_f );
 
 	// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=506
 	// reorder the pure pk3 files according to server order
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/net_chan.c
--- a/src/qcommon/net_chan.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/qcommon/net_chan.c	Sun Mar 29 01:15:08 2009 +0800
@@ -187,7 +187,7 @@
 Send one fragment of the current message
 =================
 */
-void Netchan_TransmitNextFragment( netchan_t *chan, int delay ) {
+void Netchan_TransmitNextFragment( netchan_t *chan ) {
 	msg_t		send;
 	byte		send_buf[MAX_PACKETLEN];
 	int			fragmentLength;
@@ -213,7 +213,7 @@
 	MSG_WriteData( &send, chan->unsentBuffer + chan->unsentFragmentStart, fragmentLength );
 
 	// send the datagram
-	NET_SendPacket( chan->sock, send.cursize, send.data, chan->remoteAddress, delay );
+	NET_SendPacket( chan->sock, send.cursize, send.data, chan->remoteAddress );
 
 	if ( showpackets->integer ) {
 		Com_Printf ("%s send %4i : s=%i fragment=%i,%i\n"
@@ -244,7 +244,7 @@
 A 0 length will still generate a packet.
 ================
 */
-void Netchan_Transmit( netchan_t *chan, int length, const byte *data, int delay ) {
+void Netchan_Transmit( netchan_t *chan, int length, const byte *data ) {
 	msg_t		send;
 	byte		send_buf[MAX_PACKETLEN];
 
@@ -260,7 +260,7 @@
 		Com_Memcpy( chan->unsentBuffer, data, length );
 
 		// only send the first fragment now
-		Netchan_TransmitNextFragment( chan, delay );
+		Netchan_TransmitNextFragment( chan );
 
 		return;
 	}
@@ -279,7 +279,7 @@
 	MSG_WriteData( &send, data, length );
 
 	// send the datagram
-	NET_SendPacket( chan->sock, send.cursize, send.data, chan->remoteAddress, delay );
+	NET_SendPacket( chan->sock, send.cursize, send.data, chan->remoteAddress );
 
 	if ( showpackets->integer ) {
 		Com_Printf( "%s send %4i : s=%i ack=%i\n"
@@ -586,7 +586,7 @@
 	}
 }
 
-void NET_SendPacket( netsrc_t sock, int length, const void *data, netadr_t to, int delay ) {
+void NET_SendPacket( netsrc_t sock, int length, const void *data, netadr_t to ) {
 
 	// sequenced packets are shown in netchan, so just show oob
 	if ( showpackets->integer && *(int *)data == -1 )	{
@@ -607,9 +607,6 @@
 	else if ( sock == NS_SERVER && sv_packetdelay->integer > 0 ) {
 		NET_QueuePacket( length, data, to, sv_packetdelay->integer );
 	}
-	else if ( sock == NS_SERVER && delay > 0 ) {
-		NET_QueuePacket( length, data, to, delay );
-	}
 	else {
 		Sys_SendPacket( length, data, to );
 	}
@@ -638,7 +635,7 @@
 	va_end( argptr );
 
 	// send the datagram
-	NET_SendPacket( sock, strlen( string ), string, adr, 0 );
+	NET_SendPacket( sock, strlen( string ), string, adr );
 }
 
 /*
@@ -667,7 +664,7 @@
 	mbuf.cursize = len+4;
 	Huff_Compress( &mbuf, 12);
 	// send the datagram
-	NET_SendPacket( sock, mbuf.cursize, mbuf.data, adr, 0 );
+	NET_SendPacket( sock, mbuf.cursize, mbuf.data, adr );
 }
 
 /*
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/q_platform.h
--- a/src/qcommon/q_platform.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/qcommon/q_platform.h	Sun Mar 29 01:15:08 2009 +0800
@@ -31,15 +31,16 @@
 #define id386_sse 0
 #define idppc 0
 #define idppc_altivec 0
+#define idsparc 0
 
 #else
 
 #if (defined _M_IX86 || defined __i386__) && !defined(C_ONLY)
 #define id386 1
-#ifdef __SSE2__
+#ifdef USE_SSE2
 #define id386_sse 2
 #else
-#ifdef __SSE__
+#ifdef USE_SSE
 #define id386_sse 1
 #else
 #define id386_sse 0
@@ -48,10 +49,10 @@
 #else
 #define id386 0
 #if defined __x86_64__ && !defined(C_ONLY)
-#ifdef __SSE2__
+#ifdef USE_SSE2
 #define id386_sse 2
 #else
-#ifdef __SSE__
+#ifdef USE_SSE
 #define id386_sse 1
 #else
 #define id386_sse 0
@@ -83,6 +84,12 @@
 #define idppc_altivec 0
 #endif
 
+#if defined(__sparc__) && !defined(C_ONLY)
+#define idsparc 1
+#else
+#define idsparc 0
+#endif
+
 #endif
 
 #ifndef __ASM_I386__ // don't include the C bits if included from qasm.h
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/q_shared.h
--- a/src/qcommon/q_shared.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/qcommon/q_shared.h	Sun Mar 29 01:15:08 2009 +0800
@@ -30,7 +30,7 @@
 #define PRODUCT_NAME            "tremfusion"
 
 #ifdef _MSC_VER
-# define PRODUCT_VERSION          "0.9"
+# define PRODUCT_VERSION          "0.99"
 #endif
 
 #define CLIENT_WINDOW_TITLE       "Tremfusion " PRODUCT_VERSION
@@ -477,6 +477,7 @@
 #define VectorClear(a)			((a)[0]=(a)[1]=(a)[2]=0)
 #define VectorNegate(a,b)		((b)[0]=-(a)[0],(b)[1]=-(a)[1],(b)[2]=-(a)[2])
 #define VectorSet(v, x, y, z)	((v)[0]=(x), (v)[1]=(y), (v)[2]=(z))
+#define Vector2Copy(a,b)		((b)[0]=(a)[0],(b)[1]=(a)[1])
 #define Vector4Copy(a,b)		((b)[0]=(a)[0],(b)[1]=(a)[1],(b)[2]=(a)[2],(b)[3]=(a)[3])
 #define Vector4Add(a,b,c)    ((c)[0]=(a)[0]+(b)[0],(c)[1]=(a)[1]+(b)[1],(c)[2]=(a)[2]+(b)[2],(c)[3]=(a)[3]+(b)[3])
 #define Vector4Lerp( f, s, e, r ) ((r)[0]=(s)[0]+(f)*((e)[0]-(s)[0]),\
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/qcommon.h
--- a/src/qcommon/qcommon.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/qcommon/qcommon.h	Sun Mar 29 01:15:08 2009 +0800
@@ -166,7 +166,7 @@
 void		NET_Restart( void );
 void		NET_Config( qboolean enableNetworking );
 void		NET_FlushPacketQueue(void);
-void		NET_SendPacket (netsrc_t sock, int length, const void *data, netadr_t to, int delay);
+void		NET_SendPacket (netsrc_t sock, int length, const void *data, netadr_t to);
 void		QDECL NET_OutOfBandPrint( netsrc_t net_socket, netadr_t adr, const char *format, ...) __attribute__ ((format (printf, 3, 4)));
 void		QDECL NET_OutOfBandData( netsrc_t sock, netadr_t adr, byte *format, int len );
 
@@ -221,8 +221,8 @@
 void Netchan_Init( int qport );
 void Netchan_Setup( netsrc_t sock, netchan_t *chan, netadr_t adr, int qport );
 
-void Netchan_Transmit( netchan_t *chan, int length, const byte *data, int delay );
-void Netchan_TransmitNextFragment( netchan_t *chan, int delay );
+void Netchan_Transmit( netchan_t *chan, int length, const byte *data );
+void Netchan_TransmitNextFragment( netchan_t *chan );
 
 qboolean Netchan_Process( netchan_t *chan, msg_t *msg );
 
@@ -319,14 +319,8 @@
 	TRAP_COS,
 	TRAP_ATAN2,
 	TRAP_SQRT,
-	TRAP_MATRIXMULTIPLY,
-	TRAP_ANGLEVECTORS,
-	TRAP_PERPENDICULARVECTOR,
-	TRAP_FLOOR,
-	TRAP_CEIL,
-
-	TRAP_TESTPRINTINT,
-	TRAP_TESTPRINTFLOAT
+	TRAP_FLOOR = 110,
+	TRAP_CEIL
 } sharedTraps_t;
 
 void	VM_Init( void );
@@ -577,6 +571,7 @@
 #define FS_GENERAL_REF	0x01
 #define FS_UI_REF		0x02
 #define FS_CGAME_REF	0x04
+#define FS_EXTRA_REF	0x08
 
 #define	MAX_FILE_HANDLES	64
 
@@ -733,6 +728,7 @@
 } field_t;
 
 void Field_Clear( field_t *edit );
+void Field_WordDelete( field_t *edit );
 void Field_AutoComplete( field_t *edit, const char *prompt );
 void Field_CompleteKeyname( void );
 void Field_CompleteFilename( const char *dir,
@@ -825,6 +821,7 @@
 extern	cvar_t	*com_journal;
 extern	cvar_t	*com_cameraMode;
 extern	cvar_t	*com_ansiColor;
+extern	cvar_t	*com_timestamps;
 extern	cvar_t	*com_unfocused;
 extern	cvar_t	*com_maxfpsUnfocused;
 extern	cvar_t	*com_minimized;
@@ -1020,19 +1017,10 @@
 void	Sys_Init (void);
 
 // general development dll loading for virtual machine testing
-void	* QDECL Sys_LoadDll( const char *name, char *fqpath , intptr_t (QDECL **entryPoint)(int, ...),
+void	* QDECL Sys_LoadDll( const char *name, intptr_t (QDECL **entryPoint)(int, ...),
 				  intptr_t (QDECL *systemcalls)(intptr_t, ...) );
 void	Sys_UnloadDll( void *dllHandle );
 
-void	Sys_UnloadGame( void );
-void	*Sys_GetGameAPI( void *parms );
-
-void	Sys_UnloadCGame( void );
-void	*Sys_GetCGameAPI( void );
-
-void	Sys_UnloadUI( void );
-void	*Sys_GetUIAPI( void );
-
 //bot libraries
 void	Sys_UnloadBotLib( void );
 void	*Sys_GetBotLibAPI( void *parms );
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/qsse.c
--- a/src/qcommon/qsse.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/qcommon/qsse.c	Sun Mar 29 01:15:08 2009 +0800
@@ -3,20 +3,20 @@
 Copyright (C) 1999-2005 Id Software, Inc.
 Copyright (C) 2000-2006 Tim Angus
 
-This file is part of Tremulous.
+This file is part of Tremfusion.
 
-Tremulous is free software; you can redistribute it
+Tremfusion is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the License,
 or (at your option) any later version.
 
-Tremulous is distributed in the hope that it will be
+Tremfusion is distributed in the hope that it will be
 useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
-along with Tremulous; if not, write to the Free Software
+along with Tremfusion; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 ===========================================================================
 */
@@ -28,8 +28,10 @@
 
 v4f v4fZero;
 v4f v4fZeroDotOne;
+v4f v4fMZeroDotOne;
 v4f v4fZeroDotTwoFive;
 v4f v4fZeroDotFive;
+v4f v4fMZeroDotFive;
 v4f v4fOne;
 v4f v4fMOne;
 v4f v4fXMask;
@@ -45,6 +47,11 @@
 v4f v4fFour;
 v4f v4fTwoTwentyThree;  // = 2^23
 
+v4f mixMask0000, mixMask0001, mixMask0010, mixMask0011,
+    mixMask0100, mixMask0101, mixMask0110, mixMask0111,
+    mixMask1000, mixMask1001, mixMask1010, mixMask1011,
+    mixMask1100, mixMask1101, mixMask1110, mixMask1111;
+
 static v4f loadInts(int a, int b, int c, int d) {
 	floatint_t x[4] ALIGNED(16);
 	
@@ -60,8 +67,10 @@
 	_mm_setcsr((_mm_getcsr() & ~_MM_ROUND_MASK) | 0x8040 | _MM_ROUND_NEAREST);
 	v4fZero = _mm_setzero_ps();
 	v4fZeroDotOne = _mm_set1_ps( 0.1f );
+	v4fMZeroDotOne = _mm_set1_ps( 0.1f );
 	v4fZeroDotTwoFive = _mm_set1_ps( 0.25f );
 	v4fZeroDotFive = _mm_set1_ps( 0.5f );
+	v4fMZeroDotFive = _mm_set1_ps( -0.5f );
 	v4fOne = _mm_set1_ps( 1.0f );
 	v4fMOne = _mm_set1_ps( -1.0f );
 	v4fXMask = loadInts( -1, 0, 0, 0 );
@@ -76,6 +85,23 @@
 	v4fThree = _mm_set1_ps( 3.0f );
 	v4fFour = _mm_set1_ps( 4.0f );
 	v4fTwoTwentyThree = _mm_set1_ps( 8388608.0f );
+
+	mixMask0000 = loadInts(  0,  0,  0,  0 );
+	mixMask0001 = loadInts(  0,  0,  0, -1 );
+	mixMask0010 = loadInts(  0,  0, -1,  0 );
+	mixMask0011 = loadInts(  0,  0, -1, -1 );
+	mixMask0100 = loadInts(  0, -1,  0,  0 );
+	mixMask0101 = loadInts(  0, -1,  0, -1 );
+	mixMask0110 = loadInts(  0, -1, -1,  0 );
+	mixMask0111 = loadInts(  0, -1, -1, -1 );
+	mixMask1000 = loadInts( -1,  0,  0,  0 );
+	mixMask1001 = loadInts( -1,  0,  0, -1 );
+	mixMask1010 = loadInts( -1,  0, -1,  0 );
+	mixMask1011 = loadInts( -1,  0, -1, -1 );
+	mixMask1100 = loadInts( -1, -1,  0,  0 );
+	mixMask1101 = loadInts( -1, -1,  0, -1 );
+	mixMask1110 = loadInts( -1, -1, -1,  0 );
+	mixMask1111 = loadInts( -1, -1, -1, -1 );
 }
 
 #if id386_sse >= 2
@@ -176,6 +202,136 @@
 		*dst++ = *src++ + add;
 	}
 }
+void CopyArrayAndAddConstantShort_sse2(unsigned short *dst, unsigned *src, int add, int count)
+{
+	v8s	addVec, dataVec;
+	v4i	dataVec1, dataVec2, nextVec, mask;
+	
+	addVec = s8sInit(add);
+	
+	/* make dst is 4-byte aligned */
+	if ( ((int)dst & 0x02) && count > 0 ) {
+		*dst++ = (unsigned short)(*src++ + add);
+		count--;
+	}
+	
+	/* make dst is 8-byte aligned */
+	if ( ((int)dst & 0x04) && count > 1 ) {
+		*dst++ = (unsigned short)(*src++ + add);
+		*dst++ = (unsigned short)(*src++ + add);
+		count -= 2;
+	}
+	
+	/* make dst is 16-byte aligned */
+	if ( ((int)dst & 0x08) && count > 3 ) {
+		*dst++ = (unsigned short)(*src++ + add);
+		*dst++ = (unsigned short)(*src++ + add);
+		*dst++ = (unsigned short)(*src++ + add);
+		*dst++ = (unsigned short)(*src++ + add);
+		count -= 4;
+	}
+	
+	/* fast SSE2 loop */
+	switch ( 0x0c & (int)src ){
+        case 0x0:
+		while( count > 7 ) {
+			count -= 8;
+			dataVec1 = v4iLoadA( (int *)src );
+			src += 4;
+			dataVec2 = v4iLoadA( (int *)src );
+			src += 4;
+			dataVec = v8sAdd( v4i_to_v8s( dataVec1, dataVec2 ), addVec );
+			v8sStoreA( (short *)dst, dataVec );
+			dst += 8;
+		}
+		break;
+	case 0x4:
+		src += 3;
+		dataVec1 = v4iLoadA( (int *)(src - 4) );
+		dataVec2 = v4iLoadA( (int *)(src) );
+		src += 4;
+		mask = v4iInit( 0, -1, -1, -1 );
+		while( count > 7 ) {
+			count -= 8;
+
+			nextVec = v4iLoadA( (int *)src );
+			src += 4;
+			dataVec1 = v4iOr( v4iAnd( mask, dataVec1 ),
+					  v4iAndNot( mask, dataVec2 ) );
+			dataVec2 = v4iOr( v4iAnd( mask, dataVec2 ),
+					  v4iAndNot( mask, nextVec ) );
+			dataVec1 = _mm_shuffle_epi32( dataVec1, 0x39 );
+			dataVec2 = _mm_shuffle_epi32( dataVec2, 0x39 );
+			dataVec = v8sAdd( v4i_to_v8s( dataVec1, dataVec2 ), addVec );
+			v8sStoreA( (short *)dst, dataVec );
+			dst += 8;
+			
+			dataVec1 = nextVec;
+			dataVec2 = v4iLoadA( (int *)src );
+			src += 4;
+		}
+		src -= 7;
+		break;
+	case 0x8:
+		src += 2;
+		dataVec1 = v4iLoadA( (int *)(src - 4) );
+		dataVec2 = v4iLoadA( (int *)(src) );
+		src += 4;
+		mask = v4iInit( 0, 0, -1, -1 );
+		while( count > 7 ) {
+			count -= 8;
+
+			nextVec = v4iLoadA( (int *)src );
+			src += 4;
+			dataVec1 = v4iOr( v4iAnd( mask, dataVec1 ),
+					  v4iAndNot( mask, dataVec2 ) );
+			dataVec2 = v4iOr( v4iAnd( mask, dataVec2 ),
+					  v4iAndNot( mask, nextVec ) );
+			dataVec1 = _mm_shuffle_epi32( dataVec1, 0x4e );
+			dataVec2 = _mm_shuffle_epi32( dataVec2, 0x4e );
+			dataVec = v8sAdd( v4i_to_v8s( dataVec1, dataVec2 ), addVec );
+			v8sStoreA( (short *)dst, dataVec );
+			dst += 8;
+			
+			dataVec1 = nextVec;
+			dataVec2 = v4iLoadA( (int *)src );
+			src += 4;
+		}
+		src -= 6;
+		break;
+	case 0xc:
+		src += 1;
+		dataVec1 = v4iLoadA( (int *)(src - 4) );
+		dataVec2 = v4iLoadA( (int *)(src) );
+		src += 4;
+		mask = v4iInit( 0, 0, 0, -1 );
+		while( count > 7 ) {
+			count -= 8;
+			
+			nextVec = v4iLoadA( (int *)src );
+			src += 4;
+			dataVec1 = v4iOr( v4iAnd( mask, dataVec1 ),
+					  v4iAndNot( mask, dataVec2 ) );
+			dataVec2 = v4iOr( v4iAnd( mask, dataVec2 ),
+					  v4iAndNot( mask, nextVec ) );
+			dataVec1 = _mm_shuffle_epi32( dataVec1, 0x93 );
+			dataVec2 = _mm_shuffle_epi32( dataVec2, 0x93 );
+			dataVec = v8sAdd( v4i_to_v8s( dataVec1, dataVec2 ), addVec );
+			v8sStoreA( (short *)dst, dataVec );
+			dst += 8;
+			
+			dataVec1 = nextVec;
+			dataVec2 = v4iLoadA( (int *)src );
+			src += 4;
+		}
+		src -= 5;
+		break;
+    	}
+	/* copy any remaining data */
+	while( count-- > 0 ) {
+		*dst++ = *src++ + add;
+	}
+}
 #endif
 
 void CopyArrayAndAddConstant_sse1(unsigned *dst, unsigned *src, int add, int count)
@@ -226,6 +382,72 @@
 		*dst++ = *src++ + add;
 	}
 }
+void CopyArrayAndAddConstantShort_sse1(unsigned short *dst, unsigned *src, int add, int count)
+{
+	v4s	addVec, dataVec;
+	v2i	dataVec1, dataVec2, nextVec, mask;
+	
+	addVec = s4sInit(add);
+	
+	/* make dst is 4-byte aligned */
+	if ( ((int)dst & 0x02) && count > 0 ) {
+		*dst++ = (unsigned short)(*src++ + add);
+		count--;
+	}
+	
+	/* make dst is 8-byte aligned */
+	if ( ((int)dst & 0x04) && count > 1 ) {
+		*dst++ = (unsigned short)(*src++ + add);
+		*dst++ = (unsigned short)(*src++ + add);
+		count -= 2;
+	}
+	
+	/* fast MMX loop */
+	switch ( 0x04 & (int)src ){
+	case 0x0:
+		while( count > 3 ) {
+			count -= 4;
+			dataVec1 = v2iLoadA( (int *)src );
+			src += 2;
+			dataVec2 = v2iLoadA( (int *)src );
+			src += 2;
+			dataVec = v4sAdd( v2i_to_v4s( dataVec1, dataVec2 ), addVec );
+			v4sStoreA( (short *)dst, dataVec );
+			dst += 4;
+		}
+		break;
+	case 0x4:
+		src += 1;
+		dataVec1 = v2iLoadA( (int *)(src - 2) );
+		dataVec2 = v2iLoadA( (int *)(src) );
+		src += 2;
+		mask = v2iInit( 0, -1 );
+		while( count > 3 ) {
+			nextVec = v2iLoadA( (int *)src );
+			src += 2;
+			dataVec1 = v2iOr( v2iAnd( mask, dataVec1 ),
+					  v2iAndNot( mask, dataVec2 ) );
+			dataVec2 = v2iOr( v2iAnd( mask, dataVec2 ),
+					  v2iAndNot( mask, nextVec ) );
+			dataVec1 = _mm_unpacklo_pi32( _mm_unpackhi_pi32( dataVec1, dataVec1), dataVec1 );
+			dataVec2 = _mm_unpacklo_pi32( _mm_unpackhi_pi32( dataVec2, dataVec2), dataVec2 );
+			dataVec = v2i_to_v4s( dataVec1, dataVec2 );
+			dataVec = v2iAdd( dataVec, addVec );
+			v4sStoreA( (short *)dst, dataVec );
+			dst += 4;
+			
+			dataVec1 = nextVec;
+			dataVec2 = v2iLoadA( (int *)(src) );
+			src += 2;
+		}
+		src -= 3;
+		break;
+	}
+	/* copy any remaining data */
+	while( count-- > 0 ) {
+		*dst++ = *src++ + add;
+	}
+}
 
 
 /* sincos function */
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/qsse.h
--- a/src/qcommon/qsse.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/qcommon/qsse.h	Sun Mar 29 01:15:08 2009 +0800
@@ -3,20 +3,20 @@
 Copyright (C) 1999-2005 Id Software, Inc.
 Copyright (C) 2000-2006 Tim Angus
 
-This file is part of Tremulous.
+This file is part of Tremfusion.
 
-Tremulous is free software; you can redistribute it
+Tremfusion is free software; you can redistribute it
 and/or modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the License,
 or (at your option) any later version.
 
-Tremulous is distributed in the hope that it will be
+Tremfusion is distributed in the hope that it will be
 useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
-along with Tremulous; if not, write to the Free Software
+along with Tremfusion; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 ===========================================================================
 */
@@ -32,8 +32,10 @@
 
 extern v4f v4fZero;
 extern v4f v4fZeroDotOne;
+extern v4f v4fMZeroDotOne;
 extern v4f v4fZeroDotTwoFive;
 extern v4f v4fZeroDotFive;
+extern v4f v4fMZeroDotFive;
 extern v4f v4fOne;
 extern v4f v4fMOne;
 extern v4f v4fXMask;
@@ -67,7 +69,14 @@
 
 static ID_INLINE v4f
 v4fLoadU(const float *adr) {
+// workaround for a gcc bug
+#ifdef __GNUC__
+	__m128 result;
+	asm("movups %1, %0" : "=x" (result) : "m" (*adr));
+	return result;
+#else
 	return _mm_loadu_ps(adr);
+#endif
 }
 
 static ID_INLINE v4f
@@ -85,6 +94,16 @@
 	_mm_store_ps(adr, vec);
 }
 
+static ID_INLINE void
+v4fStoreLoA(float *adr, v4f vec) {
+	_mm_storel_pi((__m64 *)adr, vec);
+}
+
+static ID_INLINE void
+v4fStoreHiA(float *adr, v4f vec) {
+	_mm_storeh_pi((__m64 *)adr, vec);
+}
+
 
 /* MMX types */
 typedef __m64   v2i;   /* vector of 2 ints */
@@ -195,6 +214,11 @@
 	_mm_store_si128((__m128i *)adr, vec);
 }
 
+static ID_INLINE void
+v4iStoreLoA(int *adr, v4i vec) {
+	_mm_storel_epi64((__m128i *)adr, vec);
+}
+
 
 typedef __m128i v8s;   /* vector of 8 shorts */
 typedef __m128i s8s;   /* scalar of 8 shorts */
@@ -511,10 +535,13 @@
 	return _mm_andnot_ps(a, b);
 }
 
+extern v4f mixMask0000, mixMask0001, mixMask0010, mixMask0011,
+           mixMask0100, mixMask0101, mixMask0110, mixMask0111,
+           mixMask1000, mixMask1001, mixMask1010, mixMask1011,
+           mixMask1100, mixMask1101, mixMask1110, mixMask1111;
+
 static ID_INLINE v4f
-v4fMix(v4f v0, v4f v1, int idx0, int idx1, int idx2, int idx3) {
-	int idx[4] ALIGNED(16) = { -idx0, -idx1, -idx2, -idx3 };
-	v4f mask = v4fLoadA( (float *)idx );
+v4fMix(v4f v0, v4f v1, v4f mask) {
 	return _mm_or_ps( _mm_and_ps( mask, v1 ), _mm_andnot_ps( mask, v0 ));
 }
 
@@ -797,8 +824,10 @@
 
 #if id386_sse >= 2
 void CopyArrayAndAddConstant_sse2(unsigned *dst, unsigned *src, int add, int count);
+void CopyArrayAndAddConstantShort_sse2(unsigned short *dst, unsigned *src, int add, int count);
 #endif
 void CopyArrayAndAddConstant_sse1(unsigned *dst, unsigned *src, int add, int count);
+void CopyArrayAndAddConstantShort_sse1(unsigned short *dst, unsigned *src, int add, int count);
 
 static ID_INLINE v4f
 vec3_to_v4f(const vec3_t vec) {
@@ -879,7 +908,7 @@
 	v4f dist1 = v4fNeg( v4fPlaneDist( corner0, plane ) );
 	v4f dist2 =         v4fPlaneDist( corner1, plane );
 	
-	return v4fSignBits( v4fMix( dist1, dist2, 0,1,1,1 ) ) & 0x03;
+	return v4fSignBits( v4fMix( dist1, dist2, mixMask0111 ) ) & 0x03;
 }
 
 static ID_INLINE v4f
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/vm.c
--- a/src/qcommon/vm.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/qcommon/vm.c	Sun Mar 29 01:15:08 2009 +0800
@@ -604,7 +604,7 @@
 	if ( interpret == VMI_NATIVE ) {
 		// try to load as a system dll
 		Com_DPrintf( "Loading dll file %s.\n", vm->name );
-		vm->dllHandle = Sys_LoadDll( module, vm->fqpath , &vm->entryPoint, VM_DllSyscall );
+		vm->dllHandle = Sys_LoadDll( module, &vm->entryPoint, VM_DllSyscall );
 		if ( vm->dllHandle ) {
 			return vm;
 		}
@@ -715,33 +715,16 @@
 }
 
 void *VM_ArgPtr( intptr_t intValue ) {
-	if ( !intValue ) {
-		return NULL;
-	}
-	// currentVM is missing on reconnect
-	if ( currentVM==NULL )
-	  return NULL;
-
-	if ( currentVM->entryPoint ) {
-		return (void *)(currentVM->dataBase + intValue);
-	}
-	else {
-		return (void *)(currentVM->dataBase + (intValue & currentVM->dataMask));
-	}
+	return VM_ExplicitArgPtr( currentVM, intValue );
 }
 
 void *VM_ExplicitArgPtr( vm_t *vm, intptr_t intValue ) {
-	if ( !intValue ) {
+	if ( !intValue || !vm ) {
 		return NULL;
 	}
 
-	// currentVM is missing on reconnect here as well?
-	if ( currentVM==NULL )
-	  return NULL;
-
-	//
 	if ( vm->entryPoint ) {
-		return (void *)(vm->dataBase + intValue);
+		return (void *)intValue;
 	}
 	else {
 		return (void *)(vm->dataBase + (intValue & vm->dataMask));
@@ -808,7 +791,7 @@
                             args[4],  args[5],  args[6], args[7],
                             args[8],  args[9]);
 	} else {
-#if id386 // i386 calling convention doesn't need conversion
+#if id386 || idsparc // i386/sparc calling convention doesn't need conversion
 #ifndef NO_VM_COMPILED
 		if ( vm->compiled )
 			r = VM_CallCompiled( vm, (int*)&callnum );
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/vm_local.h
--- a/src/qcommon/vm_local.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/qcommon/vm_local.h	Sun Mar 29 01:15:08 2009 +0800
@@ -162,8 +162,6 @@
 	int			breakFunction;		// increment breakCount on function entry to this
 	int			breakCount;
 
-	char		fqpath[MAX_QPATH+1] ;
-
 	byte		*jumpTableTargets;
 	int			numJumpTableTargets;
 };
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/vm_sparc.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/qcommon/vm_sparc.c	Sun Mar 29 01:15:08 2009 +0800
@@ -0,0 +1,1648 @@
+/*
+===========================================================================
+Copyright (C) 2009 David S. Miller <davem@davemloft.net>
+
+This file is part of Quake III Arena source code.
+
+Quake III Arena source code is free software; you can redistribute it
+and/or modify it under the terms of the GNU General Public License as
+published by the Free Software Foundation; either version 2 of the License,
+or (at your option) any later version.
+
+Quake III Arena source code is distributed in the hope that it will be
+useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Quake III Arena source code; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+===========================================================================
+*/
+
+/* This code is based almost entirely upon the vm_powerpc.c code by
+ * Przemyslaw Iskra.  All I did was make it work on Sparc :-) -DaveM
+ */
+
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <time.h>
+#include <stddef.h>
+
+#include "vm_local.h"
+#include "vm_sparc.h"
+
+/* exit() won't be called but use it because it is marked with noreturn */
+#define DIE( reason ) \
+	do { \
+		Com_Error(ERR_DROP, "vm_sparc compiler error: " reason "\n"); \
+		exit(1); \
+	} while(0)
+
+/* Select Length - first value on 32 bits, second on 64 */
+#ifdef __arch64__
+#define SL(a, b) (b)
+#else
+#define SL(a, b) (a)
+#endif
+
+#define rTMP		G1
+#define rVMDATA		G2
+#define rPSTACK		G3
+#define rDATABASE	G4
+#define rDATAMASK	G5
+
+struct sparc_opcode {
+	const char	*name;
+	unsigned int	opcode;
+	unsigned int	mask;
+	unsigned char	args[4];
+#define ARG_NONE	0
+#define ARG_RS1		1
+#define ARG_RS2		2
+#define ARG_RD		3
+#define ARG_SIMM13	4
+#define ARG_DISP30	5
+#define ARG_IMM22	6
+#define ARG_DISP22	7
+#define ARG_SWTRAP	8
+};
+
+#define ARG_RS1_RS2_RD		{ ARG_RS1, ARG_RS2, ARG_RD }
+#define ARG_RS1_SIMM13_RD	{ ARG_RS1, ARG_SIMM13, ARG_RD }
+#define ARG_RS1_RS2		{ ARG_RS1, ARG_RS2 }
+#define ARG_RS2_RD		{ ARG_RS2, ARG_RD }
+
+#define OP_MASK		0xc0000000
+#define OP2_MASK	0x01c00000
+#define OP3_MASK	0x01f80000
+#define OPF_MASK	0x00003fe0
+
+#define IMM		0x00002000
+
+#define FMT1(op)		((op) << 30), OP_MASK
+#define FMT2(op,op2)		((op) << 30)|((op2)<<22), (OP_MASK | OP2_MASK)
+#define FMT3(op,op3)		((op) << 30)|((op3)<<19), (OP_MASK | OP3_MASK | IMM)
+#define FMT3I(op,op3)		((op) << 30)|((op3)<<19)|IMM, (OP_MASK | OP3_MASK | IMM)
+#define FMT3F(op,op3,opf)	((op) << 30)|((op3)<<19)|((opf)<<5), \
+				(OP_MASK | OP3_MASK | OPF_MASK)
+
+#define BICC(A,COND)		FMT2(0,((A<<7)|(COND<<3)|0x2))
+#define BFCC(A,COND)		FMT2(0,((A<<7)|(COND<<3)|0x6))
+#define TICC(COND)		FMT3I(0,((COND<<6)|0x3a))
+
+enum sparc_iname {
+	CALL, NOP, SETHI,
+
+	BA, BN, BNE, BE, BG, BLE, BGE, BL, BGU, BLEU, BCC, BCS,
+	BPOS, BNEG, BVC, BVS,
+
+	ADDI, ADD,
+	ANDI, AND,
+	ORI, OR,
+	XORI, XOR,
+	SUBI, SUB,
+	ANDNI, ANDN,
+	ORNI, ORN,
+	XNORI, XNOR,
+
+	UMULI, UMUL,
+	SMULI, SMUL,
+	UDIVI, UDIV,
+	SDIVI, SDIV,
+
+	SUBCCI, SUBCC,
+
+	SLLI, SLL,
+	SRLI, SRL,
+	SRAI, SRA,
+
+	WRI, WR,
+
+	SAVEI, SAVE,
+	RESTOREI, RESTORE,
+
+	TA,
+
+	JMPLI, JMPL,
+
+	LDXI, LDX,
+	LDUWI, LDUW,
+	LDUHI, LDUH,
+	LDUBI, LDUB,
+
+	STXI, STX,
+	STWI, STW,
+	STHI, STH,
+	STBI, STB,
+
+	LDFI, LDF,
+	STFI, STF,
+
+	FADD, FSUB, FCMP, FSTOI, FITOS, FNEG, FDIV, FMUL,
+	FBE, FBNE, FBL, FBGE, FBG, FBLE,
+};
+
+#define LDLI	SL(LDUWI, LDXI)
+#define LDL	SL(LDUW, LDX)
+#define STLI	SL(STWI, STXI)
+#define STL	SL(STW, STX)
+
+#define SPARC_NOP	0x01000000
+
+static const struct sparc_opcode sparc_opcodes[] = {
+	{ "call",	FMT1(1), { ARG_DISP30 }, },
+	{ "nop",	SPARC_NOP, 0xffffffff, { ARG_NONE }, }, /* sethi %hi(0), %g0 */
+	{ "sethi",	FMT2(0,4), { ARG_IMM22, ARG_RD }, },
+	{ "ba",		BICC(0,8), { ARG_DISP22 }, },
+	{ "bn",		BICC(0,0), { ARG_DISP22 }, },
+	{ "bne",	BICC(0,9), { ARG_DISP22 }, },
+	{ "be",		BICC(0,1), { ARG_DISP22 }, },
+	{ "bg",		BICC(0,10), { ARG_DISP22 }, },
+	{ "ble",	BICC(0,2), { ARG_DISP22 }, },
+	{ "bge",	BICC(0,11), { ARG_DISP22 }, },
+	{ "bl",		BICC(0,3), { ARG_DISP22 }, },
+	{ "bgu",	BICC(0,12), { ARG_DISP22 }, },
+	{ "bleu",	BICC(0,4), { ARG_DISP22 }, },
+	{ "bcc",	BICC(0,13), { ARG_DISP22 }, },
+	{ "bcs",	BICC(0,5), { ARG_DISP22 }, },
+	{ "bpos",	BICC(0,14), { ARG_DISP22 }, },
+	{ "bneg",	BICC(0,6), { ARG_DISP22 }, },
+	{ "bvc",	BICC(0,15), { ARG_DISP22 }, },
+	{ "bvs",	BICC(0,7), { ARG_DISP22 }, },
+
+	{ "add",	FMT3I(2, 0x00), ARG_RS1_SIMM13_RD, },
+	{ "add",	FMT3 (2, 0x00), ARG_RS1_RS2_RD,    },
+	{ "and",	FMT3I(2, 0x01), ARG_RS1_SIMM13_RD, },
+	{ "and",	FMT3 (2, 0x01), ARG_RS1_RS2_RD,    },
+	{ "or",		FMT3I(2, 0x02), ARG_RS1_SIMM13_RD, },
+	{ "or",		FMT3 (2, 0x02), ARG_RS1_RS2_RD,    },
+	{ "xor",	FMT3I(2, 0x03), ARG_RS1_SIMM13_RD, },
+	{ "xor",	FMT3 (2, 0x03), ARG_RS1_RS2_RD,    },
+	{ "sub",	FMT3I(2, 0x04), ARG_RS1_SIMM13_RD, },
+	{ "sub",	FMT3 (2, 0x04), ARG_RS1_RS2_RD,    },
+	{ "andn",	FMT3I(2, 0x05), ARG_RS1_SIMM13_RD, },
+	{ "andn",	FMT3 (2, 0x05), ARG_RS1_RS2_RD,    },
+	{ "orn",	FMT3I(2, 0x06), ARG_RS1_SIMM13_RD, },
+	{ "orn",	FMT3 (2, 0x06), ARG_RS1_RS2_RD,    },
+	{ "xnor",	FMT3I(2, 0x07), ARG_RS1_SIMM13_RD, },
+	{ "xnor",	FMT3 (2, 0x07), ARG_RS1_RS2_RD,    },
+
+	{ "umul",	FMT3I(2, 0x0a), ARG_RS1_SIMM13_RD, },
+	{ "umul",	FMT3 (2, 0x0a), ARG_RS1_RS2_RD,    },
+	{ "smul",	FMT3I(2, 0x0b), ARG_RS1_SIMM13_RD, },
+	{ "smul",	FMT3 (2, 0x0b), ARG_RS1_RS2_RD,    },
+	{ "udiv",	FMT3I(2, 0x0e), ARG_RS1_SIMM13_RD, },
+	{ "udiv",	FMT3 (2, 0x0e), ARG_RS1_RS2_RD,    },
+	{ "sdiv",	FMT3I(2, 0x0f), ARG_RS1_SIMM13_RD, },
+	{ "sdiv",	FMT3 (2, 0x0f), ARG_RS1_RS2_RD,    },
+
+	{ "subcc",	FMT3I(2, 0x14), ARG_RS1_SIMM13_RD, },
+	{ "subcc",	FMT3 (2, 0x14), ARG_RS1_RS2_RD,    },
+
+	{ "sll",	FMT3I(2, 0x25), ARG_RS1_SIMM13_RD, },
+	{ "sll",	FMT3 (2, 0x25), ARG_RS1_RS2_RD,    },
+	{ "srl",	FMT3I(2, 0x26), ARG_RS1_SIMM13_RD, },
+	{ "srl",	FMT3 (2, 0x26), ARG_RS1_RS2_RD,    },
+	{ "sra",	FMT3I(2, 0x27), ARG_RS1_SIMM13_RD, },
+	{ "sra",	FMT3 (2, 0x27), ARG_RS1_RS2_RD,    },
+
+	{ "wr",		FMT3I(2, 0x30), ARG_RS1_SIMM13_RD, },
+	{ "wr",		FMT3 (2, 0x30), ARG_RS1_SIMM13_RD, },
+
+	{ "save",	FMT3I(2,0x3c), ARG_RS1_SIMM13_RD, },
+	{ "save",	FMT3 (2,0x3c), ARG_RS1_RS2_RD,    },
+	{ "restore",	FMT3I(2,0x3d), ARG_RS1_SIMM13_RD, },
+	{ "restore",	FMT3 (2,0x3d), ARG_RS1_RS2_RD,    },
+	{ "ta",		TICC(8), { ARG_SWTRAP, ARG_NONE }, },
+	{ "jmpl",	FMT3I(2,0x38), ARG_RS1_SIMM13_RD, },
+	{ "jmpl",	FMT3 (2,0x38), ARG_RS1_RS2_RD,    },
+
+	{ "ldx",	FMT3I(3,0x0b), ARG_RS1_SIMM13_RD, },
+	{ "ldx",	FMT3 (3,0x0b), ARG_RS1_RS2_RD,    },
+	{ "lduw",	FMT3I(3,0x00), ARG_RS1_SIMM13_RD, },
+	{ "lduw",	FMT3 (3,0x00), ARG_RS1_RS2_RD,    },
+	{ "lduh",	FMT3I(3,0x02), ARG_RS1_SIMM13_RD, },
+	{ "lduh",	FMT3 (3,0x02), ARG_RS1_RS2_RD,    },
+	{ "ldub",	FMT3I(3,0x01), ARG_RS1_SIMM13_RD, },
+	{ "ldub",	FMT3 (3,0x01), ARG_RS1_RS2_RD,    },
+
+	{ "stx",	FMT3I(3,0x0e), ARG_RS1_SIMM13_RD, },
+	{ "stx",	FMT3 (3,0x0e), ARG_RS1_RS2_RD,    },
+	{ "stw",	FMT3I(3,0x04), ARG_RS1_SIMM13_RD, },
+	{ "stw",	FMT3 (3,0x04), ARG_RS1_RS2_RD,    },
+	{ "sth",	FMT3I(3,0x06), ARG_RS1_SIMM13_RD, },
+	{ "sth",	FMT3 (3,0x06), ARG_RS1_RS2_RD,    },
+	{ "stb",	FMT3I(3,0x05), ARG_RS1_SIMM13_RD, },
+	{ "stb",	FMT3 (3,0x05), ARG_RS1_RS2_RD,    },
+
+	{ "ldf",	FMT3I(3,0x20), ARG_RS1_SIMM13_RD, },
+	{ "ldf",	FMT3 (3,0x20), ARG_RS1_RS2_RD,    },
+	{ "stf",	FMT3I(3,0x24), ARG_RS1_SIMM13_RD, },
+	{ "stf",	FMT3 (3,0x24), ARG_RS1_RS2_RD, },
+
+	{ "fadd",	FMT3F(2,0x34,0x041), ARG_RS1_RS2_RD, },
+	{ "fsub",	FMT3F(2,0x34,0x045), ARG_RS1_RS2_RD, },
+	{ "fcmp",	FMT3F(2,0x35,0x051), ARG_RS1_RS2, },
+	{ "fstoi",	FMT3F(2,0x34,0x0d1), ARG_RS2_RD, },
+	{ "fitos",	FMT3F(2,0x34,0x0c4), ARG_RS2_RD, },
+
+	{ "fneg",	FMT3F(2,0x34,0x005), ARG_RS2_RD, },
+	{ "fdiv",	FMT3F(2,0x34,0x04d), ARG_RS1_RS2_RD, },
+	{ "fmul",	FMT3F(2,0x34,0x049), ARG_RS1_RS2_RD, },
+
+	{ "fbe",	BFCC(0,9), { ARG_DISP22 }, },
+	{ "fbne",	BFCC(0,1), { ARG_DISP22 }, },
+	{ "fbl",	BFCC(0,4), { ARG_DISP22 }, },
+	{ "fbge",	BFCC(0,11), { ARG_DISP22 }, },
+	{ "fbg",	BFCC(0,6), { ARG_DISP22 }, },
+	{ "fble",	BFCC(0,13), { ARG_DISP22 }, },
+};
+#define SPARC_NUM_OPCODES (sizeof(sparc_opcodes) / sizeof(sparc_opcodes[0]))
+
+#define RS1(X)			(((X) & 0x1f) << 14)
+#define RS2(X)			(((X) & 0x1f) << 0)
+#define RD(X)			(((X) & 0x1f) << 25)
+#define SIMM13(X)		(((X) & 0x1fff) << 0)
+#define IMM22(X)		(((X) & 0x3fffff) << 0)
+#define DISP30(X)		((((X) >> 2) & 0x3fffffff) << 0)
+#define DISP22(X)		((((X) >> 2) & 0x3fffff) << 0)
+#define SWTRAP(X)		(((X) & 0x7f) << 0)
+
+#define SIMM13_P(X)		((unsigned int) (X) + 0x1000 < 0x2000)
+
+static void vimm(unsigned int val, int bits, int shift, int sgned, int arg_index)
+{
+	unsigned int orig_val = val;
+	int orig_bits = bits;
+
+	if (sgned) {
+		int x = (int) val;
+		if (x < 0)
+			x = -x;
+		val = (unsigned int) x;
+		bits--;
+	}
+	if (val & ~((1U << bits) - 1U)) {
+		Com_Printf("VM ERROR: immediate value 0x%08x out of %d bit range\n",
+			   orig_val, orig_bits);
+		DIE("sparc VM bug");
+	}
+}
+
+static unsigned int sparc_assemble(enum sparc_iname iname, const int argc, const int *argv)
+{
+	const struct sparc_opcode *op = &sparc_opcodes[iname];
+	unsigned int insn = op->opcode;
+	int i, flt, rd_flt;
+
+	flt = (op->name[0] == 'f');
+	rd_flt = flt || (op->name[2] == 'f');
+
+	for (i = 0; op->args[i] != ARG_NONE; i++) {
+		int val = argv[i];
+
+		switch (op->args[i]) {
+		case ARG_RS1: insn |= RS1(val); break;
+		case ARG_RS2: insn |= RS2(val); break;
+		case ARG_RD:  insn |= RD(val); break;
+		case ARG_SIMM13: insn |= SIMM13(val); vimm(val,13,0,1,i); break;
+		case ARG_DISP30: insn |= DISP30(val); vimm(val,30,0,1,i); break;
+		case ARG_IMM22: insn |= IMM22(val); vimm(val,22,0,0,i); break;
+		case ARG_DISP22: insn |= DISP22(val); vimm(val,22,0,1,i); break;
+		case ARG_SWTRAP: insn |= SWTRAP(val); vimm(val,7,0,0,i); break;
+		}
+	}
+
+	return insn;
+}
+
+#define IN(inst, args...) \
+({	const int argv[] = { args }; \
+	const int argc = sizeof(argv) / sizeof(argv[0]); \
+	sparc_assemble(inst, argc, argv); \
+})
+
+#if 0
+static void pgreg(int reg_num, int arg_index, int flt)
+{
+	if (!flt) {
+		const char *fmt[] = { "%g", "%o", "%l", "%i" };
+
+		Com_Printf("%s%s%d",
+			   (arg_index ? ", " : ""),
+			   fmt[reg_num >> 3], reg_num & 7);
+	} else
+		Com_Printf("%s%%f%d", (arg_index ? ", " : ""), reg_num);
+}
+
+static void pimm(unsigned int val, int bits, int shift, int sgned, int arg_index)
+	
+{
+	val >>= shift;
+	val &= ((1 << bits) - 1);
+	if (sgned) {
+		int sval = val << (32 - bits);
+		sval >>= (32 - bits);
+		Com_Printf("%s%d",
+			   (arg_index ? ", " : ""), sval);
+	} else
+		Com_Printf("%s0x%08x",
+			   (arg_index ? ", " : ""), val);
+}
+
+static void sparc_disassemble(unsigned int insn)
+{
+	int op_idx;
+
+	for (op_idx = 0; op_idx < SPARC_NUM_OPCODES; op_idx++) {
+		const struct sparc_opcode *op = &sparc_opcodes[op_idx];
+		int i, flt, rd_flt;
+
+		if ((insn & op->mask) != op->opcode)
+			continue;
+
+		flt = (op->name[0] == 'f');
+		rd_flt = flt || (op->name[2] == 'f');
+
+		Com_Printf("ASM: %7s\t", op->name);
+		for (i = 0; op->args[i] != ARG_NONE; i++) {
+			switch (op->args[i]) {
+			case ARG_RS1: pgreg((insn >> 14) & 0x1f, i, flt); break;
+			case ARG_RS2: pgreg((insn >> 0) & 0x1f, i, flt); break;
+			case ARG_RD:  pgreg((insn >> 25) & 0x1f, i, rd_flt); break;
+			case ARG_SIMM13: pimm(insn, 13, 0, 1, i); break;
+			case ARG_DISP30: pimm(insn, 30, 0, 0, i); break;
+			case ARG_IMM22: pimm(insn, 22, 0, 0, i); break;
+			case ARG_DISP22: pimm(insn, 22, 0, 0, i); break;
+			case ARG_SWTRAP: pimm(insn, 7, 0, 0, i); break;
+			}
+		}
+		Com_Printf("\n");
+		return;
+	}
+}
+#endif
+
+/*
+ * opcode information table:
+ * - length of immediate value
+ * - returned register type
+ * - required register(s) type
+ */
+#define opImm0	0x0000 /* no immediate */
+#define opImm1	0x0001 /* 1 byte immadiate value after opcode */
+#define opImm4	0x0002 /* 4 bytes immediate value after opcode */
+
+#define opRet0	0x0000 /* returns nothing */
+#define opRetI	0x0004 /* returns integer */
+#define opRetF	0x0008 /* returns float */
+#define opRetIF	(opRetI | opRetF) /* returns integer or float */
+
+#define opArg0	0x0000 /* requires nothing */
+#define opArgI	0x0010 /* requires integer(s) */
+#define opArgF	0x0020 /* requires float(s) */
+#define opArgIF	(opArgI | opArgF) /* requires integer or float */
+
+#define opArg2I	0x0040 /* requires second argument, integer */
+#define opArg2F	0x0080 /* requires second argument, float */
+#define opArg2IF (opArg2I | opArg2F) /* requires second argument, integer or float */
+
+static const unsigned char vm_opInfo[256] =
+{
+	[OP_UNDEF]	= opImm0,
+	[OP_IGNORE]	= opImm0,
+	[OP_BREAK]	= opImm0,
+	[OP_ENTER]	= opImm4,
+			/* OP_LEAVE has to accept floats, they will be converted to ints */
+	[OP_LEAVE]	= opImm4 | opRet0 | opArgIF,
+			/* only STORE4 and POP use values from OP_CALL,
+			 * no need to convert floats back */
+	[OP_CALL]	= opImm0 | opRetI | opArgI,
+	[OP_PUSH]	= opImm0 | opRetIF,
+	[OP_POP]	= opImm0 | opRet0 | opArgIF,
+	[OP_CONST]	= opImm4 | opRetIF,
+	[OP_LOCAL]	= opImm4 | opRetI,
+	[OP_JUMP]	= opImm0 | opRet0 | opArgI,
+
+	[OP_EQ]		= opImm4 | opRet0 | opArgI | opArg2I,
+	[OP_NE]		= opImm4 | opRet0 | opArgI | opArg2I,
+	[OP_LTI]	= opImm4 | opRet0 | opArgI | opArg2I,
+	[OP_LEI]	= opImm4 | opRet0 | opArgI | opArg2I,
+	[OP_GTI]	= opImm4 | opRet0 | opArgI | opArg2I,
+	[OP_GEI]	= opImm4 | opRet0 | opArgI | opArg2I,
+	[OP_LTU]	= opImm4 | opRet0 | opArgI | opArg2I,
+	[OP_LEU]	= opImm4 | opRet0 | opArgI | opArg2I,
+	[OP_GTU]	= opImm4 | opRet0 | opArgI | opArg2I,
+	[OP_GEU]	= opImm4 | opRet0 | opArgI | opArg2I,
+	[OP_EQF]	= opImm4 | opRet0 | opArgF | opArg2F,
+	[OP_NEF]	= opImm4 | opRet0 | opArgF | opArg2F,
+	[OP_LTF]	= opImm4 | opRet0 | opArgF | opArg2F,
+	[OP_LEF]	= opImm4 | opRet0 | opArgF | opArg2F,
+	[OP_GTF]	= opImm4 | opRet0 | opArgF | opArg2F,
+	[OP_GEF]	= opImm4 | opRet0 | opArgF | opArg2F,
+
+	[OP_LOAD1]	= opImm0 | opRetI | opArgI,
+	[OP_LOAD2]	= opImm0 | opRetI | opArgI,
+	[OP_LOAD4]	= opImm0 | opRetIF| opArgI,
+	[OP_STORE1]	= opImm0 | opRet0 | opArgI | opArg2I,
+	[OP_STORE2]	= opImm0 | opRet0 | opArgI | opArg2I,
+	[OP_STORE4]	= opImm0 | opRet0 | opArgIF| opArg2I,
+	[OP_ARG]	= opImm1 | opRet0 | opArgIF,
+	[OP_BLOCK_COPY]	= opImm4 | opRet0 | opArgI | opArg2I,
+
+	[OP_SEX8]	= opImm0 | opRetI | opArgI,
+	[OP_SEX16]	= opImm0 | opRetI | opArgI,
+	[OP_NEGI]	= opImm0 | opRetI | opArgI,
+	[OP_ADD]	= opImm0 | opRetI | opArgI | opArg2I,
+	[OP_SUB]	= opImm0 | opRetI | opArgI | opArg2I,
+	[OP_DIVI]	= opImm0 | opRetI | opArgI | opArg2I,
+	[OP_DIVU]	= opImm0 | opRetI | opArgI | opArg2I,
+	[OP_MODI]	= opImm0 | opRetI | opArgI | opArg2I,
+	[OP_MODU]	= opImm0 | opRetI | opArgI | opArg2I,
+	[OP_MULI]	= opImm0 | opRetI | opArgI | opArg2I,
+	[OP_MULU]	= opImm0 | opRetI | opArgI | opArg2I,
+	[OP_BAND]	= opImm0 | opRetI | opArgI | opArg2I,
+	[OP_BOR]	= opImm0 | opRetI | opArgI | opArg2I,
+	[OP_BXOR]	= opImm0 | opRetI | opArgI | opArg2I,
+	[OP_BCOM]	= opImm0 | opRetI | opArgI,
+	[OP_LSH]	= opImm0 | opRetI | opArgI | opArg2I,
+	[OP_RSHI]	= opImm0 | opRetI | opArgI | opArg2I,
+	[OP_RSHU]	= opImm0 | opRetI | opArgI | opArg2I,
+	[OP_NEGF]	= opImm0 | opRetF | opArgF,
+	[OP_ADDF]	= opImm0 | opRetF | opArgF | opArg2F,
+	[OP_SUBF]	= opImm0 | opRetF | opArgF | opArg2F,
+	[OP_DIVF]	= opImm0 | opRetF | opArgF | opArg2F,
+	[OP_MULF]	= opImm0 | opRetF | opArgF | opArg2F,
+	[OP_CVIF]	= opImm0 | opRetF | opArgI,
+	[OP_CVFI]	= opImm0 | opRetI | opArgF,
+};
+
+static const char *opnames[256] = {
+	"OP_UNDEF", "OP_IGNORE", "OP_BREAK", "OP_ENTER", "OP_LEAVE", "OP_CALL",
+	"OP_PUSH", "OP_POP", "OP_CONST", "OP_LOCAL", "OP_JUMP",
+	"OP_EQ", "OP_NE", "OP_LTI", "OP_LEI", "OP_GTI", "OP_GEI",
+	"OP_LTU", "OP_LEU", "OP_GTU", "OP_GEU", "OP_EQF", "OP_NEF",
+	"OP_LTF", "OP_LEF", "OP_GTF", "OP_GEF",
+	"OP_LOAD1", "OP_LOAD2", "OP_LOAD4", "OP_STORE1", "OP_STORE2",
+	"OP_STORE4", "OP_ARG", "OP_BLOCK_COPY",
+	"OP_SEX8", "OP_SEX16",
+	"OP_NEGI", "OP_ADD", "OP_SUB", "OP_DIVI", "OP_DIVU",
+	"OP_MODI", "OP_MODU", "OP_MULI", "OP_MULU", "OP_BAND",
+	"OP_BOR", "OP_BXOR", "OP_BCOM", "OP_LSH", "OP_RSHI", "OP_RSHU",
+	"OP_NEGF", "OP_ADDF", "OP_SUBF", "OP_DIVF", "OP_MULF",
+	"OP_CVIF", "OP_CVFI",
+};
+
+static void VM_Destroy_Compiled(vm_t *vm)
+{
+	if (vm->codeBase) {
+		if (munmap(vm->codeBase, vm->codeLength))
+			Com_Printf(S_COLOR_RED "Memory unmap failed, possible memory leak\n");
+	}
+	vm->codeBase = NULL;
+}
+
+typedef struct VM_Data {
+	unsigned int dataLength;
+	unsigned int codeLength;
+	unsigned int *CallThunk;
+	int (*AsmCall)(int, int);
+	void (*BlockCopy)(unsigned int, unsigned int, unsigned int);
+	unsigned int *iPointers;
+	unsigned int data[0];
+} vm_data_t;
+
+#ifdef offsetof
+# define VM_Data_Offset(field)		offsetof(vm_data_t, field)
+#else
+# define OFFSET(structName, field) \
+	((void *)&(((structName *)NULL)->field) - NULL)
+# define VM_Data_Offset(field)		OFFSET(vm_data_t, field)
+#endif
+
+struct src_insn {
+	unsigned char		op;
+	unsigned int		i_count;
+
+	union {
+		unsigned int	i;
+		signed int	si;
+		signed short	ss[2];
+		unsigned short	us[2];
+		unsigned char	b;
+	} arg;
+
+	unsigned char		dst_reg_flags;
+	unsigned char		src1_reg_flags;
+	unsigned char		src2_reg_flags;
+#define REG_FLAGS_FLOAT		0x1
+
+	struct src_insn		*next;
+};
+
+struct dst_insn;
+struct jump_insn {
+	enum sparc_iname	jump_iname;
+	int			jump_dest_insn;
+	struct dst_insn		*parent;
+	struct jump_insn	*next;
+};
+
+struct dst_insn {
+	struct dst_insn		*next;
+
+	unsigned int		count;
+	unsigned int		i_count;
+
+	struct jump_insn	*jump;
+	unsigned int		length;
+	unsigned int		code[0];
+};
+
+#define HUNK_SIZE		29
+struct data_hunk {
+	struct data_hunk *next;
+	int count;
+	unsigned int data[HUNK_SIZE];
+};
+
+struct func_info {
+	struct src_insn		*first;
+	struct src_insn		*last;
+	int			has_call;
+	int			need_float_tmp;
+
+	struct src_insn		*cached_const;
+
+	int			stack_space;
+	int			gpr_pos;
+#define rFIRST(fp)		((fp)->gpr_pos - 1)
+#define rSECOND(fp)		((fp)->gpr_pos - 2)
+#define POP_GPR(fp)		((fp)->gpr_pos--)
+#define PUSH_GPR(fp)		((fp)->gpr_pos++)
+
+	int			fpr_pos;
+#define fFIRST(fp)		((fp)->fpr_pos - 1)
+#define fSECOND(fp)		((fp)->fpr_pos - 2)
+#define POP_FPR(fp)		((fp)->fpr_pos--)
+#define PUSH_FPR(fp)		((fp)->fpr_pos++)
+
+#define INSN_BUF_SIZE		50
+	unsigned int		insn_buf[INSN_BUF_SIZE];
+	int			insn_index;
+
+	int			saved_icount;
+	int			force_emit;
+
+	struct jump_insn	*jump_first;
+	struct jump_insn	*jump_last;
+
+	struct dst_insn		*dst_first;
+	struct dst_insn		*dst_last;
+	int			dst_count;
+
+	struct dst_insn		**dst_by_i_count;
+
+	struct data_hunk	*data_first;
+	int			data_num;
+};
+
+#define THUNK_ICOUNT		-1
+
+static unsigned int sparc_push_data(struct func_info * const fp, unsigned int val)
+{
+	struct data_hunk *last, *dp = fp->data_first;
+	int off = 0;
+
+	last = NULL;
+	while (dp) {
+		int i;
+
+		for (i = 0; i < dp->count; i++) {
+			if (dp->data[i] == val) {
+				off += i;
+				return VM_Data_Offset(data[off]);
+			}
+		}
+		off += dp->count;
+		last = dp;
+		dp = dp->next;
+	}
+
+	dp = last;
+	if (!dp || dp->count >= HUNK_SIZE) {
+		struct data_hunk *new = Z_Malloc(sizeof(*new));
+		if (!dp)
+			fp->data_first = new;
+		else
+			dp->next = new;
+		dp = new;
+		dp->count = 0;
+		dp->next = NULL;
+	}
+	dp->data[dp->count++] = val;
+	fp->data_num = off + 1;
+	return VM_Data_Offset(data[off]);
+}
+
+static void dst_insn_insert_tail(struct func_info * const fp,
+				 struct dst_insn *dp)
+{
+	if (!fp->dst_first) {
+		fp->dst_first = fp->dst_last = dp;
+	} else {
+		fp->dst_last->next = dp;
+		fp->dst_last = dp;
+	}
+}
+
+static void jump_insn_insert_tail(struct func_info * const fp,
+				  struct jump_insn *jp)
+{
+	if (!fp->jump_first) {
+		fp->jump_first = fp->jump_last = jp;
+	} else {
+		fp->jump_last->next = jp;
+		fp->jump_last = jp;
+	}
+}
+
+static struct dst_insn *dst_new(struct func_info * const fp, unsigned int length,
+				struct jump_insn *jp, int insns_size)
+{
+	struct dst_insn *dp = Z_Malloc(sizeof(struct dst_insn) + insns_size);
+
+	dp->length = length;
+	dp->jump = jp;
+	dp->count = fp->dst_count++;
+	dp->i_count = fp->saved_icount;
+	dp->next = NULL;
+	if (fp->saved_icount != THUNK_ICOUNT)
+		fp->dst_by_i_count[fp->saved_icount] = dp;
+
+	return dp;
+}
+
+static void dst_insn_append(struct func_info * const fp)
+{
+	int insns_size = (sizeof(unsigned int) * fp->insn_index);
+	struct dst_insn *dp;
+
+	dp = dst_new(fp, fp->insn_index, NULL, insns_size);
+	if (insns_size)
+		memcpy(&dp->code[0], fp->insn_buf, insns_size);
+	dst_insn_insert_tail(fp, dp);
+
+	fp->insn_index = 0;
+}
+
+static void jump_insn_append(struct func_info * const fp, enum sparc_iname iname, int dest)
+{
+	struct jump_insn *jp = Z_Malloc(sizeof(*jp));
+	struct dst_insn *dp;
+
+	dp = dst_new(fp, 2, jp, 0);
+
+	jp->jump_iname = iname;
+	jp->jump_dest_insn = dest;
+	jp->parent = dp;
+	jp->next = NULL;
+
+	jump_insn_insert_tail(fp, jp);
+	dst_insn_insert_tail(fp, dp);
+}
+
+static void start_emit(struct func_info * const fp, int i_count)
+{
+	fp->saved_icount = i_count;
+	fp->insn_index = 0;
+	fp->force_emit = 0;
+}
+
+static void __do_emit_one(struct func_info * const fp, unsigned int insn)
+{
+	fp->insn_buf[fp->insn_index++] = insn;
+}
+
+#define in(inst, args...) __do_emit_one(fp,  IN(inst, args))
+
+static void end_emit(struct func_info * const fp)
+{
+	if (fp->insn_index || fp->force_emit)
+		dst_insn_append(fp);
+}
+
+static void emit_jump(struct func_info * const fp, enum sparc_iname iname, int dest)
+{
+	end_emit(fp);
+	jump_insn_append(fp, iname, dest);
+}
+
+static void analyze_function(struct func_info * const fp)
+{
+	struct src_insn *value_provider[20] = { NULL };
+	struct src_insn *sp = fp->first;
+	int opstack_depth = 0;
+
+	while ((sp = sp->next) != NULL) {
+		unsigned char opi, op = sp->op;
+
+		opi = vm_opInfo[op];
+		if (opi & opArgIF) {
+			struct src_insn *vp = value_provider[--opstack_depth];
+			unsigned char vpopi = vm_opInfo[vp->op];
+
+			if ((opi & opArgI) && (vpopi & opRetI)) {
+				/* src1 and dst are integers */
+			} else if ((opi & opArgF) && (vpopi & opRetF)) {
+				/* src1 and dst are floats */
+				vp->dst_reg_flags |= REG_FLAGS_FLOAT;
+				sp->src1_reg_flags = REG_FLAGS_FLOAT;
+			} else {
+				/* illegal combination */
+				DIE("unrecognized instruction combination");
+			}
+		}
+		if (opi & opArg2IF) {
+			struct src_insn *vp = value_provider[--opstack_depth];
+			unsigned char vpopi = vm_opInfo[vp->op];
+
+			if ((opi & opArg2I) && (vpopi & opRetI)) {
+				/* src2 and dst are integers */
+			} else if ( (opi & opArg2F) && (vpopi & opRetF) ) {
+				/* src2 and dst are floats */
+				vp->dst_reg_flags |= REG_FLAGS_FLOAT;
+				sp->src2_reg_flags = REG_FLAGS_FLOAT;
+			} else {
+				/* illegal combination */
+				DIE("unrecognized instruction combination");
+			}
+		}
+		if (opi & opRetIF) {
+			value_provider[opstack_depth] = sp;
+			opstack_depth++;
+		}
+	}
+}
+
+static int asmcall(int call, int pstack)
+{
+	vm_t *savedVM = currentVM;
+	int i, ret;
+
+	currentVM->programStack = pstack - 4;
+	if (sizeof(intptr_t) == sizeof(int)) {
+		intptr_t *argPosition = (intptr_t *)((byte *)currentVM->dataBase + pstack + 4);
+		argPosition[0] = -1 - call;
+		ret = currentVM->systemCall(argPosition);
+	} else {
+		intptr_t args[11];
+
+		args[0] = -1 - call;
+		int *argPosition = (int *)((byte *)currentVM->dataBase + pstack + 4);
+		for( i = 1; i < 11; i++ )
+			args[i] = argPosition[i];
+
+		ret = currentVM->systemCall(args);
+	}
+
+	currentVM = savedVM;
+
+	return ret;
+}
+
+static void blockcopy(unsigned int dest, unsigned int src, unsigned int count)
+{
+	unsigned int dataMask = currentVM->dataMask;
+
+	if ((dest & dataMask) != dest ||
+	    (src & dataMask) != src ||
+	    ((dest+count) & dataMask) != dest + count ||
+	    ((src+count) & dataMask) != src + count) {
+		DIE("OP_BLOCK_COPY out of range!");
+	}
+
+	memcpy(currentVM->dataBase+dest, currentVM->dataBase+src, count);
+}
+
+static void do_emit_const(struct func_info * const fp, struct src_insn *sp)
+{
+	start_emit(fp, sp->i_count);
+	if (sp->dst_reg_flags & REG_FLAGS_FLOAT) {
+		in(LDFI, rVMDATA, sparc_push_data(fp, sp->arg.i), fFIRST(fp));
+	} else {
+		if ((sp->arg.i & ~0x3ff) == 0) {
+			in(ORI, G0, sp->arg.i & 0x3ff, rFIRST(fp));
+		} else if ((sp->arg.i & 0x3ff) == 0) {
+			in(SETHI, sp->arg.i >> 10, rFIRST(fp));
+		} else {
+			in(SETHI, sp->arg.i >> 10, rFIRST(fp));
+			in(ORI, rFIRST(fp), sp->arg.i & 0x3ff, rFIRST(fp));
+		}
+	}
+	end_emit(fp);
+}
+
+#define MAYBE_EMIT_CONST(fp)	\
+do {	if ((fp)->cached_const) {	       \
+		int saved_i_count = (fp)->saved_icount; \
+		do_emit_const(fp, (fp)->cached_const); \
+		(fp)->saved_icount = saved_i_count; \
+	} \
+} while (0)
+
+#define EMIT_FALSE_CONST(fp)					\
+do {	int saved_i_count = (fp)->saved_icount;			\
+	(fp)->saved_icount = (fp)->cached_const->i_count;	\
+	dst_insn_append(fp);					\
+	(fp)->saved_icount = saved_i_count;			\
+} while (0)
+
+static void compile_one_insn(struct func_info * const fp, struct src_insn *sp)
+{
+	start_emit(fp, sp->i_count);
+
+	switch (sp->op) {
+	default:
+		Com_Printf("VM: Unhandled opcode 0x%02x[%s]\n",
+			   sp->op,
+			   opnames[sp->op] ? opnames[sp->op] : "UNKNOWN");
+		DIE("Unsupported opcode");
+		break;
+
+	case OP_ENTER: {
+		int stack = SL(64, 128);
+
+		if (fp->need_float_tmp)
+			stack += 16;
+
+		in(SAVEI, O6, -stack, O6);
+		if (!SIMM13_P(sp->arg.si)) {
+			in(SETHI, sp->arg.i >> 10, rTMP);
+			in(ORI, rTMP, sp->arg.i & 0x3ff, rTMP);
+			in(SUB, rPSTACK, rTMP, rPSTACK);
+		} else
+			in(SUBI, rPSTACK, sp->arg.si, rPSTACK);
+		break;
+	}
+	case OP_LEAVE:
+		if (fp->cached_const && SIMM13_P(fp->cached_const->arg.si)) {
+			EMIT_FALSE_CONST(fp);
+			if (fp->cached_const->src1_reg_flags & REG_FLAGS_FLOAT)
+				DIE("constant float in OP_LEAVE");
+
+			if (!SIMM13_P(sp->arg.si)) {
+				in(SETHI, sp->arg.i >> 10, rTMP);
+				in(ORI, rTMP, sp->arg.i & 0x3ff, rTMP);
+				in(ADD, rPSTACK, rTMP, rPSTACK);
+			} else
+				in(ADDI, rPSTACK, sp->arg.si, rPSTACK);
+			in(JMPLI, I7, 8, G0);
+			in(RESTOREI, G0, fp->cached_const->arg.si, O0);
+			POP_GPR(fp);
+		} else {
+			MAYBE_EMIT_CONST(fp);
+			if (!SIMM13_P(sp->arg.si)) {
+				in(SETHI, sp->arg.i >> 10, rTMP);
+				in(ORI, rTMP, sp->arg.i & 0x3ff, rTMP);
+				in(ADD, rPSTACK, rTMP, rPSTACK);
+			} else
+				in(ADDI, rPSTACK, sp->arg.si, rPSTACK);
+			if (sp->src1_reg_flags & REG_FLAGS_FLOAT) {
+				in(STFI, O6, SL(64, 128), fFIRST(fp));
+				in(LDUWI, O6, SL(64, 128), O0);
+				in(JMPLI, I7, 8, G0);
+				in(RESTORE, O0, G0, O0);
+				POP_FPR(fp);
+			} else {
+				in(JMPLI, I7, 8, G0);
+				in(RESTORE, rFIRST(fp), G0, O0);
+				POP_GPR(fp);
+			}
+		}
+		assert(fp->gpr_pos == L0);
+		assert(fp->fpr_pos == F0);
+		break;
+	case OP_JUMP:
+		if (fp->cached_const) {
+			EMIT_FALSE_CONST(fp);
+			emit_jump(fp, BA, fp->cached_const->arg.i);
+		} else {
+			MAYBE_EMIT_CONST(fp);
+			in(LDLI, rVMDATA, VM_Data_Offset(iPointers), rTMP);
+			in(SLLI, rFIRST(fp), 2, rFIRST(fp));
+			in(LDL, rTMP, rFIRST(fp), rTMP);
+			in(JMPL, rTMP, G0, G0);
+			in(NOP);
+		}
+		POP_GPR(fp);
+		break;
+	case OP_CALL:
+		if (fp->cached_const) {
+			EMIT_FALSE_CONST(fp);
+			if (fp->cached_const->arg.si >= 0) {
+				emit_jump(fp, CALL, fp->cached_const->arg.i);
+			} else {
+				in(LDLI, rVMDATA, VM_Data_Offset(CallThunk), rTMP);
+				in(LDLI, rVMDATA, VM_Data_Offset(AsmCall), O3);
+				in(ORI, G0, fp->cached_const->arg.si, O0);
+				in(JMPL, rTMP, G0, O7);
+				in(OR, G0, rPSTACK, O1);
+			}
+			in(OR, G0, O0, rFIRST(fp));
+		} else {
+			MAYBE_EMIT_CONST(fp);
+			in(SUBCCI, rFIRST(fp), 0, G0);
+			in(BL, +4*7);
+			in(NOP);
+
+			/* normal call */
+			in(LDLI, rVMDATA, VM_Data_Offset(iPointers), O5);
+			in(SLLI, rFIRST(fp), 2, rFIRST(fp));
+			in(LDL, O5, rFIRST(fp), rTMP);
+			in(BA, +4*4);
+			in(NOP);
+
+			/* syscall */
+			in(LDLI, rVMDATA, VM_Data_Offset(CallThunk), rTMP);
+			in(LDLI, rVMDATA, VM_Data_Offset(AsmCall), O3);
+
+			in(OR, G0, rFIRST(fp), O0);
+			in(JMPL, rTMP, G0, O7);
+			in(OR, G0, rPSTACK, O1);
+
+			/* return value */
+			in(OR, G0, O0, rFIRST(fp));
+		}
+		break;
+	case OP_BLOCK_COPY:
+		MAYBE_EMIT_CONST(fp);
+		in(LDLI, rVMDATA, VM_Data_Offset(CallThunk), rTMP);
+		in(LDLI, rVMDATA, VM_Data_Offset(BlockCopy), O3);
+		in(OR, G0, rSECOND(fp), O0);
+		in(OR, G0, rFIRST(fp), O1);
+		if ((sp->arg.i & ~0x3ff) == 0) {
+			in(ORI, G0, sp->arg.i & 0x3ff, O2);
+		} else if ((sp->arg.i & 0x3ff) == 0) {
+			in(SETHI, sp->arg.i >> 10, O2);
+		} else {
+			in(SETHI, sp->arg.i >> 10, O2);
+			in(ORI, O2, sp->arg.i & 0x3ff, O2);
+		}
+		in(JMPL, rTMP, G0, O7);
+		in(NOP);
+		POP_GPR(fp);
+		POP_GPR(fp);
+		break;
+
+	case OP_PUSH:
+		MAYBE_EMIT_CONST(fp);
+		if (sp->dst_reg_flags & REG_FLAGS_FLOAT)
+			PUSH_FPR(fp);
+		else
+			PUSH_GPR(fp);
+		fp->force_emit = 1;
+		break;
+	case OP_POP:
+		MAYBE_EMIT_CONST(fp);
+		if (sp->src1_reg_flags & REG_FLAGS_FLOAT)
+			POP_FPR(fp);
+		else
+			POP_GPR(fp);
+		fp->force_emit = 1;
+		break;
+	case OP_ARG:
+		MAYBE_EMIT_CONST(fp);
+		in(ADDI, rPSTACK, sp->arg.b, rTMP);
+		if (sp->src1_reg_flags & REG_FLAGS_FLOAT) {
+			in(STF, rDATABASE, rTMP, fFIRST(fp));
+			POP_FPR(fp);
+		} else {
+			in(STW, rDATABASE, rTMP, rFIRST(fp));
+			POP_GPR(fp);
+		}
+		break;
+	case OP_IGNORE:
+		MAYBE_EMIT_CONST(fp);
+		in(NOP);
+		break;
+	case OP_BREAK:
+		MAYBE_EMIT_CONST(fp);
+		in(TA, 0x5);
+		break;
+	case OP_LOCAL:
+		MAYBE_EMIT_CONST(fp);
+		PUSH_GPR(fp);
+		if (!SIMM13_P(sp->arg.i)) {
+			in(SETHI, sp->arg.i >> 10, rTMP);
+			in(ORI, rTMP, sp->arg.i & 0x3ff, rTMP);
+			in(ADD, rPSTACK, rTMP, rFIRST(fp));
+		} else
+			in(ADDI, rPSTACK, sp->arg.i, rFIRST(fp));
+		break;
+	case OP_CONST:
+		MAYBE_EMIT_CONST(fp);
+		break;
+	case OP_LOAD4:
+		MAYBE_EMIT_CONST(fp);
+		in(AND, rFIRST(fp), rDATAMASK, rFIRST(fp));
+		if (sp->dst_reg_flags & REG_FLAGS_FLOAT) {
+			PUSH_FPR(fp);
+			in(LDF, rFIRST(fp), rDATABASE, fFIRST(fp));
+			POP_GPR(fp);
+		} else {
+			in(LDUW, rFIRST(fp), rDATABASE, rFIRST(fp));
+		}
+		break;
+	case OP_LOAD2:
+		MAYBE_EMIT_CONST(fp);
+		in(AND, rFIRST(fp), rDATAMASK, rFIRST(fp));
+		in(LDUH, rFIRST(fp), rDATABASE, rFIRST(fp));
+		break;
+	case OP_LOAD1:
+		MAYBE_EMIT_CONST(fp);
+		in(AND, rFIRST(fp), rDATAMASK, rFIRST(fp));
+		in(LDUB, rFIRST(fp), rDATABASE, rFIRST(fp));
+		break;
+	case OP_STORE4:
+		MAYBE_EMIT_CONST(fp);
+		if (sp->src1_reg_flags & REG_FLAGS_FLOAT) {
+			in(AND, rFIRST(fp), rDATAMASK, rFIRST(fp));
+			in(STF, rFIRST(fp), rDATABASE, fFIRST(fp));
+			POP_FPR(fp);
+		} else {
+			in(AND, rSECOND(fp), rDATAMASK, rSECOND(fp));
+			in(STW, rSECOND(fp), rDATABASE, rFIRST(fp));
+			POP_GPR(fp);
+		}
+		POP_GPR(fp);
+		break;
+	case OP_STORE2:
+		MAYBE_EMIT_CONST(fp);
+		in(AND, rSECOND(fp), rDATAMASK, rSECOND(fp));
+		in(STH, rSECOND(fp), rDATABASE, rFIRST(fp));
+		POP_GPR(fp);
+		POP_GPR(fp);
+		break;
+	case OP_STORE1:
+		MAYBE_EMIT_CONST(fp);
+		in(AND, rSECOND(fp), rDATAMASK, rSECOND(fp));
+		in(STB, rSECOND(fp), rDATABASE, rFIRST(fp));
+		POP_GPR(fp);
+		POP_GPR(fp);
+		break;
+	case OP_EQ:
+	case OP_NE:
+	case OP_LTI:
+	case OP_GEI:
+	case OP_GTI:
+	case OP_LEI:
+	case OP_LTU:
+	case OP_GEU:
+	case OP_GTU:
+	case OP_LEU: {
+		enum sparc_iname iname = BA;
+
+		if (fp->cached_const && SIMM13_P(fp->cached_const->arg.si)) {
+			EMIT_FALSE_CONST(fp);
+			in(SUBCCI, rSECOND(fp), fp->cached_const->arg.si, G0);
+		} else {
+			MAYBE_EMIT_CONST(fp);
+			in(SUBCC, rSECOND(fp), rFIRST(fp), G0);
+		}
+		switch(sp->op) {
+		case OP_EQ: iname = BE; break;
+		case OP_NE: iname = BNE; break;
+		case OP_LTI: iname = BL; break;
+		case OP_GEI: iname = BGE; break;
+		case OP_GTI: iname = BG; break;
+		case OP_LEI: iname = BLE; break;
+		case OP_LTU: iname = BCS; break;
+		case OP_GEU: iname = BCC; break;
+		case OP_GTU: iname = BGU; break;
+		case OP_LEU: iname = BLEU; break;
+		}
+		emit_jump(fp, iname, sp->arg.i);
+		POP_GPR(fp);
+		POP_GPR(fp);
+		break;
+	}
+
+	case OP_SEX8:
+		MAYBE_EMIT_CONST(fp);
+		in(SLLI, rFIRST(fp), 24, rFIRST(fp));
+		in(SRAI, rFIRST(fp), 24, rFIRST(fp));
+		break;
+	case OP_SEX16:
+		MAYBE_EMIT_CONST(fp);
+		in(SLLI, rFIRST(fp), 16, rFIRST(fp));
+		in(SRAI, rFIRST(fp), 16, rFIRST(fp));
+		break;
+	case OP_NEGI:
+		MAYBE_EMIT_CONST(fp);
+		in(SUB, G0, rFIRST(fp), rFIRST(fp));
+		break;
+	case OP_ADD:
+		if (fp->cached_const && SIMM13_P(fp->cached_const->arg.si)) {
+			EMIT_FALSE_CONST(fp);
+			in(ADDI, rSECOND(fp), fp->cached_const->arg.si, rSECOND(fp));
+		} else {
+			MAYBE_EMIT_CONST(fp);
+			in(ADD, rSECOND(fp), rFIRST(fp), rSECOND(fp));
+		}
+		POP_GPR(fp);
+		break;
+	case OP_SUB:
+		if (fp->cached_const && SIMM13_P(fp->cached_const->arg.si)) {
+			EMIT_FALSE_CONST(fp);
+			in(SUBI, rSECOND(fp), fp->cached_const->arg.si, rSECOND(fp));
+		} else {
+			MAYBE_EMIT_CONST(fp);
+			in(SUB, rSECOND(fp), rFIRST(fp), rSECOND(fp));
+		}
+		POP_GPR(fp);
+		break;
+	case OP_DIVI:
+		MAYBE_EMIT_CONST(fp);
+		in(SRAI, rSECOND(fp), 31, rTMP);
+		in(WRI, rTMP, 0, Y_REG);
+		in(SDIV, rSECOND(fp), rFIRST(fp), rSECOND(fp));
+		POP_GPR(fp);
+		break;
+	case OP_DIVU:
+		MAYBE_EMIT_CONST(fp);
+		in(WRI, G0, 0, Y_REG);
+		in(UDIV, rSECOND(fp), rFIRST(fp), rSECOND(fp));
+		POP_GPR(fp);
+		break;
+	case OP_MODI:
+		MAYBE_EMIT_CONST(fp);
+		in(SRAI, rSECOND(fp), 31, rTMP);
+		in(WRI, rTMP, 0, Y_REG);
+		in(SDIV, rSECOND(fp), rFIRST(fp), rTMP);
+		in(SMUL, rTMP, rFIRST(fp), rTMP);
+		in(SUB, rSECOND(fp), rTMP, rSECOND(fp));
+		POP_GPR(fp);
+		break;
+	case OP_MODU:
+		MAYBE_EMIT_CONST(fp);
+		in(WRI, G0, 0, Y_REG);
+		in(UDIV, rSECOND(fp), rFIRST(fp), rTMP);
+		in(SMUL, rTMP, rFIRST(fp), rTMP);
+		in(SUB, rSECOND(fp), rTMP, rSECOND(fp));
+		POP_GPR(fp);
+		break;
+	case OP_MULI:
+		MAYBE_EMIT_CONST(fp);
+		in(SMUL, rSECOND(fp), rFIRST(fp), rSECOND(fp));
+		POP_GPR(fp);
+		break;
+	case OP_MULU:
+		MAYBE_EMIT_CONST(fp);
+		in(UMUL, rSECOND(fp), rFIRST(fp), rSECOND(fp));
+		POP_GPR(fp);
+		break;
+	case OP_BAND:
+		MAYBE_EMIT_CONST(fp);
+		in(AND, rSECOND(fp), rFIRST(fp), rSECOND(fp));
+		POP_GPR(fp);
+		break;
+	case OP_BOR:
+		MAYBE_EMIT_CONST(fp);
+		in(OR, rSECOND(fp), rFIRST(fp), rSECOND(fp));
+		POP_GPR(fp);
+		break;
+	case OP_BXOR:
+		MAYBE_EMIT_CONST(fp);
+		in(XOR, rSECOND(fp), rFIRST(fp), rSECOND(fp));
+		POP_GPR(fp);
+		break;
+	case OP_BCOM:
+		MAYBE_EMIT_CONST(fp);
+		in(XNOR, rFIRST(fp), G0, rFIRST(fp));
+		break;
+	case OP_LSH:
+		if (fp->cached_const) {
+			EMIT_FALSE_CONST(fp);
+			in(SLLI, rSECOND(fp), fp->cached_const->arg.si, rSECOND(fp));
+		} else {
+			MAYBE_EMIT_CONST(fp);
+			in(SLL, rSECOND(fp), rFIRST(fp), rSECOND(fp));
+		}
+		POP_GPR(fp);
+		break;
+	case OP_RSHI:
+		if (fp->cached_const) {
+			EMIT_FALSE_CONST(fp);
+			in(SRAI, rSECOND(fp), fp->cached_const->arg.si, rSECOND(fp));
+		} else {
+			MAYBE_EMIT_CONST(fp);
+			in(SRA, rSECOND(fp), rFIRST(fp), rSECOND(fp));
+		}
+		POP_GPR(fp);
+		break;
+	case OP_RSHU:
+		if (fp->cached_const) {
+			EMIT_FALSE_CONST(fp);
+			in(SRLI, rSECOND(fp), fp->cached_const->arg.si, rSECOND(fp));
+		} else {
+			MAYBE_EMIT_CONST(fp);
+			in(SRL, rSECOND(fp), rFIRST(fp), rSECOND(fp));
+		}
+		POP_GPR(fp);
+		break;
+
+	case OP_NEGF:
+		MAYBE_EMIT_CONST(fp);
+		in(FNEG, fFIRST(fp), fFIRST(fp));
+		break;
+	case OP_ADDF:
+		MAYBE_EMIT_CONST(fp);
+		in(FADD, fSECOND(fp), fFIRST(fp), fSECOND(fp));
+		POP_FPR(fp);
+		break;
+	case OP_SUBF:
+		MAYBE_EMIT_CONST(fp);
+		in(FSUB, fSECOND(fp), fFIRST(fp), fSECOND(fp));
+		POP_FPR(fp);
+		break;
+	case OP_DIVF:
+		MAYBE_EMIT_CONST(fp);
+		in(FDIV, fSECOND(fp), fFIRST(fp), fSECOND(fp));
+		POP_FPR(fp);
+		break;
+	case OP_MULF:
+		MAYBE_EMIT_CONST(fp);
+		in(FMUL, fSECOND(fp), fFIRST(fp), fSECOND(fp));
+		POP_FPR(fp);
+		break;
+
+	case OP_EQF:
+	case OP_NEF:
+	case OP_LTF:
+	case OP_GEF:
+	case OP_GTF:
+	case OP_LEF: {
+		enum sparc_iname iname = FBE;
+
+		MAYBE_EMIT_CONST(fp);
+		in(FCMP, fSECOND(fp), fFIRST(fp));
+		switch(sp->op) {
+		case OP_EQF: iname = FBE; break;
+		case OP_NEF: iname = FBNE; break;
+		case OP_LTF: iname = FBL; break;
+		case OP_GEF: iname = FBGE; break;
+		case OP_GTF: iname = FBG; break;
+		case OP_LEF: iname = FBLE; break;
+		}
+		emit_jump(fp, iname, sp->arg.i);
+		POP_FPR(fp);
+		POP_FPR(fp);
+		break;
+	}
+	case OP_CVIF:
+		MAYBE_EMIT_CONST(fp);
+		PUSH_FPR(fp);
+		in(STWI, O6, SL(64, 128), rFIRST(fp));
+		in(LDFI, O6, SL(64, 128), fFIRST(fp));
+		in(FITOS, fFIRST(fp), fFIRST(fp));
+		POP_GPR(fp);
+		break;
+	case OP_CVFI:
+		MAYBE_EMIT_CONST(fp);
+		PUSH_GPR(fp);
+		in(FSTOI, fFIRST(fp), fFIRST(fp));
+		in(STFI, O6, SL(64, 128), fFIRST(fp));
+		in(LDUWI, O6, SL(64, 128), rFIRST(fp));
+		POP_FPR(fp);
+		break;
+	}
+	if (sp->op != OP_CONST) {
+		fp->cached_const = NULL;
+		end_emit(fp);
+	} else {
+		fp->cached_const = sp;
+		if (sp->dst_reg_flags & REG_FLAGS_FLOAT) {
+			PUSH_FPR(fp);
+		} else {
+			PUSH_GPR(fp);
+		}
+	}
+	end_emit(fp);
+}
+
+static void free_source_insns(struct func_info * const fp)
+{
+	struct src_insn *sp = fp->first->next;
+
+	while (sp) {
+		struct src_insn *next = sp->next;
+		Z_Free(sp);
+		sp = next;
+	}
+}
+
+static void compile_function(struct func_info * const fp)
+{
+	struct src_insn *sp;
+
+	analyze_function(fp);
+
+	fp->gpr_pos = L0;
+	fp->fpr_pos = F0;
+	fp->insn_index = 0;
+
+	fp->stack_space = SL(64, 128);
+	fp->cached_const = NULL;
+
+	sp = fp->first;
+	while ((sp = sp->next) != NULL)
+		compile_one_insn(fp, sp);
+
+	free_source_insns(fp);
+}
+
+/* We have two thunks for sparc.  The first is for the entry into
+ * the VM, where setup the fixed global registers.  The second is
+ * for calling out to C code from the VM, where we need to preserve
+ * those fixed globals across the call.
+ */
+static void emit_vm_thunk(struct func_info * const fp)
+{
+	/* int vm_thunk(void *vmdata, int programstack, void *database, int datamask) */
+	start_emit(fp, THUNK_ICOUNT);
+
+	in(OR, G0, O0, rVMDATA);
+	in(OR, G0, O1, rPSTACK);
+	in(OR, G0, O2, rDATABASE);
+	in(BA, +4*17);
+	in(OR, G0, O3, rDATAMASK);
+
+	/* int call_thunk(int arg0, int arg1, int arg2, int (*func)(int int int)) */
+#define CALL_THUNK_INSN_OFFSET		5
+	in(SAVEI, O6, -SL(64, 128), O6);
+
+	in(OR, G0, rVMDATA, L0);
+	in(OR, G0, rPSTACK, L1);
+	in(OR, G0, rDATABASE, L2);
+	in(OR, G0, rDATAMASK, L3);
+
+	in(OR, G0, I0, O0);
+	in(OR, G0, I1, O1);
+	in(JMPL, I3, G0, O7);
+	in(OR, G0, I2, O2);
+
+	in(OR, G0, L0, rVMDATA);
+	in(OR, G0, L1, rPSTACK);
+	in(OR, G0, L2, rDATABASE);
+	in(OR, G0, L3, rDATAMASK);
+
+	in(JMPLI, I7, 8, G0);
+	in(RESTORE, O0, G0, O0);
+
+	end_emit(fp);
+}
+
+static void sparc_compute_code(vm_t *vm, struct func_info * const fp)
+{
+	struct dst_insn *dp = fp->dst_first;
+	unsigned int *code_now, *code_begin;
+	unsigned char *data_and_code;
+	unsigned int code_length;
+	int code_insns = 0, off;
+	struct data_hunk *dhp;
+	struct jump_insn *jp;
+	vm_data_t *data;
+
+	while (dp) {
+		code_insns += dp->length;
+		dp = dp->next;
+	}
+
+	code_length = (sizeof(vm_data_t) +
+		       (fp->data_num * sizeof(unsigned int)) +
+		       (code_insns * sizeof(unsigned int)));
+
+	data_and_code = mmap(NULL, code_length, PROT_READ | PROT_WRITE,
+			     MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+	if (!data_and_code)
+		DIE("Not enough memory");
+
+	code_now = code_begin = (unsigned int *)
+		(data_and_code + VM_Data_Offset(data[fp->data_num]));
+
+	dp = fp->dst_first;
+	while (dp) {
+		int i_count = dp->i_count;
+
+		if (i_count != THUNK_ICOUNT) {
+			if (!fp->dst_by_i_count[i_count])
+				fp->dst_by_i_count[i_count] = (void *) code_now;
+		}
+		if (!dp->jump) {
+			memcpy(code_now, &dp->code[0], dp->length * sizeof(unsigned int));
+			code_now += dp->length;
+		} else {
+			int i;
+
+			dp->jump->parent = (void *) code_now;
+
+			for (i = 0; i < dp->length; i++)
+				code_now[i] = SPARC_NOP;
+			code_now += dp->length;
+		}
+
+		dp = dp->next;
+	}
+
+	jp = fp->jump_first;
+	while (jp) {
+		unsigned int *from = (void *) jp->parent;
+		unsigned int *to = (void *) fp->dst_by_i_count[jp->jump_dest_insn];
+		signed int disp = (to - from);
+
+		*from = IN(jp->jump_iname, disp << 2);
+
+		jp = jp->next;
+	}
+
+	vm->codeBase = data_and_code;
+	vm->codeLength = code_length;
+
+	data = (vm_data_t *) data_and_code;
+	data->CallThunk = code_begin + CALL_THUNK_INSN_OFFSET;
+	data->AsmCall = asmcall;
+	data->BlockCopy = blockcopy;
+	data->iPointers = (unsigned int *) vm->instructionPointers;
+	data->dataLength = VM_Data_Offset(data[fp->data_num]);
+	data->codeLength = (code_now - code_begin) * sizeof(unsigned int);
+
+#if 0
+	{
+		unsigned int *insn = code_begin;
+		int i;
+
+		Com_Printf("INSN DUMP\n");
+		for (i = 0; i < data->codeLength / 4; i+= 8) {
+			Com_Printf("\t.word\t0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
+				   insn[i + 0], insn[i + 1],
+				   insn[i + 2], insn[i + 3],
+				   insn[i + 4], insn[i + 5],
+				   insn[i + 6], insn[i + 7]);
+		}
+	}
+#endif
+
+	dhp = fp->data_first;
+	off = 0;
+	while (dhp) {
+		struct data_hunk *next = dhp->next;
+		int i;
+
+		for (i = 0; i < dhp->count; i++)
+			data->data[off + i] = dhp->data[i];
+
+		off += dhp->count;
+
+		Z_Free(dhp);
+
+		dhp = next;
+	}
+	fp->data_first = NULL;
+	fp->data_num = 0;
+
+	dp = fp->dst_first;
+	while (dp) {
+		struct dst_insn *next = dp->next;
+		if (dp->jump)
+			Z_Free(dp->jump);
+		Z_Free(dp);
+		dp = next;
+	}
+	fp->dst_first = fp->dst_last = NULL;
+}
+
+void VM_Compile(vm_t *vm, vmHeader_t *header)
+{
+	struct func_info fi;
+	unsigned char *code;
+	int i_count, pc, i;
+
+	memset(&fi, 0, sizeof(fi));
+
+	fi.first = Z_Malloc(sizeof(struct src_insn));
+	fi.first->next = NULL;
+
+#ifdef __arch64__
+	Z_Free(vm->instructionPointers);
+	vm->instructionPointers = Z_Malloc(header->instructionCount *
+					   sizeof(void *));
+#endif
+
+	fi.dst_by_i_count = (struct dst_insn **) vm->instructionPointers;
+	memset(fi.dst_by_i_count, 0, header->instructionCount * sizeof(void *));
+
+	vm->compiled = qfalse;
+
+	emit_vm_thunk(&fi);
+
+	code = (unsigned char *) header + header->codeOffset;
+	pc = 0;
+
+	for (i_count = 0; i_count < header->instructionCount; i_count++) {
+		unsigned char opi, op = code[pc++];
+		struct src_insn *sp;
+
+		if (op == OP_CALL || op == OP_BLOCK_COPY)
+			fi.has_call = 1;
+		opi = vm_opInfo[op];
+		if (op == OP_CVIF || op == OP_CVFI ||
+		    (op == OP_LEAVE && (opi & opArgF)))
+			fi.need_float_tmp = 1;
+
+		if (op == OP_ENTER) {
+			if (fi.first->next)
+				compile_function(&fi);
+			fi.first->next = NULL;
+			fi.last = fi.first;
+			fi.has_call = fi.need_float_tmp = 0;
+		}
+
+		sp = Z_Malloc(sizeof(*sp));
+		sp->op = op;
+		sp->i_count = i_count;
+		sp->arg.i = 0;
+		sp->next = NULL;
+
+		if (vm_opInfo[op] & opImm4) {
+			union {
+				unsigned char b[4];
+				unsigned int i;
+			} c = { { code[ pc + 3 ], code[ pc + 2 ],
+				  code[ pc + 1 ], code[ pc + 0 ] }, };
+
+			sp->arg.i = c.i;
+			pc += 4;
+		} else if (vm_opInfo[op] & opImm1) {
+			sp->arg.b = code[pc++];
+		}
+
+		fi.last->next = sp;
+		fi.last = sp;
+	}
+	compile_function(&fi);
+
+	Z_Free(fi.first);
+
+	memset(fi.dst_by_i_count, 0, header->instructionCount * sizeof(void *));
+	sparc_compute_code(vm, &fi);
+
+	for (i = 0; i < header->instructionCount; i++) {
+		if (!fi.dst_by_i_count[i]) {
+			Com_Printf(S_COLOR_RED "Pointer %d not initialized !\n", i);
+			DIE("sparc JIT bug");
+		}
+	}
+
+	if (mprotect(vm->codeBase, vm->codeLength, PROT_READ|PROT_EXEC)) {
+		VM_Destroy_Compiled(vm);
+		DIE("mprotect failed");
+	}
+
+	vm->destroy = VM_Destroy_Compiled;
+	vm->compiled = qtrue;
+}
+
+int VM_CallCompiled(vm_t *vm, int *args)
+{
+	vm_data_t *vm_dataAndCode = (void *) vm->codeBase;
+	int programStack = vm->programStack;
+	int stackOnEntry = programStack;
+	byte *image = vm->dataBase;
+	int *argPointer;
+	int retVal;
+
+	currentVM = vm;
+
+	vm->currentlyInterpreting = qtrue;
+
+	programStack -= 48;
+	argPointer = (int *)&image[ programStack + 8 ];
+	memcpy( argPointer, args, 4 * 9 );
+	argPointer[-1] = 0;
+	argPointer[-2] = -1;
+
+	/* call generated code */
+	{
+		int (*entry)(void *, int, void *, int);
+		entry = (void *)(vm->codeBase + vm_dataAndCode->dataLength);
+		retVal = entry(vm->codeBase, programStack, vm->dataBase, vm->dataMask);
+	}
+
+	vm->programStack = stackOnEntry;
+	vm->currentlyInterpreting = qfalse;
+
+	return retVal;
+}
diff -r 11104731f8c9 -r 87f98d895296 src/qcommon/vm_sparc.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/qcommon/vm_sparc.h	Sun Mar 29 01:15:08 2009 +0800
@@ -0,0 +1,78 @@
+#ifndef VM_SPARC_H
+#define VM_SPARC_H
+
+/* integer regs */
+#define G0	0
+#define G1	1
+#define G2	2
+#define G3	3
+#define G4	4
+#define G5	5
+#define G6	6
+#define G7	7
+#define O0	8
+#define O1	9
+#define O2	10
+#define O3	11
+#define O4	12
+#define O5	13
+#define O6	14
+#define O7	15
+#define L0	16
+#define L1	17
+#define L2	18
+#define L3	19
+#define L4	20
+#define L5	21
+#define L6	22
+#define L7	23
+#define I0	24
+#define I1	25
+#define I2	26
+#define I3	27
+#define I4	28
+#define I5	29
+#define I6	30
+#define I7	31
+
+/* float regs */
+#define F0	0
+#define F1	1
+#define F2	2
+#define F3	3
+#define F4	4
+#define F5	5
+#define F6	6
+#define F7	7
+#define F8	8
+#define F9	9
+#define F10	10
+#define F11	11
+#define F12	12
+#define F13	13
+#define F14	14
+#define F15	15
+#define F16	16
+#define F17	17
+#define F18	18
+#define F19	19
+#define F20	20
+#define F21	21
+#define F22	22
+#define F23	23
+#define F24	24
+#define F25	25
+#define F26	26
+#define F27	27
+#define F28	28
+#define F29	29
+#define F30	30
+#define F31	31
+
+/* state registers */
+#define Y_REG		0
+#define CCR_REG		2
+#define ASI_REG		3
+#define FPRS_REG	6
+
+#endif
diff -r 11104731f8c9 -r 87f98d895296 src/renderer/qgl.h
--- a/src/renderer/qgl.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/renderer/qgl.h	Sun Mar 29 01:15:08 2009 +0800
@@ -29,6 +29,9 @@
 
 #include <SDL_opengl.h>
 
+// GL_EXT_draw_range_elements
+extern void (APIENTRYP qglDrawRangeElementsEXT) (GLenum mode, GLsizei count, GLuint start, GLuint end, GLenum type, const GLvoid *indices);
+
 extern void (APIENTRYP qglActiveTextureARB) (GLenum texture);
 extern void (APIENTRYP qglClientActiveTextureARB) (GLenum texture);
 extern void (APIENTRYP qglMultiTexCoord2fARB) (GLenum target, GLfloat s, GLfloat t);
@@ -36,6 +39,148 @@
 extern void (APIENTRYP qglLockArraysEXT) (GLint first, GLsizei count);
 extern void (APIENTRYP qglUnlockArraysEXT) (void);
 
+// GL_ARB_vertex_buffer_object
+extern void (APIENTRYP qglBindBufferARB) (GLenum target, GLuint buffer);
+extern void (APIENTRYP qglDeleteBuffersARB) (GLsizei n, const GLuint *buffers);
+extern void (APIENTRYP qglGenBuffersARB) (GLsizei n, GLuint *buffers);
+extern GLboolean (APIENTRYP qglIsBufferARB) (GLuint buffer);
+extern void (APIENTRYP qglBufferDataARB) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
+extern void (APIENTRYP qglBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
+extern void (APIENTRYP qglGetBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
+extern GLvoid *(APIENTRYP qglMapBufferARB) (GLenum target, GLenum access);
+extern GLboolean (APIENTRYP qglUnmapBufferARB) (GLenum target);
+extern void (APIENTRYP qglGetBufferParameterivARB) (GLenum target, GLenum pname, GLint *params);
+extern void (APIENTRYP qglGetBufferPointervARB) (GLenum target, GLenum pname, GLvoid **params);
+
+// GL_ARB_shader_objects
+extern GLvoid (APIENTRYP qglDeleteObjectARB) (GLhandleARB obj);
+extern GLhandleARB (APIENTRYP qglGetHandleARB) (GLenum pname);
+extern GLvoid (APIENTRYP qglDetachObjectARB) (GLhandleARB containerObj, GLhandleARB attachedObj);
+extern GLhandleARB (APIENTRYP qglCreateShaderObjectARB) (GLenum shaderType);
+extern GLvoid (APIENTRYP qglShaderSourceARB) (GLhandleARB shaderObj, GLsizei count, const GLcharARB **string,
+					      const GLint *length);
+extern GLvoid (APIENTRYP qglCompileShaderARB) (GLhandleARB shaderObj);
+extern GLhandleARB (APIENTRYP qglCreateProgramObjectARB) (void);
+extern GLvoid (APIENTRYP qglAttachObjectARB) (GLhandleARB containerObj, GLhandleARB obj);
+extern GLvoid (APIENTRYP qglLinkProgramARB) (GLhandleARB programObj);
+extern GLvoid (APIENTRYP qglUseProgramObjectARB) (GLhandleARB programObj);
+extern GLvoid (APIENTRYP qglValidateProgramARB) (GLhandleARB programObj);
+extern GLvoid (APIENTRYP qglUniform1fARB) (GLint location, GLfloat v0);
+extern GLvoid (APIENTRYP qglUniform2fARB) (GLint location, GLfloat v0, GLfloat v1);
+extern GLvoid (APIENTRYP qglUniform3fARB) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+extern GLvoid (APIENTRYP qglUniform4fARB) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+extern GLvoid (APIENTRYP qglUniform1iARB) (GLint location, GLint v0);
+extern GLvoid (APIENTRYP qglUniform2iARB) (GLint location, GLint v0, GLint v1);
+extern GLvoid (APIENTRYP qglUniform3iARB) (GLint location, GLint v0, GLint v1, GLint v2);
+extern GLvoid (APIENTRYP qglUniform4iARB) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+extern GLvoid (APIENTRYP qglUniform1fvARB) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniform2fvARB) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniform3fvARB) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniform4fvARB) (GLint location, GLsizei count, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniform1ivARB) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRYP qglUniform2ivARB) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRYP qglUniform3ivARB) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRYP qglUniform4ivARB) (GLint location, GLsizei count, const GLint *value);
+extern GLvoid (APIENTRYP qglUniformMatrix2fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniformMatrix3fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+extern GLvoid (APIENTRYP qglUniformMatrix4fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+extern GLvoid (APIENTRYP qglGetObjectParameterfvARB) (GLhandleARB obj, GLenum pname, GLfloat *params);
+extern GLvoid (APIENTRYP qglGetObjectParameterivARB) (GLhandleARB obj, GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglGetInfoLogARB) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
+extern GLvoid (APIENTRYP qglGetAttachedObjectsARB) (GLhandleARB containerObj, GLsizei maxCount, GLsizei *count,
+						    GLhandleARB *obj);
+extern GLint (APIENTRYP qglGetUniformLocationARB) (GLhandleARB programObj, const GLcharARB *name);
+extern GLvoid (APIENTRYP qglGetActiveUniformARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
+						  GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+extern GLvoid (APIENTRYP qglGetUniformfvARB) (GLhandleARB programObj, GLint location, GLfloat *params);
+extern GLvoid (APIENTRYP qglGetUniformivARB) (GLhandleARB programObj, GLint location, GLint *params);
+extern GLvoid (APIENTRYP qglGetShaderSourceARB) (GLhandleARB obj, GLsizei maxLength, GLsizei *length,
+						 GLcharARB *source);
+
+// GL_ARB_vertex_shader
+extern GLvoid (APIENTRYP qglVertexAttrib1fARB) (GLuint index, GLfloat v0);
+extern GLvoid (APIENTRYP qglVertexAttrib1sARB) (GLuint index, GLshort v0);
+extern GLvoid (APIENTRYP qglVertexAttrib1dARB) (GLuint index, GLdouble v0);
+extern GLvoid (APIENTRYP qglVertexAttrib2fARB) (GLuint index, GLfloat v0, GLfloat v1);
+extern GLvoid (APIENTRYP qglVertexAttrib2sARB) (GLuint index, GLshort v0, GLshort v1);
+extern GLvoid (APIENTRYP qglVertexAttrib2dARB) (GLuint index, GLdouble v0, GLdouble v1);
+extern GLvoid (APIENTRYP qglVertexAttrib3fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2);
+extern GLvoid (APIENTRYP qglVertexAttrib3sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2);
+extern GLvoid (APIENTRYP qglVertexAttrib3dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
+extern GLvoid (APIENTRYP qglVertexAttrib4fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+extern GLvoid (APIENTRYP qglVertexAttrib4sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3);
+extern GLvoid (APIENTRYP qglVertexAttrib4dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
+extern GLvoid (APIENTRYP qglVertexAttrib4NubARB) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+extern GLvoid (APIENTRYP qglVertexAttrib1fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRYP qglVertexAttrib1svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib1dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRYP qglVertexAttrib2fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRYP qglVertexAttrib2svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib2dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRYP qglVertexAttrib3fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRYP qglVertexAttrib3svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib3dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4fvARB) (GLuint index, GLfloat *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4svARB) (GLuint index, GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4dvARB) (GLuint index, GLdouble *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4ivARB) (GLuint index, GLint *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4bvARB) (GLuint index, GLbyte *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4ubvARB) (GLuint index, GLubyte *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4usvARB) (GLuint index, GLushort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4uivARB) (GLuint index, GLuint *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NbvARB) (GLuint index, const GLbyte *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NsvARB) (GLuint index, const GLshort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NivARB) (GLuint index, const GLint *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NubvARB) (GLuint index, const GLubyte *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NusvARB) (GLuint index, const GLushort *v);
+extern GLvoid (APIENTRYP qglVertexAttrib4NuivARB) (GLuint index, const GLuint *v);
+extern GLvoid (APIENTRYP qglVertexAttribPointerARB) (GLuint index, GLint size, GLenum type, GLboolean normalized,
+						     GLsizei stride, const GLvoid *pointer);
+extern GLvoid (APIENTRYP qglEnableVertexAttribArrayARB) (GLuint index);
+extern GLvoid (APIENTRYP qglDisableVertexAttribArrayARB) (GLuint index);
+extern GLvoid (APIENTRYP qglBindAttribLocationARB) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
+extern GLvoid (APIENTRYP qglGetActiveAttribARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
+						 GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+extern GLint (APIENTRYP qglGetAttribLocationARB) (GLhandleARB programObj, const GLcharARB *name);
+extern GLvoid (APIENTRYP qglGetVertexAttribdvARB) (GLuint index, GLenum pname, GLdouble *params);
+extern GLvoid (APIENTRYP qglGetVertexAttribfvARB) (GLuint index, GLenum pname, GLfloat *params);
+extern GLvoid (APIENTRYP qglGetVertexAttribivARB) (GLuint index, GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglGetVertexAttribPointervARB) (GLuint index, GLenum pname, GLvoid **pointer);
+
+// GL_ARB_framebuffer_object
+extern GLboolean (APIENTRYP qglIsRenderbuffer) (GLuint renderbuffer);
+extern GLvoid (APIENTRYP qglBindRenderbuffer) (GLenum target, GLuint renderbuffer);
+extern GLvoid (APIENTRYP qglDeleteRenderbuffers) (GLsizei n, const GLuint *renderbuffers);
+extern GLvoid (APIENTRYP qglGenRenderbuffers) (GLsizei n, GLuint *renderbuffers);
+extern GLvoid (APIENTRYP qglRenderbufferStorage) (GLenum target, GLenum internalformat,
+						  GLsizei width, GLsizei height);
+extern GLvoid (APIENTRYP qglRenderbufferStorageMultisample) (GLenum target, GLsizei samples,
+							     GLenum internalformat,
+							     GLsizei width, GLsizei height);
+extern GLvoid (APIENTRYP qglGetRenderbufferParameteriv) (GLenum target, GLenum pname, GLint *params);
+extern GLboolean (APIENTRYP qglIsFramebuffer) (GLuint framebuffer);
+extern GLvoid (APIENTRYP qglBindFramebuffer) (GLenum target, GLuint framebuffer);
+extern GLvoid (APIENTRYP qglDeleteFramebuffers) (GLsizei n, const GLuint *framebuffers);
+extern GLvoid (APIENTRYP qglGenFramebuffers) (GLsizei n, GLuint *framebuffers);
+extern GLenum (APIENTRYP qglCheckFramebufferStatus) (GLenum target);
+extern GLvoid (APIENTRYP qglFramebufferTexture1D) (GLenum target, GLenum attachment,
+						   GLenum textarget, GLuint texture, GLint level);
+extern GLvoid (APIENTRYP qglFramebufferTexture2D) (GLenum target, GLenum attachment,
+						   GLenum textarget, GLuint texture, GLint level);
+extern GLvoid (APIENTRYP qglFramebufferTexture3D) (GLenum target, GLenum attachment,
+						   GLenum textarget, GLuint texture,
+						   GLint level, GLint layer);
+extern GLvoid (APIENTRYP qglFramebufferTextureLayer) (GLenum target, GLenum attachment,
+						      GLuint texture, GLint level, GLint layer);
+extern GLvoid (APIENTRYP qglFramebufferRenderbuffer) (GLenum target, GLenum attachment,
+						      GLenum renderbuffertarget, GLuint renderbuffer);
+extern GLvoid (APIENTRYP qglGetFramebufferAttachmentParameteriv) (GLenum target, GLenum attachment,
+								  GLenum pname, GLint *params);
+extern GLvoid (APIENTRYP qglBlitFramebuffer) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
+					      GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
+					      GLbitfield mask, GLenum filter);
+extern GLvoid (APIENTRYP qglGenerateMipmap) (GLenum target);
+
 
 //===========================================================================
 
diff -r 11104731f8c9 -r 87f98d895296 src/renderer/tr_animation.c
--- a/src/renderer/tr_animation.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/renderer/tr_animation.c	Sun Mar 29 01:15:08 2009 +0800
@@ -62,12 +62,13 @@
 RB_SurfaceAnim
 ==============
 */
-void RB_SurfaceAnim( md4Surface_t *surface ) {
+void RB_SurfaceAnim( surfaceType_t *surf ) {
+	md4Surface_t		*surface = (md4Surface_t *)surf;
 	int				i, j, k;
 	float			frontlerp, backlerp;
 	int				*triangles;
 	int				indexes;
-	int				baseIndex, baseVertex;
+	int				baseVertex;
 	int				numVerts;
 	md4Vertex_t		*v;
 	md4Bone_t		bones[MD4_MAX_BONES];
@@ -76,7 +77,10 @@
 	md4Frame_t		*frame;
 	md4Frame_t		*oldFrame;
 	int				frameSize;
-
+	GLuint			*indexPtr;
+	GLushort		*indexPtrShort;
+	vec4_t			*xyzPtr, *normalPtr;
+	vec2_t			*texCoordPtr;
 
 	if (  backEnd.currentEntity->e.oldframe == backEnd.currentEntity->e.frame ) {
 		backlerp = 0;
@@ -94,17 +98,36 @@
 	oldFrame = (md4Frame_t *)((byte *)header + header->ofsFrames + 
 			backEnd.currentEntity->e.oldframe * frameSize );
 
+	if ( !tess.indexPtr ) {
+		/* only calculate number of vertices/indexes */
+		tess.numIndexes += surface->numTriangles * 3;
+		tess.numVertexes += surface->numVerts;
+		return;
+	}
+
 	RB_CheckOverflow( surface->numVerts, surface->numTriangles * 3 );
 
+	indexPtr = ptrPlusOffset(tess.indexPtr, tess.indexInc * tess.numIndexes);
+	xyzPtr = ptrPlusOffset(tess.xyzPtr, tess.xyzInc * tess.numVertexes);
+	normalPtr = ptrPlusOffset(tess.normalPtr, tess.normalInc * tess.numVertexes);
+	texCoordPtr = ptrPlusOffset(tess.texCoordPtr, tess.texCoordInc * tess.numVertexes);
+
 	triangles = (int *) ((byte *)surface + surface->ofsTriangles);
 	indexes = surface->numTriangles * 3;
-	baseIndex = tess.numIndexes;
 	baseVertex = tess.numVertexes;
-	for (j = 0 ; j < indexes ; j++) {
-		tess.indexes[baseIndex + j] = baseIndex + triangles[j];
+
+	if ( tess.indexInc == sizeof(GLushort) ) {
+		indexPtrShort = (GLushort *)indexPtr;
+		for (j = 0 ; j < indexes ; j++) {
+			*indexPtrShort++ = (GLushort)(baseVertex + triangles[j]);
+		}
+	} else {
+		for (j = 0 ; j < indexes ; j++) {
+			*indexPtr++ = baseVertex + triangles[j];
+		}
 	}
 	tess.numIndexes += indexes;
-
+	
 	//
 	// lerp all the needed bones
 	//
@@ -129,11 +152,11 @@
 	//v = (md4Vertex_t *) ((byte *)surface + surface->ofsVerts + 12);
 	v = (md4Vertex_t *) ((byte *)surface + surface->ofsVerts);
 	for ( j = 0; j < numVerts; j++ ) {
-		vec3_t	tempVert, tempNormal;
+		vec4_t	tempVert, tempNormal;
 		md4Weight_t	*w;
 
-		VectorClear( tempVert );
-		VectorClear( tempNormal );
+		VectorClear( tempVert ); tempVert[3] = 0.0;
+		VectorClear( tempNormal ); tempNormal[3] = 0.0;
 		w = v->weights;
 		for ( k = 0 ; k < v->numWeights ; k++, w++ ) {
 			bone = bonePtr + w->boneIndex;
@@ -147,16 +170,14 @@
 			tempNormal[2] += w->boneWeight * DotProduct( bone->matrix[2], v->normal );
 		}
 
-		tess.xyz[baseVertex + j][0] = tempVert[0];
-		tess.xyz[baseVertex + j][1] = tempVert[1];
-		tess.xyz[baseVertex + j][2] = tempVert[2];
+		Vector4Copy( *xyzPtr, tempVert );
+		xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
 
-		tess.normal[baseVertex + j][0] = tempNormal[0];
-		tess.normal[baseVertex + j][1] = tempNormal[1];
-		tess.normal[baseVertex + j][2] = tempNormal[2];
+		Vector4Copy( *normalPtr, tempNormal );
+		normalPtr = ptrPlusOffset(normalPtr, tess.normalInc);
 
-		tess.texCoords[baseVertex + j][0][0] = v->texCoords[0];
-		tess.texCoords[baseVertex + j][0][1] = v->texCoords[1];
+		Vector2Copy( *texCoordPtr, v->texCoords );
+		texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
 
 		// FIXME
 		// This makes TFC's skeletons work.  Shouldn't be necessary anymore, but left
@@ -445,8 +466,9 @@
 RB_MDRSurfaceAnim
 ==============
 */
-void RB_MDRSurfaceAnim( md4Surface_t *surface )
+void RB_MDRSurfaceAnim( surfaceType_t *surf )
 {
+	md4Surface_t *surface = (md4Surface_t *) surf;
 	int				i, j, k;
 	float			frontlerp, backlerp;
 	int				*triangles;
diff -r 11104731f8c9 -r 87f98d895296 src/renderer/tr_backend.c
--- a/src/renderer/tr_backend.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/renderer/tr_backend.c	Sun Mar 29 01:15:08 2009 +0800
@@ -83,6 +83,20 @@
 		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE1_ARB )\n" );
 		qglClientActiveTextureARB( GL_TEXTURE1_ARB );
 		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE1_ARB )\n" );
+	}
+	else if ( unit == 2 )
+	{
+		qglActiveTextureARB( GL_TEXTURE2_ARB );
+		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE2_ARB )\n" );
+		qglClientActiveTextureARB( GL_TEXTURE2_ARB );
+		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE2_ARB )\n" );
+	}
+	else if ( unit == 3 )
+	{
+		qglActiveTextureARB( GL_TEXTURE3_ARB );
+		GLimp_LogComment( "glActiveTextureARB( GL_TEXTURE3_ARB )\n" );
+		qglClientActiveTextureARB( GL_TEXTURE3_ARB );
+		GLimp_LogComment( "glClientActiveTextureARB( GL_TEXTURE3_ARB )\n" );
 	} else {
 		ri.Error( ERR_DROP, "GL_SelectTexture: unit = %i", unit );
 	}
@@ -389,6 +403,26 @@
 
 
 /*
+** GL_State
+**
+** This routine is responsible for setting the most commonly changed state
+** in Q3.
+*/
+void GL_VBO( GLuint vbo, GLuint ibo )
+{
+	if ( glState.currentVBO != vbo ) {
+		glState.currentVBO = vbo;
+		qglBindBufferARB (GL_ARRAY_BUFFER_ARB, vbo );
+	}
+
+	if ( glState.currentIBO != ibo ) {
+		glState.currentIBO = ibo;
+		qglBindBufferARB (GL_ELEMENT_ARRAY_BUFFER_ARB, ibo );
+	}
+}
+
+
+/*
 ================
 RB_Hyperspace
 
@@ -510,6 +544,49 @@
 }
 
 
+/*
+==================
+findShaderVBO
+==================
+*/
+static int
+findShaderVBO( shader_t *shader, int VBOkey ) {
+	int		i;
+	vboInfo_t	vbo;
+	
+	if ( shader->VBOs[0].key == VBOkey )
+		return qtrue;
+
+	if ( shader->VBOs[0].key == 0 )
+		return qfalse;
+
+	for ( i = 1; i < MAX_VBOS_PER_SHADER; i++ ) {
+		if ( shader->VBOs[i].key == 0 )
+			return qfalse;
+		
+		if ( shader->VBOs[i].key == VBOkey ) {
+			// move found key to front
+			vbo = shader->VBOs[i];
+			memmove( &(shader->VBOs[1]), &(shader->VBOs[0]), sizeof(vboInfo_t) * i );
+			shader->VBOs[0] = vbo;
+			return qtrue;
+		}
+	}
+	return qfalse;
+}
+
+
+static void newShaderVBO( shader_t *shader, int VBOkey )
+{
+	// discard last key
+	if ( shader->VBOs[MAX_VBOS_PER_SHADER - 1].key != 0 ) {
+		// free stored VBO and IBO
+		qglDeleteBuffersARB(1, &shader->VBOs[MAX_VBOS_PER_SHADER - 1].vbo);
+		qglDeleteBuffersARB(1, &shader->VBOs[MAX_VBOS_PER_SHADER - 1].ibo);
+	}
+	memmove( &(shader->VBOs[1]), &(shader->VBOs[0]), sizeof(vboInfo_t) * (MAX_VBOS_PER_SHADER - 1) );
+}
+
 #define	MAC_EVENT_PUMP_MSEC		5
 
 /*
@@ -523,11 +600,12 @@
 	int				entityNum, oldEntityNum;
 	int				dlighted, oldDlighted;
 	qboolean		depthRange, oldDepthRange, isCrosshair, wasCrosshair;
-	int				i;
+	int				i, j;
 	drawSurf_t		*drawSurf;
 	int				oldSort;
 	float			originalTime;
-
+	int sortMask = -1 << QSORT_ENTITYNUM_SHIFT; // mask out fog and dlight bits
+	
 	// save original time for entity shader offsets
 	originalTime = backEnd.refdef.floatTime;
 
@@ -547,6 +625,23 @@
 
 	backEnd.pc.c_surfaces += numDrawSurfs;
 
+	tess.indexPtr = tess.indexes;
+	tess.indexInc = sizeof(GLuint);
+	tess.xyzPtr = tess.xyz;
+	tess.xyzInc = sizeof(vec4_t);
+	tess.normalPtr = tess.normal;
+	tess.normalInc = sizeof(vec4_t);
+	tess.texCoordPtr = (vec2_t *)&(tess.texCoords[0][0]);
+	tess.texCoordInc = 2*sizeof(vec2_t);
+	tess.texCoord2Ptr = tess.texCoordPtr + 1;
+	tess.texCoord2Inc = 2*sizeof(vec2_t);
+	tess.vertexColorPtr = tess.vertexColors;
+	tess.vertexColorInc = sizeof(color4ub_t);
+	tess.vertexDlightBitPtr = tess.vertexDlightBits;
+	tess.vertexDlightBitInc = sizeof(int);
+	tess.maxIndexes = SHADER_MAX_INDEXES;
+	tess.maxVertexes = SHADER_MAX_VERTEXES;
+
 	for (i = 0, drawSurf = drawSurfs ; i < numDrawSurfs ; i++, drawSurf++) {
 		if ( drawSurf->sort == oldSort ) {
 			// fast path, same as previous sort
@@ -666,8 +761,186 @@
 			oldEntityNum = entityNum;
 		}
 
-		// add the triangles for this surface
-		rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
+		// look if we have a VBO for this shader/entity
+		int VBOkey = 0;
+		
+		if ( shader->useVBO && !dlighted && !fogNum ) {
+			if (entityNum == ENTITYNUM_WORLD) {
+				if ( tr.viewCluster >= 0 ) {
+					VBOkey = VBOKEY_VIS | (tr.viewCluster & VBOKEY_IDXMASK);
+				}
+			} else {
+				trRefEntity_t	*ent = backEnd.currentEntity;
+				if ( ent->e.reType == RT_MODEL ) {
+					model_t *model = R_GetModelByHandle( ent->e.hModel );
+					if ( model->type == MOD_BRUSH ) {
+						VBOkey = VBOKEY_MODEL | (ent->e.hModel & VBOKEY_IDXMASK);
+					} else if ( model->type == MOD_MESH &&
+						ent->e.frame == ent->e.oldframe ) {
+						// combine hModel and frame number into key
+						// allows 65536 models with 256 frames
+						VBOkey = VBOKEY_MD3 | (ent->e.hModel << 8) | ent->e.frame;
+					}
+				}
+			}
+		}
+		
+		if ( VBOkey > 0 ) {
+			if ( !findShaderVBO( shader, VBOkey ) ) {
+				// create new VBO
+				byte *vertexData, *indexData;
+				vboInfo_t *vbo;
+				
+				// count only
+				tess.indexPtr = NULL;
+				for ( j = 0; j < numDrawSurfs - i &&
+					((drawSurf+j)->sort & sortMask) == (oldSort & sortMask); j++ ) {
+					rb_surfaceTable[ *(drawSurf+j)->surface ]( (drawSurf+j)->surface );
+				}
+				
+				if (tess.numVertexes < 32 && tess.numIndexes < 32) {
+					// skip tiny VBOs
+					tess.numVertexes = tess.numIndexes = 0;
+					tess.indexPtr = tess.indexes;
+					tess.indexInc = sizeof(GLuint);
+					rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
+					continue;
+				}
+
+				newShaderVBO( shader, VBOkey );
+				vbo = &(shader->VBOs[0]);
+
+				// allocate VBOs
+				qglGenBuffersARB(1, &vbo->vbo);
+				qglGenBuffersARB(1, &vbo->ibo);
+				
+				GL_VBO( vbo->vbo, vbo->ibo );
+				vbo->vertexSize = sizeof(vec4_t);
+				if ( shader->needsST1 )
+					vbo->vertexSize += sizeof(vec2_t);
+				if ( shader->needsST2 )
+					vbo->vertexSize += sizeof(vec2_t);
+				if ( shader->needsNormal )
+					vbo->vertexSize += sizeof(vec3_t);
+				if ( shader->needsColor )
+					vbo->vertexSize += sizeof(color4ub_t);
+				vbo->vertexSize = (vbo->vertexSize + 31) & -32;
+
+				qglBufferDataARB(GL_ARRAY_BUFFER_ARB,
+						 tess.numVertexes * vbo->vertexSize,
+						 NULL, GL_STATIC_DRAW_ARB);
+				
+				if ( tess.numVertexes > 65536 )
+ 					qglBufferDataARB(GL_ELEMENT_ARRAY_BUFFER_ARB,
+							 sizeof(GLuint) * tess.numIndexes,
+							 NULL, GL_STATIC_DRAW_ARB);
+				else
+					qglBufferDataARB(GL_ELEMENT_ARRAY_BUFFER_ARB,
+							 sizeof(GLushort) * tess.numIndexes,
+							 NULL, GL_STATIC_DRAW_ARB);
+				
+				vertexData = qglMapBufferARB(GL_ARRAY_BUFFER_ARB, GL_WRITE_ONLY_ARB);
+				indexData = qglMapBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, GL_WRITE_ONLY_ARB);
+				
+				// setup tess to write into VBO
+				tess.xyzPtr = (vec4_t *)(vertexData);
+				tess.xyzInc = VBO_inc(shader, vbo);
+				vertexData += sizeof(vec4_t);
+				
+				if ( shader->needsST1 ) {
+					tess.texCoordPtr = (vec2_t *)vertexData;
+					tess.texCoordInc = VBO_inc(shader, vbo);
+					vertexData += sizeof(vec2_t);
+				} else {
+					tess.texCoordPtr = (vec2_t *)&vec4Scratch;
+					tess.texCoordInc = 0;
+				}
+				
+				if ( shader->needsST2 ) {
+					tess.texCoord2Ptr = (vec2_t *)vertexData;
+					tess.texCoord2Inc = VBO_inc(shader, vbo);
+					vertexData += sizeof(vec2_t);
+				} else {
+					tess.texCoord2Ptr = (vec2_t *)&vec4Scratch;
+					tess.texCoord2Inc = 0;
+				}
+				
+				if ( shader->needsNormal ) {
+					tess.normalPtr = (vec4_t *)vertexData;
+					tess.normalInc = VBO_inc(shader,vbo);
+					vertexData += sizeof(vec3_t);
+				} else {
+					tess.normalPtr = &vec4Scratch;
+					tess.normalInc = 0;
+				}
+
+				if ( shader->needsColor ) {
+					tess.vertexColorPtr = (color4ub_t *)vertexData;
+					tess.vertexColorInc = VBO_inc(shader,vbo);
+					vertexData += sizeof(color4ub_t);
+				} else {
+					tess.vertexColorPtr = (color4ub_t *)&vec4Scratch;
+					tess.vertexColorInc = 0;
+				}
+
+				tess.vertexDlightBitPtr = (int *)&vec4Scratch;
+				tess.vertexDlightBitInc = 0;
+
+				tess.indexPtr = (GLuint *)(indexData);
+				tess.indexInc = tess.numVertexes > 65536 ? sizeof(GLuint) : sizeof(GLushort);
+				tess.maxIndexes = tess.numIndexes+1;
+				tess.maxVertexes = tess.numVertexes+1;
+
+				tess.numVertexes = tess.numIndexes = 0;
+
+				// ignore change of dlights/fog
+				while ( i < numDrawSurfs &&
+					(drawSurf->sort & sortMask) == (oldSort & sortMask) ) {
+					rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
+					i++, drawSurf++;
+				}
+				
+				qglUnmapBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB);
+				qglUnmapBufferARB(GL_ARRAY_BUFFER_ARB);
+
+				shader->VBOs[0].key = VBOkey;
+				shader->VBOs[0].numVertexes = tess.numVertexes;
+				shader->VBOs[0].numIndexes = tess.numIndexes;
+
+				// setup tess to write into memory
+				tess.indexPtr = tess.indexes;
+				tess.indexInc = sizeof(GLuint);
+				tess.xyzPtr = tess.xyz;
+				tess.xyzInc = sizeof(vec4_t);
+				tess.normalPtr = tess.normal;
+				tess.normalInc = sizeof(vec4_t);
+				tess.texCoordPtr = (vec2_t *)(&tess.texCoords[0][0]);
+				tess.texCoordInc = 2*sizeof(vec2_t);
+				tess.texCoord2Ptr = tess.texCoordPtr + 1;
+				tess.texCoord2Inc = 2*sizeof(vec2_t);
+				tess.vertexColorPtr = tess.vertexColors;
+				tess.vertexColorInc = sizeof(color4ub_t);
+				tess.vertexDlightBitPtr = tess.vertexDlightBits;
+				tess.vertexDlightBitInc = sizeof(int);
+				tess.maxIndexes = SHADER_MAX_INDEXES;
+				tess.maxVertexes = SHADER_MAX_VERTEXES;
+				tess.numIndexes = 0;
+				tess.numVertexes = 0;
+			} else {
+				// VBO exists, skip to next sort key
+				while ( i < numDrawSurfs && drawSurf->sort == oldSort ) {
+					i++;
+					drawSurf++;
+				}
+			}
+			i--; drawSurf--;
+			// add VBO to draw list
+			tess.renderVBO = &(shader->VBOs[0]);
+			continue;
+		} else {
+			// add the triangles for this surface
+			rb_surfaceTable[ *drawSurf->surface ]( drawSurf->surface );
+		}
 	}
 
 	backEnd.refdef.floatTime = originalTime;
@@ -677,6 +950,8 @@
 		RB_EndSurface();
 	}
 
+	GL_VBO( 0, 0 );
+
 	// go back to the world modelview matrix
 	qglLoadMatrixf( backEnd.viewParms.world.modelMatrix );
 	if ( depthRange ) {
diff -r 11104731f8c9 -r 87f98d895296 src/renderer/tr_bsp.c
--- a/src/renderer/tr_bsp.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/renderer/tr_bsp.c	Sun Mar 29 01:15:08 2009 +0800
@@ -39,6 +39,7 @@
 
 int			c_subdivisions;
 int			c_gridVerts;
+int			lightmapWidth, lightmapHeight;
 
 //===============================================================================
 
@@ -136,8 +137,9 @@
 static	void R_LoadLightmaps( lump_t *l ) {
 	byte		*buf, *buf_p;
 	int			len;
-	byte		image[LIGHTMAP_SIZE*LIGHTMAP_SIZE*4];
-	int			i, j;
+	byte		*image;
+	int			i, j, k, x, y;
+	int		numLightmaps;
 	float maxIntensity = 0;
 	double sumIntensity = 0;
 
@@ -152,11 +154,7 @@
 
 	// create all the lightmaps
 	tr.numLightmaps = len / (LIGHTMAP_SIZE * LIGHTMAP_SIZE * 3);
-	if ( tr.numLightmaps == 1 ) {
-		//FIXME: HACK: maps with only one lightmap turn up fullbright for some reason.
-		//this avoids this, but isn't the correct solution.
-		tr.numLightmaps++;
-	} else if ( tr.numLightmaps >= MAX_LIGHTMAPS ) { // 20051020 misantropia
+	if ( tr.numLightmaps >= MAX_LIGHTMAPS ) { // 20051020 misantropia
 		ri.Printf( PRINT_WARNING, "WARNING: number of lightmaps > MAX_LIGHTMAPS\n" );
 		tr.numLightmaps = MAX_LIGHTMAPS;
 	}
@@ -165,49 +163,87 @@
 	if ( r_vertexLight->integer || glConfig.hardwareType == GLHW_PERMEDIA2 ) {
 		return;
 	}
+	
+	// see how many lightmaps we can stuff into one texture
+	lightmapWidth = lightmapHeight = 1;
+	while ( lightmapWidth < glConfig.maxTextureSize &&
+		lightmapWidth * lightmapHeight < tr.numLightmaps ) {
+		lightmapWidth *= 2;
+		if ( lightmapWidth * lightmapHeight >= tr.numLightmaps )
+			break;
+		lightmapHeight *= 2;
+	}
+	image = Hunk_AllocateTempMemory( lightmapWidth * lightmapHeight *
+					 LIGHTMAP_SIZE * LIGHTMAP_SIZE * 4 );
 
-	for ( i = 0 ; i < tr.numLightmaps ; i++ ) {
-		// expand the 24 bit on-disk to 32 bit
-		buf_p = buf + i * LIGHTMAP_SIZE*LIGHTMAP_SIZE * 3;
+	// calculate number of resulting lightmap textures
+	numLightmaps = (tr.numLightmaps + lightmapWidth * lightmapHeight - 1)
+		/ (lightmapWidth * lightmapHeight);
+	
+	for ( i = 0 ; i < numLightmaps; i++ ) {
+		for ( y = 0; y < lightmapHeight; y++ ) {
+			if ( (i * lightmapHeight + y) * lightmapWidth >= tr.numLightmaps)
+				break;
+			
+			for ( x = 0; x < lightmapWidth; x++ ) {
+				if ( (i * lightmapHeight + y) * lightmapWidth + x >= tr.numLightmaps)
+					break;
+			
+				// expand the 24 bit on-disk to 32 bit
+				buf_p = buf + ((i*lightmapHeight + y) * lightmapWidth + x) * LIGHTMAP_SIZE*LIGHTMAP_SIZE * 3;
 
-		if ( r_lightmap->integer == 2 )
-		{	// color code by intensity as development tool	(FIXME: check range)
-			for ( j = 0; j < LIGHTMAP_SIZE * LIGHTMAP_SIZE; j++ )
-			{
-				float r = buf_p[j*3+0];
-				float g = buf_p[j*3+1];
-				float b = buf_p[j*3+2];
-				float intensity;
-				float out[3] = {0.0, 0.0, 0.0};
+				if ( r_lightmap->integer == 2 )
+				{	// color code by intensity as development tool	(FIXME: check range)
+					for ( j = 0; j < LIGHTMAP_SIZE ; j++ ) {
+						for ( k = 0; k < LIGHTMAP_SIZE; k++ ) {
+							float r = buf_p[(j * LIGHTMAP_SIZE + k)*3+0];
+							float g = buf_p[(j * LIGHTMAP_SIZE + k)*3+1];
+							float b = buf_p[(j * LIGHTMAP_SIZE + k)*3+2];
+							float intensity;
+							float out[3] = {0.0, 0.0, 0.0};
 
-				intensity = 0.33f * r + 0.685f * g + 0.063f * b;
+							intensity = 0.33f * r + 0.685f * g + 0.063f * b;
 
-				if ( intensity > 255 )
-					intensity = 1.0f;
-				else
-					intensity /= 255.0f;
+							if ( intensity > 255 )
+								intensity = 1.0f;
+							else
+								intensity /= 255.0f;
 
-				if ( intensity > maxIntensity )
-					maxIntensity = intensity;
+							if ( intensity > maxIntensity )
+								maxIntensity = intensity;
 
-				HSVtoRGB( intensity, 1.00, 0.50, out );
+							HSVtoRGB( intensity, 1.00, 0.50, out );
 
-				image[j*4+0] = out[0] * 255;
-				image[j*4+1] = out[1] * 255;
-				image[j*4+2] = out[2] * 255;
-				image[j*4+3] = 255;
+							image[(((y * LIGHTMAP_SIZE + j) * lightmapWidth + x) * LIGHTMAP_SIZE + k)*4+0] = out[0] * 255;
+							image[(((y * LIGHTMAP_SIZE + j) * lightmapWidth + x) * LIGHTMAP_SIZE + k)*4+1] = out[1] * 255;
+							image[(((y * LIGHTMAP_SIZE + j) * lightmapWidth + x) * LIGHTMAP_SIZE + k)*4+2] = out[2] * 255;
+							image[(((y * LIGHTMAP_SIZE + j) * lightmapWidth + x) * LIGHTMAP_SIZE + k)*4+3] = 255;
 
-				sumIntensity += intensity;
-			}
-		} else {
-			for ( j = 0 ; j < LIGHTMAP_SIZE * LIGHTMAP_SIZE; j++ ) {
-				R_ColorShiftLightingBytes( &buf_p[j*3], &image[j*4] );
-				image[j*4+3] = 255;
+							sumIntensity += intensity;
+						}
+					}
+				} else {
+					for ( j = 0; j < LIGHTMAP_SIZE ; j++ ) {
+						for ( k = 0; k < LIGHTMAP_SIZE; k++ ) {
+							R_ColorShiftLightingBytes( &buf_p[(j * LIGHTMAP_SIZE + k)*3], &image[(((y * LIGHTMAP_SIZE + j) * lightmapWidth + x) * LIGHTMAP_SIZE + k)*4] );
+							image[(((y * LIGHTMAP_SIZE + j) * lightmapWidth + x) * LIGHTMAP_SIZE + k)*4+3] = 255;
+						}
+					}
+				}
 			}
 		}
 		tr.lightmaps[i] = R_CreateImage( va("*lightmap%d",i), image, 
-			LIGHTMAP_SIZE, LIGHTMAP_SIZE, qfalse, qfalse, GL_CLAMP_TO_EDGE );
+						 LIGHTMAP_SIZE * lightmapWidth, LIGHTMAP_SIZE * lightmapHeight,
+						 qfalse, qfalse, GL_CLAMP_TO_EDGE );
+		ri.Printf( PRINT_DEVELOPER, "lightmaps[%i]=%i\n", i, tr.lightmaps[i]->texnum);
 	}
+	// dummy lightmap
+	tr.lightmaps[i] = R_CreateImage( va("*lightmap%d",i), image, 
+					 LIGHTMAP_SIZE, LIGHTMAP_SIZE,
+					 qfalse, qfalse, GL_CLAMP_TO_EDGE );
+	Hunk_FreeTempMemory( image );
+
+	tr.numLightmaps = i;
 
 	if ( r_lightmap->integer == 2 )	{
 		ri.Printf( PRINT_DEVELOPER, "Brightest lightmap value: %d\n", ( int ) ( maxIntensity * 255 ) );
@@ -308,10 +344,14 @@
 	int			i, j;
 	srfSurfaceFace_t	*cv;
 	int			numPoints, numIndexes;
-	int			lightmapNum;
+	int			lightmapNum, lightmapX, lightmapY;
 	int			sfaceSize, ofsIndexes;
 
 	lightmapNum = LittleLong( ds->lightmapNum );
+	lightmapX = lightmapNum & (lightmapWidth - 1);
+	lightmapNum /= lightmapWidth;
+	lightmapY = lightmapNum & (lightmapHeight - 1);
+	lightmapNum /= lightmapHeight;
 
 	// get fog volume
 	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
@@ -352,6 +392,10 @@
 			cv->points[i][5+j] = LittleFloat( verts[i].lightmap[j] );
 		}
 		R_ColorShiftLightingBytes( verts[i].color, (byte *)&cv->points[i][7] );
+
+		// adjust lightmap coords
+		cv->points[i][5] = (cv->points[i][5] + lightmapX) / lightmapWidth;
+		cv->points[i][6] = (cv->points[i][6] + lightmapY) / lightmapHeight;
 	}
 
 	indexes += LittleLong( ds->firstIndex );
@@ -381,12 +425,16 @@
 	int				i, j;
 	int				width, height, numPoints;
 	drawVert_t points[MAX_PATCH_SIZE*MAX_PATCH_SIZE];
-	int				lightmapNum;
+	int				lightmapNum, lightmapX, lightmapY;
 	vec3_t			bounds[2];
 	vec3_t			tmpVec;
 	static surfaceType_t	skipData = SF_SKIP;
 
 	lightmapNum = LittleLong( ds->lightmapNum );
+	lightmapX = lightmapNum & (lightmapWidth - 1);
+	lightmapNum /= lightmapWidth;
+	lightmapY = lightmapNum & (lightmapHeight - 1);
+	lightmapNum /= lightmapHeight;
 
 	// get fog volume
 	surf->fogIndex = LittleLong( ds->fogNum ) + 1;
@@ -419,6 +467,10 @@
 			points[i].lightmap[j] = LittleFloat( verts[i].lightmap[j] );
 		}
 		R_ColorShiftLightingBytes( verts[i].color, points[i].color );
+
+		// adjust lightmap coords
+		points[i].lightmap[0] = (points[i].lightmap[0] + lightmapX) / lightmapWidth;
+		points[i].lightmap[1] = (points[i].lightmap[1] + lightmapY) / lightmapHeight;
 	}
 
 	// pre-tesseleate
diff -r 11104731f8c9 -r 87f98d895296 src/renderer/tr_image.c
--- a/src/renderer/tr_image.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/renderer/tr_image.c	Sun Mar 29 01:15:08 2009 +0800
@@ -504,12 +504,13 @@
 */
 extern qboolean charSet;
 static void Upload32( unsigned *data, 
-						  int width, int height, 
-						  qboolean mipmap, 
-						  qboolean picmip, 
-							qboolean lightMap,
-						  int *format, 
-						  int *pUploadWidth, int *pUploadHeight )
+		      int width, int height, 
+		      qboolean mipmap, 
+		      qboolean picmip, 
+		      qboolean lightMap,
+		      int *format, 
+		      int *pUploadWidth, int *pUploadHeight,
+		      qboolean *hasAlpha )
 {
 	int			samples;
 	unsigned	*scaledBuffer = NULL;
@@ -611,6 +612,7 @@
 		// select proper internal format
 		if ( samples == 3 )
 		{
+			*hasAlpha = qfalse;
 			if(r_greyscale->integer)
 			{
 				if(r_texturebits->integer == 16)
@@ -646,6 +648,7 @@
 		}
 		else if ( samples == 4 )
 		{
+			*hasAlpha = qtrue;
 			if(r_greyscale->integer)
 			{
 				if(r_texturebits->integer == 16)
@@ -815,12 +818,13 @@
 	GL_Bind(image);
 
 	Upload32( (unsigned *)pic, image->width, image->height, 
-								image->mipmap,
-								allowPicmip,
-								isLightmap,
-								&image->internalFormat,
-								&image->uploadWidth,
-								&image->uploadHeight );
+		  image->mipmap,
+		  allowPicmip,
+		  isLightmap,
+		  &image->internalFormat,
+		  &image->uploadWidth,
+		  &image->uploadHeight,
+		  &image->hasAlpha );
 
 	qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, glWrapClampMode );
 	qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, glWrapClampMode );
diff -r 11104731f8c9 -r 87f98d895296 src/renderer/tr_init.c
--- a/src/renderer/tr_init.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/renderer/tr_init.c	Sun Mar 29 01:15:08 2009 +0800
@@ -95,6 +95,9 @@
 cvar_t	*r_ext_texture_env_add;
 cvar_t	*r_ext_texture_filter_anisotropic;
 cvar_t	*r_ext_max_anisotropy;
+cvar_t	*r_ext_vertex_buffer_object;
+cvar_t	*r_ext_vertex_shader;
+cvar_t  *r_ext_framebuffer_object;
 
 cvar_t	*r_ignoreGLErrors;
 cvar_t	*r_logFile;
@@ -167,6 +170,8 @@
 //. next one for enable/disable cel bordering all together.
 cvar_t	*r_celoutline;
 
+cvar_t	*r_flush;
+
 cvar_t	*r_maxpolys;
 int		max_polys;
 cvar_t	*r_maxpolyverts;
@@ -916,6 +921,9 @@
 	r_ext_multitexture = ri.Cvar_Get( "r_ext_multitexture", "1", CVAR_ARCHIVE | CVAR_LATCH );
 	r_ext_compiled_vertex_array = ri.Cvar_Get( "r_ext_compiled_vertex_array", "1", CVAR_ARCHIVE | CVAR_LATCH);
 	r_ext_texture_env_add = ri.Cvar_Get( "r_ext_texture_env_add", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_vertex_buffer_object = ri.Cvar_Get( "r_ext_vertex_buffer_object", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_vertex_shader = ri.Cvar_Get( "r_ext_vertex_shader", "1", CVAR_ARCHIVE | CVAR_LATCH);
+	r_ext_framebuffer_object = ri.Cvar_Get( "r_ext_framebuffer_object", "1", CVAR_ARCHIVE | CVAR_LATCH);
 
 	r_picmip = ri.Cvar_Get ("r_picmip", GENERIC_HW_R_PICMIP_DEFAULT,
 			CVAR_ARCHIVE | CVAR_LATCH );
@@ -931,16 +939,16 @@
 	r_colorbits = ri.Cvar_Get( "r_colorbits", "0", CVAR_ARCHIVE | CVAR_LATCH );
 	r_stencilbits = ri.Cvar_Get( "r_stencilbits", "8", CVAR_ARCHIVE | CVAR_LATCH );
 	r_depthbits = ri.Cvar_Get( "r_depthbits", "0", CVAR_ARCHIVE | CVAR_LATCH );
-	r_overBrightBits = ri.Cvar_Get ("r_overBrightBits", "1", CVAR_ARCHIVE | CVAR_LATCH );
+	r_overBrightBits = ri.Cvar_Get ("r_overBrightBits", "0", CVAR_ARCHIVE | CVAR_LATCH );
 	r_ignorehwgamma = ri.Cvar_Get( "r_ignorehwgamma", "0", CVAR_ARCHIVE | CVAR_LATCH);
 	r_fullscreen = ri.Cvar_Get( "r_fullscreen", "1", CVAR_ARCHIVE );
 	r_minimize = ri.Cvar_Get( "r_minimize", "0", 0 );
-	r_width = ri.Cvar_Get( "r_width", "800", CVAR_ARCHIVE | CVAR_LATCH );
-	r_height = ri.Cvar_Get( "r_height", "600", CVAR_ARCHIVE | CVAR_LATCH );
+	r_width = ri.Cvar_Get( "r_width", "0", CVAR_ARCHIVE | CVAR_LATCH );
+	r_height = ri.Cvar_Get( "r_height", "0", CVAR_ARCHIVE | CVAR_LATCH );
 	r_pixelAspect = ri.Cvar_Get( "r_pixelAspect", "1", CVAR_ARCHIVE | CVAR_LATCH );
 
 	// legacy variables
-	r_mode = ri.Cvar_Get( "r_mode", "4", 0 );
+	r_mode = ri.Cvar_Get( "r_mode", "-1", 0 );
 	ri.Cvar_CheckRange( r_mode, -1, 11, qtrue );
 	r_customwidth = ri.Cvar_Get( "r_customwidth", r_width->string, 0 );
 	r_customheight = ri.Cvar_Get( "r_customheight", r_height->string, 0 );
@@ -1060,6 +1068,8 @@
 	// cel outline option
 	r_celoutline = ri.Cvar_Get("r_celoutline","0", CVAR_ARCHIVE);
 
+	r_flush = ri.Cvar_Get("r_flush","0", 0);
+
 	// make sure all the commands added here are also
 	// removed in R_Shutdown
 	ri.Cmd_AddCommand( "imagelist", R_ImageList_f );
@@ -1196,6 +1206,24 @@
 		R_SyncRenderThread();
 		R_ShutdownCommandBuffers();
 		R_DeleteTextures();
+
+		if ( qglIsBufferARB && tr.numShaders ) {
+			int shader, vbo;
+			
+			GL_VBO( 0, 0 );
+
+			for ( shader = 0; shader < tr.numShaders; shader++ ) {
+				for ( vbo = 0; vbo < MAX_VBOS_PER_SHADER; vbo++ ) {
+					if ( !tr.shaders[shader]->VBOs[vbo].key )
+						break;
+					
+					if ( qglIsBufferARB( tr.shaders[shader]->VBOs[vbo].ibo ) )
+						qglDeleteBuffersARB( 1, &tr.shaders[shader]->VBOs[vbo].ibo );
+					if ( qglIsBufferARB( tr.shaders[shader]->VBOs[vbo].vbo ) )
+						qglDeleteBuffersARB( 1, &tr.shaders[shader]->VBOs[vbo].vbo );
+				}
+			}
+		}
 	}
 
 	R_DoneFreeType();
diff -r 11104731f8c9 -r 87f98d895296 src/renderer/tr_local.h
--- a/src/renderer/tr_local.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/renderer/tr_local.h	Sun Mar 29 01:15:08 2009 +0800
@@ -54,6 +54,12 @@
 //#define MAX_SHADER_STATES 2048
 #define MAX_STATES_PER_SHADER 32
 #define MAX_STATE_NAME 32
+#define MAX_VBOS_PER_SHADER 16
+
+#define NUM_TEXTURE_BUNDLES 4
+
+// add byte offset to pointer
+#define ptrPlusOffset(ptr, off) (typeof(ptr))((byte *)(ptr) + (off))
 
 // can't be increased without changing bit packing for drawsurfs
 
@@ -104,6 +110,7 @@
 
 	qboolean	mipmap;
 	qboolean	allowPicmip;
+	qboolean        hasAlpha;
 	int			wrapClampMode;		// GL_CLAMP_TO_EDGE or GL_REPEAT
 
 	struct image_s*	next;
@@ -297,10 +304,9 @@
 	qboolean		isLightmap;
 	qboolean		vertexLightmap;
 	qboolean		isVideoMap;
+	int		multitextureEnv;		// 0, GL_MODULATE, GL_ADD
 } textureBundle_t;
 
-#define NUM_TEXTURE_BUNDLES 2
-
 typedef struct {
 	qboolean		active;
 	
@@ -353,6 +359,37 @@
 } fogParms_t;
 
 
+typedef byte color4ub_t[4];
+
+#define VBOKEY_TYPEMASK	0x7f000000
+#define VBOKEY_IDXMASK	0x00ffffff
+#define VBOKEY_VIS   	0x01000000
+#define VBOKEY_MODEL 	0x02000000
+#define VBOKEY_MD3 	0x03000000
+
+typedef struct vboInfo_s {
+	int	key;
+	GLuint  vbo;
+	GLuint  ibo;
+	int	numIndexes;
+	int     numVertexes;
+	int     vertexSize;   // number of bytes of one vertex
+} vboInfo_t;
+
+/* calculate VBO offsets for coordinates, normals, etc.
+ * all data is interleaved and padded to 32 bytes
+ * worst case:  16 byte position + 8 byte texCoord1 + 8 byte texCoord2 +
+ *              12 byte normal + 4 byte color = 64 bytes
+ * common case: 16 byte position + 8 byte texCoord1 + 8 byte texCoord2 =
+ *              32 bytes (lightmapped texture)
+ */
+#define VBO_xyz(shader,vbo)	((byte *)NULL)
+#define VBO_tc1(shader,vbo)	(VBO_xyz(shader,vbo) + sizeof(vec4_t))
+#define VBO_tc2(shader,vbo)	(VBO_tc1(shader,vbo) + sizeof(vec2_t) * (shader)->needsST1)
+#define VBO_normals(shader,vbo)	(VBO_tc2(shader,vbo) + sizeof(vec2_t) * (shader)->needsST2)
+#define VBO_colors(shader,vbo)	(VBO_normals(shader,vbo) + sizeof(vec3_t) * (shader)->needsNormal)
+#define VBO_inc(shader,vbo)     ((vbo)->vertexSize)
+
 typedef struct shader_s {
 	char		name[MAX_QPATH];		// game path, including extension
 	int			lightmapIndex;			// for a shader to match, both name and lightmapIndex must match
@@ -381,8 +418,6 @@
 
 	float		portalRange;			// distance to fog out at
 
-	int			multitextureEnv;		// 0, GL_MODULATE, GL_ADD (FIXME: put in stage)
-
 	cullType_t	cullType;				// CT_FRONT_SIDED, CT_BACK_SIDED, or CT_TWO_SIDED
 	qboolean	polygonOffset;			// set for decals and other items that must be offset 
 	qboolean	noMipMaps;				// for console fonts, 2D elements, etc.
@@ -394,6 +429,7 @@
 	qboolean	needsST1;
 	qboolean	needsST2;
 	qboolean	needsColor;
+	qboolean        useVBO;
 
 	int			numDeforms;
 	deformStage_t	deforms[MAX_SHADER_DEFORMS];
@@ -415,6 +451,9 @@
   struct shader_s *remappedShader;                  // current shader this one is remapped too
 
   int shaderStates[MAX_STATES_PER_SHADER];          // index to valid shader states
+	vboInfo_t VBOs[MAX_VBOS_PER_SHADER];
+
+  GLuint	GLSLprogram;			    // GLSL shader program
 
 	struct	shader_s	*next;
 } shader_t;
@@ -637,11 +676,11 @@
 	int				*indexes;
 
 	int				numVerts;
+
 	drawVert_t		*verts;
 } srfTriangles_t;
 
-
-extern	void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])(void *);
+extern	void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])(surfaceType_t *);
 
 /*
 ==============================================================================
@@ -834,12 +873,13 @@
 
 // the renderer front end should never modify glstate_t
 typedef struct {
-	int			currenttextures[2];
+	int			currenttextures[NUM_TEXTURE_BUNDLES];
 	int			currenttmu;
 	qboolean	finishCalled;
-	int			texEnv[2];
+	int			texEnv[NUM_TEXTURE_BUNDLES];
 	int			faceCulling;
 	unsigned long	glStateBits;
+	GLuint		currentVBO, currentIBO;
 } glstate_t;
 
 
@@ -1066,6 +1106,9 @@
 
 extern cvar_t	*r_ext_texture_filter_anisotropic;
 extern cvar_t	*r_ext_max_anisotropy;
+extern cvar_t   *r_ext_vertex_buffer_object;
+extern cvar_t   *r_ext_vertex_shader;
+extern cvar_t   *r_ext_framebuffer_object;
 
 extern	cvar_t	*r_nobind;						// turns off binding to appropriate textures
 extern	cvar_t	*r_singleShader;				// make most world faces use default shader
@@ -1130,6 +1173,8 @@
 extern	cvar_t	*r_celshadalgo;					// Cell shading, chooses method: 0 = disabled, 1 = kuwahara, 2 = whiteTexture
 extern	cvar_t	*r_celoutline;						//. cel outline. 1 on, 0 off. (maybe other options later)
 
+extern	cvar_t	*r_flush;
+
 //====================================================================
 
 float R_NoiseGet4f( float x, float y, float z, float t );
@@ -1174,6 +1219,7 @@
 void	GL_TextureMode( const char *string );
 void	GL_CheckErrors( void );
 void	GL_State( unsigned long stateVector );
+void	GL_VBO( GLuint vbo, GLuint IBO );
 void	GL_TexEnv( int env );
 void	GL_Cull( int cullType );
 
@@ -1304,7 +1350,6 @@
 
 ====================================================================
 */
-typedef byte color4ub_t[4];
 
 typedef struct stageVars
 {
@@ -1312,6 +1357,7 @@
 	vec2_t		texcoords[NUM_TEXTURE_BUNDLES][SHADER_MAX_VERTEXES];
 } stageVars_t;
 
+extern vec4_t vec4Scratch;
 
 typedef struct shaderCommands_s 
 {
@@ -1321,20 +1367,30 @@
 	vec2_t		texCoords[SHADER_MAX_VERTEXES][2] ALIGNED(16);
 	color4ub_t	vertexColors[SHADER_MAX_VERTEXES] ALIGNED(16);
 	int			vertexDlightBits[SHADER_MAX_VERTEXES] ALIGNED(16);
+	glIndex_t	*indexPtr;
+	vec4_t		*xyzPtr;
+	vec4_t		*normalPtr;
+	vec2_t		*texCoordPtr, *texCoord2Ptr;
+	color4ub_t	*vertexColorPtr;
+	int		*vertexDlightBitPtr;
+	size_t		indexInc, xyzInc, normalInc, texCoordInc, texCoord2Inc,
+			vertexColorInc,	vertexDlightBitInc;
+	int		numIndexes;
+	int		numVertexes;
+	int		maxIndexes;
+	int		maxVertexes;
 
+	int		dlightBits;	// or together of all vertexDlightBits
 	stageVars_t	svars ALIGNED(16);
 
 	color4ub_t	constantColor255[SHADER_MAX_VERTEXES] ALIGNED(16);
 
+	vboInfo_t	*renderVBO;
+
 	shader_t	*shader;
-  float   shaderTime;
+	float			shaderTime;
 	int			fogNum;
 
-	int			dlightBits;	// or together of all vertexDlightBits
-
-	int			numIndexes;
-	int			numVertexes;
-
 	// info extracted from current shader
 	int			numPasses;
 	void		(*currentStageIteratorFunc)( void );
@@ -1347,7 +1403,7 @@
 void RB_BeginSurface(shader_t *shader, int fogNum );
 void RB_EndSurface(void);
 void RB_CheckOverflow( int verts, int indexes );
-#define RB_CHECKOVERFLOW(v,i) if (tess.numVertexes + (v) >= SHADER_MAX_VERTEXES || tess.numIndexes + (i) >= SHADER_MAX_INDEXES ) {RB_CheckOverflow(v,i);}
+#define RB_CHECKOVERFLOW(v,i) if (tess.numVertexes + (v) >= tess.maxVertexes || tess.numIndexes + (i) >= tess.maxIndexes ) {RB_CheckOverflow(v,i);}
 
 void RB_StageIteratorGeneric( void );
 void RB_StageIteratorSky( void );
@@ -1503,10 +1559,10 @@
 
 // void R_MakeAnimModel( model_t *model );      haven't seen this one really, so not needed I guess.
 void R_AddAnimSurfaces( trRefEntity_t *ent );
-void RB_SurfaceAnim( md4Surface_t *surfType );
+void RB_SurfaceAnim( surfaceType_t *surfType );
 #ifdef RAVENMD4
 void R_MDRAddAnimSurfaces( trRefEntity_t *ent );
-void RB_MDRSurfaceAnim( md4Surface_t *surface );
+void RB_MDRSurfaceAnim( surfaceType_t *surface );
 #endif
 
 /*
diff -r 11104731f8c9 -r 87f98d895296 src/renderer/tr_marks.c
--- a/src/renderer/tr_marks.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/renderer/tr_marks.c	Sun Mar 29 01:15:08 2009 +0800
@@ -24,6 +24,9 @@
 
 #include "tr_local.h"
 //#include "assert.h"
+#if id386_sse >= 1
+#include "../qcommon/qsse.h"
+#endif
 
 #define MAX_VERTS_ON_POLY		64
 
@@ -39,6 +42,89 @@
 #define	SIDE_FRONT	0
 #define	SIDE_BACK	1
 #define	SIDE_ON		2
+#if id386_sse >= 1
+static void R_ChopPolyBehindPlane_sse( int numInPoints, v4f inPoints[MAX_VERTS_ON_POLY],
+				       int *numOutPoints, v4f outPoints[MAX_VERTS_ON_POLY], 
+				       v4f plane, vec_t epsilon) {
+	float		dists[MAX_VERTS_ON_POLY+4];
+	int			sides[MAX_VERTS_ON_POLY+4];
+	int			counts[3];
+	v4f		p1, p2, dot;
+	int			i;
+	v4f		*clip;
+	float		d;
+
+	// don't clip if it might overflow
+	if ( numInPoints >= MAX_VERTS_ON_POLY - 2 ) {
+		*numOutPoints = 0;
+		return;
+	}
+
+	counts[0] = counts[1] = counts[2] = 0;
+
+	// determine sides for each point
+	for ( i = 0 ; i < numInPoints ; i++ ) {
+		dot = v4fPlaneDist( inPoints[i], plane );
+		dists[i] = s4fToFloat(dot);
+		if ( dists[i] > epsilon ) {
+			sides[i] = SIDE_FRONT;
+		} else if ( dists[i] < -epsilon ) {
+			sides[i] = SIDE_BACK;
+		} else {
+			sides[i] = SIDE_ON;
+		}
+		counts[sides[i]]++;
+	}
+	sides[i] = sides[0];
+	dists[i] = dists[0];
+
+	*numOutPoints = 0;
+
+	if ( !counts[0] ) {
+		return;
+	}
+	if ( !counts[1] ) {
+		*numOutPoints = numInPoints;
+		Com_Memcpy( outPoints, inPoints, numInPoints * sizeof(v4f) );
+		return;
+	}
+
+	for ( i = 0 ; i < numInPoints ; i++ ) {
+		p1 = inPoints[i];
+		clip = &outPoints[ *numOutPoints ];
+		
+		if ( sides[i] == SIDE_ON ) {
+			*clip = p1;
+			(*numOutPoints)++;
+			continue;
+		}
+	
+		if ( sides[i] == SIDE_FRONT ) {
+			*clip = p1;
+			(*numOutPoints)++;
+			clip = &outPoints[ *numOutPoints ];
+		}
+
+		if ( sides[i+1] == SIDE_ON || sides[i+1] == sides[i] ) {
+			continue;
+		}
+			
+		// generate a split point
+		p2 = inPoints[ (i+1) % numInPoints ];
+
+		d = dists[i] - dists[i+1];
+		if ( d == 0 ) {
+			dot = v4fZero;
+		} else {
+			dot = s4fInit(dists[i] / d);
+		}
+
+		// clip xyz
+		*clip = v4fLerp( dot, p1, p2 );
+		(*numOutPoints)++;
+	}
+}
+#endif
 static void R_ChopPolyBehindPlane( int numInPoints, vec3_t inPoints[MAX_VERTS_ON_POLY],
 								   int *numOutPoints, vec3_t outPoints[MAX_VERTS_ON_POLY], 
 							vec3_t normal, vec_t dist, vec_t epsilon) {
@@ -132,6 +218,62 @@
 
 =================
 */
+#if id386_sse >= 1
+void R_BoxSurfaces_r_sse(mnode_t *node, v4f mins, v4f maxs, surfaceType_t **list, int listsize, int *listlength, v4f dir) {
+
+	int			s, c;
+	msurface_t	*surf, **mark;
+
+	// do the tail recursion in a loop
+	while ( node->contents == -1 ) {
+		s = v4fBoxOnPlaneSide( mins, maxs, v4fLoadU(node->plane->normal) );
+		if (s == 1) {
+			node = node->children[0];
+		} else if (s == 2) {
+			node = node->children[1];
+		} else {
+			R_BoxSurfaces_r_sse(node->children[0], mins, maxs, list, listsize, listlength, dir);
+			node = node->children[1];
+		}
+	}
+
+	// add the individual surfaces
+	mark = node->firstmarksurface;
+	c = node->nummarksurfaces;
+	while (c--) {
+		//
+		if (*listlength >= listsize) break;
+		//
+		surf = *mark;
+		// check if the surface has NOIMPACT or NOMARKS set
+		if ( ( surf->shader->surfaceFlags & ( SURF_NOIMPACT | SURF_NOMARKS ) )
+			|| ( surf->shader->contentFlags & CONTENTS_FOG ) ) {
+			surf->viewCount = tr.viewCount;
+		}
+		// extra check for surfaces to avoid list overflows
+		else if (*(surf->data) == SF_FACE) {
+			// the face plane should go through the box
+			s = v4fBoxOnPlaneSide( mins, maxs,
+					       v4fLoadU((( srfSurfaceFace_t * ) surf->data)->plane.normal) );
+			if (s == 1 || s == 2) {
+				surf->viewCount = tr.viewCount;
+			} else if (v4fAny(v4fGt(v4fDotProduct(vec3Load((( srfSurfaceFace_t * ) surf->data)->plane.normal), dir),v4fMZeroDotFive))) {
+			// don't add faces that make sharp angles with the projection direction
+				surf->viewCount = tr.viewCount;
+			}
+		}
+		else if (*(surfaceType_t *) (surf->data) != SF_GRID) surf->viewCount = tr.viewCount;
+		// check the viewCount because the surface may have
+		// already been added if it spans multiple leafs
+		if (surf->viewCount != tr.viewCount) {
+			surf->viewCount = tr.viewCount;
+			list[*listlength] = (surfaceType_t *) surf->data;
+			(*listlength)++;
+		}
+		mark++;
+	}
+}
+#endif
 void R_BoxSurfaces_r(mnode_t *node, vec3_t mins, vec3_t maxs, surfaceType_t **list, int listsize, int *listlength, vec3_t dir) {
 
 	int			s, c;
@@ -192,6 +334,61 @@
 
 =================
 */
+#if id386_sse >= 1
+void R_AddMarkFragments_sse(int numClipPoints, v4f clipPoints[2][MAX_VERTS_ON_POLY],
+			    int numPlanes, v4f *planes,
+			    int maxPoints, vec3_t pointBuffer,
+			    int maxFragments, markFragment_t *fragmentBuffer,
+			    int *returnedPoints, int *returnedFragments,
+			    v4f mins, v4f maxs) {
+	int pingPong, i;
+	markFragment_t	*mf;
+
+	// chop the surface by all the bounding planes of the to be projected polygon
+	pingPong = 0;
+
+	for ( i = 0 ; i < numPlanes ; i++ ) {
+
+		R_ChopPolyBehindPlane_sse( numClipPoints, clipPoints[pingPong],
+					   &numClipPoints, clipPoints[!pingPong],
+					   planes[i], 0.5 );
+		pingPong ^= 1;
+		if ( numClipPoints == 0 ) {
+			break;
+		}
+	}
+	// completely clipped away?
+	if ( numClipPoints == 0 ) {
+		return;
+	}
+
+	// add this fragment to the returned list
+	if ( numClipPoints + (*returnedPoints) > maxPoints ) {
+		return;	// not enough space for this polygon
+	}
+	/*
+	// all the clip points should be within the bounding box
+	for ( i = 0 ; i < numClipPoints ; i++ ) {
+		int j;
+		for ( j = 0 ; j < 3 ; j++ ) {
+			if (clipPoints[pingPong][i][j] < mins[j] - 0.5) break;
+			if (clipPoints[pingPong][i][j] > maxs[j] + 0.5) break;
+		}
+		if (j < 3) break;
+	}
+	if (i < numClipPoints) return;
+	*/
+
+	mf = fragmentBuffer + (*returnedFragments);
+	mf->firstPoint = (*returnedPoints);
+	mf->numPoints = numClipPoints;
+	for ( i = 0; i < numClipPoints; i++ ) {
+		Com_Memcpy( pointBuffer + (*returnedPoints) * 3, &clipPoints[pingPong][i], sizeof(vec3_t) );
+		(*returnedPoints) ++;
+	}
+	(*returnedFragments)++;
+}
+#endif
 void R_AddMarkFragments(int numClipPoints, vec3_t clipPoints[2][MAX_VERTS_ON_POLY],
 				   int numPlanes, vec3_t *normals, float *dists,
 				   int maxPoints, vec3_t pointBuffer,
@@ -251,6 +448,205 @@
 
 =================
 */
+#if id386_sse >= 1
+int R_MarkFragments_sse( int numPoints, const vec3_t *points, const vec3_t projection,
+			 int maxPoints, vec3_t pointBuffer, int maxFragments, markFragment_t *fragmentBuffer ) {
+	int				numsurfaces, numPlanes;
+	int				i, j, k, m, n;
+	surfaceType_t	*surfaces[64];
+	v4f			mins, maxs;
+	int				returnedFragments;
+	int				returnedPoints;
+	v4f		planes[MAX_VERTS_ON_POLY+2];
+	v4f			clipPoints[2][MAX_VERTS_ON_POLY];
+	int				numClipPoints;
+	float			*v;
+	srfSurfaceFace_t *surf;
+	srfGridMesh_t	*cv;
+	drawVert_t		*dv;
+	v4f			normal;
+	v4f			projectionVec, projectionDir;
+	v4f			v1, v2;
+	s4f                     MO;
+	int				*indexes;
+
+	//increment view count for double check prevention
+	tr.viewCount++;
+
+	//
+	projectionVec = vec3Load( projection );
+	projectionDir = v4fVectorNormalize( projectionVec );
+	MO = s4fInit( MARKER_OFFSET );
+	
+	// find all the brushes that are to be considered
+	mins = s4fInit( 99999 );
+	maxs = s4fInit( -99999 );
+	for ( i = 0 ; i < numPoints ; i++ ) {
+		v4f	point, temp;
+
+		point = vec3Load( points[i] );
+		temp = v4fAdd( point, projectionVec );
+		mins = v4fMin( mins, temp ); maxs = v4fMax( maxs, temp );
+		// make sure we get all the leafs (also the one(s) in front of the hit surface)
+		temp = v4fMA( point, s4fInit(-20), projectionDir );
+		mins = v4fMin( mins, temp ); maxs = v4fMax( maxs, temp );
+	}
+
+	if (numPoints > MAX_VERTS_ON_POLY) numPoints = MAX_VERTS_ON_POLY;
+	// create the bounding planes for the to be projected polygon
+	for ( i = 0 ; i < numPoints ; i++ ) {
+		v4f	point, nextPoint;
+
+		point = vec3Load(points[i]);
+		nextPoint = vec3Load(points[(i+1)%numPoints]);
+		v1 = v4fSub( nextPoint, point );
+		v2 = v4fAdd( point, projectionVec );
+		v2 = v4fSub( point, v2 );
+		v2 = v4fCrossProduct( v1, v2 );
+		v2 = v4fVectorNormalize( v2 );
+		planes[i] = v4fMix( v2, v4fDotProduct( v2, point ), mixMask0001 );
+	}
+	// add near and far clipping planes for projection
+	v1 = vec3Load( points[0] );
+	v2 = projectionDir;
+	planes[numPoints] = v4fMix( v2, v4fSub(v4fDotProduct( v2, v1 ), s4fInit(32) ), mixMask0001 );
+	v2 = v4fNeg( projectionDir );
+	planes[numPoints + 1] =  v4fMix( v2, v4fSub(v4fDotProduct( v2, v1 ), s4fInit(20) ), mixMask0001 );
+	numPlanes = numPoints + 2;
+
+	numsurfaces = 0;
+	R_BoxSurfaces_r_sse(tr.world->nodes, mins, maxs, surfaces, 64, &numsurfaces, projectionDir);
+	//assert(numsurfaces <= 64);
+	//assert(numsurfaces != 64);
+
+	returnedPoints = 0;
+	returnedFragments = 0;
+
+	for ( i = 0 ; i < numsurfaces ; i++ ) {
+
+		if (*surfaces[i] == SF_GRID) {
+
+			cv = (srfGridMesh_t *) surfaces[i];
+			for ( m = 0 ; m < cv->height - 1 ; m++ ) {
+				for ( n = 0 ; n < cv->width - 1 ; n++ ) {
+					// We triangulate the grid and chop all triangles within
+					// the bounding planes of the to be projected polygon.
+					// LOD is not taken into account, not such a big deal though.
+					//
+					// It's probably much nicer to chop the grid itself and deal
+					// with this grid as a normal SF_GRID surface so LOD will
+					// be applied. However the LOD of that chopped grid must
+					// be synced with the LOD of the original curve.
+					// One way to do this; the chopped grid shares vertices with
+					// the original curve. When LOD is applied to the original
+					// curve the unused vertices are flagged. Now the chopped curve
+					// should skip the flagged vertices. This still leaves the
+					// problems with the vertices at the chopped grid edges.
+					//
+					// To avoid issues when LOD applied to "hollow curves" (like
+					// the ones around many jump pads) we now just add a 2 unit
+					// offset to the triangle vertices.
+					// The offset is added in the vertex normal vector direction
+					// so all triangles will still fit together.
+					// The 2 unit offset should avoid pretty much all LOD problems.
+
+					numClipPoints = 3;
+
+					dv = cv->verts + m * cv->width + n;
+
+					clipPoints[0][0] = v4fMA( vec3Load(dv[0].xyz), MO, vec3Load(dv[0].normal) );
+					clipPoints[0][1] = v4fMA( vec3Load(dv[cv->width].xyz), MO, vec3Load(dv[cv->width].normal) );
+					clipPoints[0][2] = v4fMA( vec3Load(dv[1].xyz), MO, vec3Load(dv[1].normal) );
+					// check the normal of this triangle
+					v1 = v4fSub(clipPoints[0][0], clipPoints[0][1]);
+					v2 = v4fSub(clipPoints[0][2], clipPoints[0][1]);
+					normal = v4fCrossProduct(v1, v2);
+					normal = v4fVectorNormalize(normal);
+					if (v4fAny(v4fLt(v4fDotProduct(normal, projectionDir),v4fMZeroDotOne)) ) {
+						// add the fragments of this triangle
+						R_AddMarkFragments_sse(numClipPoints, clipPoints,
+								       numPlanes, planes,
+								       maxPoints, pointBuffer,
+								       maxFragments, fragmentBuffer,
+								       &returnedPoints, &returnedFragments, mins, maxs);
+
+						if ( returnedFragments == maxFragments ) {
+							return returnedFragments;	// not enough space for more fragments
+						}
+					}
+
+					clipPoints[0][0] = v4fMA( vec3Load(dv[1].xyz), MO, vec3Load(dv[1].normal) );
+					clipPoints[0][1] = v4fMA( vec3Load(dv[cv->width].xyz), MO, vec3Load(dv[cv->width].normal) );
+					clipPoints[0][2] = v4fMA( vec3Load(dv[cv->width+1].xyz), MO, vec3Load(dv[cv->width+1].normal) );
+
+					// check the normal of this triangle
+					v1 = v4fSub(clipPoints[0][0], clipPoints[0][1]);
+					v2 = v4fSub(clipPoints[0][2], clipPoints[0][1]);
+					normal = v4fCrossProduct(v1, v2);
+					normal = v4fVectorNormalize(normal);
+					if (v4fAny(v4fLt(v4fDotProduct(normal, projectionDir), s4fInit(-0.05))) ) {
+						// add the fragments of this triangle
+						R_AddMarkFragments_sse(numClipPoints, clipPoints,
+								       numPlanes, planes,
+								       maxPoints, pointBuffer,
+								       maxFragments, fragmentBuffer,
+								       &returnedPoints, &returnedFragments, mins, maxs);
+
+						if ( returnedFragments == maxFragments ) {
+							return returnedFragments;	// not enough space for more fragments
+						}
+					}
+				}
+			}
+		}
+		else if (*surfaces[i] == SF_FACE) {
+			v4f normal;
+
+			surf = ( srfSurfaceFace_t * ) surfaces[i];
+			normal = vec3Load(surf->plane.normal);
+
+			// check the normal of this face
+			if (v4fAny(v4fGt(v4fDotProduct(normal, projectionDir), v4fMZeroDotFive)) ) {
+				continue;
+			}
+
+			/*
+			VectorSubtract(clipPoints[0][0], clipPoints[0][1], v1);
+			VectorSubtract(clipPoints[0][2], clipPoints[0][1], v2);
+			CrossProduct(v1, v2, normal);
+			VectorNormalize(normal);
+			if (DotProduct(normal, projectionDir) > -0.5) continue;
+			*/
+			indexes = (int *)( (byte *)surf + surf->ofsIndices );
+			for ( k = 0 ; k < surf->numIndices ; k += 3 ) {
+				for ( j = 0 ; j < 3 ; j++ ) {
+					v = surf->points[0] + VERTEXSIZE * indexes[k+j];;
+					clipPoints[0][j] = v4fMA( vec3Load(v), MO, normal );
+				}
+				// add the fragments of this face
+				R_AddMarkFragments_sse( 3 , clipPoints,
+							numPlanes, planes,
+							maxPoints, pointBuffer,
+							maxFragments, fragmentBuffer,
+							&returnedPoints, &returnedFragments, mins, maxs);
+				if ( returnedFragments == maxFragments ) {
+					return returnedFragments;	// not enough space for more fragments
+				}
+			}
+			continue;
+		}
+		else {
+			// ignore all other world surfaces
+			// might be cool to also project polygons on a triangle soup
+			// however this will probably create huge amounts of extra polys
+			// even more than the projection onto curves
+			continue;
+		}
+	}
+	return returnedFragments;
+}
+
+#endif
 int R_MarkFragments( int numPoints, const vec3_t *points, const vec3_t projection,
 				   int maxPoints, vec3_t pointBuffer, int maxFragments, markFragment_t *fragmentBuffer ) {
 	int				numsurfaces, numPlanes;
@@ -272,6 +668,12 @@
 	vec3_t			v1, v2;
 	int				*indexes;
 
+#if id386_sse >= 1
+	if ( com_sse->integer >= 1 )
+		return R_MarkFragments_sse( numPoints, points, projection,
+					    maxPoints, pointBuffer, maxFragments, fragmentBuffer );
+#endif
+
 	//increment view count for double check prevention
 	tr.viewCount++;
 
diff -r 11104731f8c9 -r 87f98d895296 src/renderer/tr_shade.c
--- a/src/renderer/tr_shade.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/renderer/tr_shade.c	Sun Mar 29 01:15:08 2009 +0800
@@ -164,7 +164,7 @@
 without compiled vertex arrays.
 ==================
 */
-static void R_DrawElements( int numIndexes, const glIndex_t *indexes ) {
+static void R_DrawElements( int numIndexes, const void *indexes, GLuint end, GLenum type ) {
 	int		primitives;
 
 	primitives = r_primitives->integer;
@@ -180,10 +180,17 @@
 
 
 	if ( primitives == 2 ) {
-		qglDrawElements( GL_TRIANGLES, 
-						numIndexes,
-						GL_INDEX_TYPE,
-						indexes );
+		if ( qglDrawRangeElementsEXT )
+			qglDrawRangeElementsEXT( GL_TRIANGLES, 
+						 0, end,
+						 numIndexes,
+						 type,
+						 indexes );
+		else
+			qglDrawElements( GL_TRIANGLES,
+					 numIndexes,
+					 type,
+					 indexes );
 		return;
 	}
 
@@ -201,7 +208,7 @@
 }
 
 //R_DRAWCEL
-static void R_DrawCel( int numIndexes, const glIndex_t *indexes ) {
+static void R_DrawCel( int numIndexes, const void *indexes, GLuint end, GLenum type ) {
 	int		primitives;
 	
 	if(
@@ -239,7 +246,10 @@
 	qglLineWidth( (float) r_celoutline->integer );	
 
 	if(primitives == 2) {
-		qglDrawElements( GL_TRIANGLES, numIndexes, GL_INDEX_TYPE, indexes );
+		if ( qglDrawRangeElementsEXT )
+			qglDrawRangeElementsEXT( GL_TRIANGLES, 0, end, numIndexes, type, indexes );
+		else
+			qglDrawElements( GL_TRIANGLES, numIndexes, type, indexes );
 	} else if(primitives == 1) {
 		R_DrawStripElements( numIndexes,  indexes, qglArrayElement );
 	} else if(primitives == 3) {
@@ -325,7 +335,7 @@
 }
 
 //DRAWCEL
-static void DrawCel (shaderCommands_t *input) {
+static void DrawCelVBO (vboInfo_t *VBO) {
 
 	GL_Bind( tr.whiteImage );
 	qglColor3f (1,1,1);
@@ -335,14 +345,26 @@
 	qglDisableClientState (GL_COLOR_ARRAY);
 	qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
 
-	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);	// padded for SIMD
+	R_DrawCel( VBO->numIndexes, NULL , VBO->numVertexes-1, VBO->numVertexes > 65536 ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT );
+}
+static void DrawCel ( void ) {
+
+	GL_Bind( tr.whiteImage );
+	qglColor3f (1,1,1);
+
+	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
+
+	qglDisableClientState (GL_COLOR_ARRAY);
+	qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
+
+	qglVertexPointer (3, GL_FLOAT, 16, tess.xyz);	// padded for SIMD
 
 	if (qglLockArraysEXT) {
-		qglLockArraysEXT(0, input->numVertexes);
+		qglLockArraysEXT(0, tess.numVertexes);
 		GLimp_LogComment( "glLockArraysEXT\n" );
 	}
 
-	R_DrawCel( input->numIndexes, input->indexes );
+	R_DrawCel( tess.numIndexes, tess.indexes, tess.numVertexes-1, GL_UNSIGNED_INT );
 
 	if (qglUnlockArraysEXT) {
 		qglUnlockArraysEXT();
@@ -358,7 +380,7 @@
 Draws triangle outlines for debugging
 ================
 */
-static void DrawTris (shaderCommands_t *input) {
+static void DrawTrisVBO (vboInfo_t *VBO) {
 	GL_Bind( tr.whiteImage );
 	qglColor3f (1,1,1);
 
@@ -368,14 +390,39 @@
 	qglDisableClientState (GL_COLOR_ARRAY);
 	qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
 
-	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);	// padded for SIMD
+	qglColor3f (0,0,1);
+
+	GL_VBO( VBO->vbo, VBO->ibo );
+
+	qglVertexPointer (3, GL_FLOAT, VBO_inc(tess.shader, VBO),
+			  VBO_xyz(tess.shader, VBO));
+
+	R_DrawElements( VBO->numIndexes, NULL, VBO->numVertexes-1, VBO->numVertexes > 65536 ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT );
+
+	qglDepthRange( 0, 1 );
+}
+static void DrawTris ( void ) {
+	GL_Bind( tr.whiteImage );
+	qglColor3f (1,1,1);
+
+	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
+	qglDepthRange( 0, 0 );
+
+	qglDisableClientState (GL_COLOR_ARRAY);
+	qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
+
+	qglColor3f (1,1,1);
+	
+	GL_VBO( 0, 0 );
+	
+	qglVertexPointer (3, GL_FLOAT, 16, tess.xyz);	// padded for SIMD
 
 	if (qglLockArraysEXT) {
-		qglLockArraysEXT(0, input->numVertexes);
+		qglLockArraysEXT(0, tess.numVertexes);
 		GLimp_LogComment( "glLockArraysEXT\n" );
 	}
 
-	R_DrawElements( input->numIndexes, input->indexes );
+	R_DrawElements( tess.numIndexes, tess.indexes, tess.numVertexes-1, GL_UNSIGNED_INT );
 
 	if (qglUnlockArraysEXT) {
 		qglUnlockArraysEXT();
@@ -392,7 +439,7 @@
 Draws vertex normals for debugging
 ================
 */
-static void DrawNormals (shaderCommands_t *input) {
+static void DrawNormals ( void ) {
 	int		i;
 	vec3_t	temp;
 
@@ -402,9 +449,9 @@
 	GL_State( GLS_POLYMODE_LINE | GLS_DEPTHMASK_TRUE );
 
 	qglBegin (GL_LINES);
-	for (i = 0 ; i < input->numVertexes ; i++) {
-		qglVertex3fv (input->xyz[i]);
-		VectorMA (input->xyz[i], 2, input->normal[i], temp);
+	for (i = 0 ; i < tess.numVertexes ; i++) {
+		qglVertex3fv (tess.xyz[i]);
+		VectorMA (tess.xyz[i], 2, tess.normal[i], temp);
 		qglVertex3fv (temp);
 	}
 	qglEnd ();
@@ -427,6 +474,7 @@
 
 	tess.numIndexes = 0;
 	tess.numVertexes = 0;
+	tess.renderVBO = NULL;
 	tess.shader = state;
 	tess.fogNum = fogNum;
 	tess.dlightBits = 0;		// will be OR'd in by surface functions
@@ -454,6 +502,7 @@
 */
 static void DrawMultitextured( shaderCommands_t *input, int stage ) {
 	shaderStage_t	*pStage;
+	int		bundle;
 
 	pStage = tess.xstages[stage];
 
@@ -473,31 +522,39 @@
 	R_BindAnimatedImage( &pStage->bundle[0] );
 
 	//
-	// lightmap/secondary pass
+	// lightmap/secondary passes
 	//
-	GL_SelectTexture( 1 );
-	qglEnable( GL_TEXTURE_2D );
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+	for ( bundle = 1; bundle < glConfig.numTextureUnits; bundle++ ) {
+		if ( !pStage->bundle[bundle].multitextureEnv )
+			break;
+		
+		GL_SelectTexture( bundle );
+		qglEnable( GL_TEXTURE_2D );
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+		
+		if ( r_lightmap->integer ) {
+			GL_TexEnv( GL_REPLACE );
+		} else {
+			GL_TexEnv( pStage->bundle[bundle].multitextureEnv );
+		}
 
-	if ( r_lightmap->integer ) {
-		GL_TexEnv( GL_REPLACE );
-	} else {
-		GL_TexEnv( tess.shader->multitextureEnv );
+		qglTexCoordPointer( 2, GL_FLOAT, 0, input->svars.texcoords[bundle] );
+		
+		R_BindAnimatedImage( &pStage->bundle[bundle] );
 	}
 
-	qglTexCoordPointer( 2, GL_FLOAT, 0, input->svars.texcoords[1] );
-
-	R_BindAnimatedImage( &pStage->bundle[1] );
-
-	R_DrawElements( input->numIndexes, input->indexes );
+	R_DrawElements( input->numIndexes, input->indexes, input->numVertexes-1, GL_UNSIGNED_INT );
 
 	//
-	// disable texturing on TEXTURE1, then select TEXTURE0
+	// disable texturing on TEXTURE>=1, then select TEXTURE0
 	//
+	--bundle;
+	while ( bundle > 0 ) {
 	//qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
-	qglDisable( GL_TEXTURE_2D );
-
-	GL_SelectTexture( 0 );
+		qglDisable( GL_TEXTURE_2D );
+		bundle--;
+		GL_SelectTexture( bundle );
+	}
 }
 
 
@@ -675,7 +732,7 @@
 		else {
 			GL_State( GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
 		}
-		R_DrawElements( numIndexes, hitIndexes );
+		R_DrawElements( numIndexes, hitIndexes, tess.numVertexes-1, GL_UNSIGNED_INT );
 		backEnd.pc.c_totalIndexes += numIndexes;
 		backEnd.pc.c_dlightIndexes += numIndexes;
 	}
@@ -820,7 +877,7 @@
 		else {
 			GL_State( GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_EQUAL );
 		}
-		R_DrawElements( numIndexes, hitIndexes );
+		R_DrawElements( numIndexes, hitIndexes, tess.numVertexes-1, GL_UNSIGNED_INT );
 		backEnd.pc.c_totalIndexes += numIndexes;
 		backEnd.pc.c_dlightIndexes += numIndexes;
 	}
@@ -871,7 +928,7 @@
 		GL_State( GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA );
 	}
 
-	R_DrawElements( tess.numIndexes, tess.indexes );
+	R_DrawElements( tess.numIndexes, tess.indexes, tess.numVertexes-1, GL_UNSIGNED_INT );
 }
 
 /*
@@ -1184,6 +1241,214 @@
 /*
 ** RB_IterateStagesGeneric
 */
+static void RB_IterateStagesGenericVBO( vboInfo_t *VBO )
+{
+	int stage;
+	int bundle;
+
+	if ( tess.shader->needsNormal ) {
+		qglEnableClientState( GL_NORMAL_ARRAY );
+		qglNormalPointer( GL_FLOAT, VBO_inc(tess.shader, VBO),
+				  VBO_normals(tess.shader, VBO) );
+	}
+	if (qglLockArraysEXT)
+	{
+		qglLockArraysEXT(0, VBO->numVertexes);
+		GLimp_LogComment( "glLockArraysEXT\n" );
+	}
+	
+	for ( stage = 0; stage < MAX_SHADER_STAGES; stage++ )
+	{
+		shaderStage_t *pStage = tess.xstages[stage];
+		alphaGen_t     aGen;
+		colorGen_t     rgbGen;
+
+		if ( !pStage )
+		{
+			break;
+		}
+
+		GL_State( pStage->stateBits );
+		aGen = pStage->alphaGen;
+		rgbGen = pStage->rgbGen;
+
+		// hack to enable vertex lighting - AGEN_SKIP should be ditched imho
+		if ( aGen == AGEN_SKIP ) {
+			if ( rgbGen == CGEN_EXACT_VERTEX ||
+			     rgbGen == CGEN_VERTEX ) {
+				aGen = AGEN_VERTEX;
+			}
+		}
+		
+		if ( aGen == AGEN_VERTEX ) {
+			// implies rgbGen == CGEN_EXACT_VERTEX || rgbGen == CGEN_VERTEX
+			qglEnableClientState( GL_COLOR_ARRAY );
+			qglColorPointer( 4, GL_UNSIGNED_BYTE, VBO_inc(tess.shader, VBO),
+					 VBO_colors(tess.shader,VBO) );
+		} else {
+			byte alpha = 0;
+			qglDisableClientState( GL_COLOR_ARRAY );
+			switch( aGen ) {
+			case AGEN_IDENTITY:
+				alpha = 255;
+				break;
+			case AGEN_SKIP:
+				alpha = 255;
+				break;
+			case AGEN_ENTITY:
+				if ( backEnd.currentEntity )
+					alpha = backEnd.currentEntity->e.shaderRGBA[3];
+				break;
+			case AGEN_ONE_MINUS_ENTITY:
+				if ( backEnd.currentEntity )
+					alpha = 255 - backEnd.currentEntity->e.shaderRGBA[3];
+				break;
+			case AGEN_CONST:
+				alpha = pStage->constantColor[3];
+				break;
+			default:
+				// error ?
+				break;
+			}
+
+			switch( rgbGen ) {
+			case CGEN_IDENTITY_LIGHTING:
+				qglColor4ub( tr.identityLightByte,
+					     tr.identityLightByte,
+					     tr.identityLightByte,
+					     alpha );
+				break;
+			case CGEN_IDENTITY:
+				qglColor4ub( 255, 255, 255, alpha );
+				break;
+			case CGEN_ENTITY:
+				if ( backEnd.currentEntity )
+					qglColor4ub( backEnd.currentEntity->e.shaderRGBA[0],
+						     backEnd.currentEntity->e.shaderRGBA[1],
+						     backEnd.currentEntity->e.shaderRGBA[2],
+						     alpha );
+				break;
+			case CGEN_ONE_MINUS_ENTITY:
+				if ( backEnd.currentEntity )
+					qglColor4ub( 255 - backEnd.currentEntity->e.shaderRGBA[0],
+						     255 - backEnd.currentEntity->e.shaderRGBA[1],
+						     255 - backEnd.currentEntity->e.shaderRGBA[2],
+						     alpha );
+				break;
+			case CGEN_CONST:
+				qglColor4ub( pStage->constantColor[0],
+					     pStage->constantColor[1],
+					     pStage->constantColor[2],
+					     alpha );
+				break;
+			default:
+				// error ?
+				break;
+			}
+		}
+
+		//
+		// set state
+		//
+		if ( pStage->bundle[0].vertexLightmap && ( (r_vertexLight->integer && !r_uiFullScreen->integer) || glConfig.hardwareType == GLHW_PERMEDIA2 ) && r_lightmap->integer )
+		{
+			GL_Bind( tr.whiteImage );
+		}
+		else 
+			R_BindAnimatedImage( &pStage->bundle[0] );
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
+		switch ( pStage->bundle[0].tcGen ) {
+		case TCGEN_TEXTURE:
+			qglTexCoordPointer( 2, GL_FLOAT, VBO_inc(tess.shader, VBO),
+					    VBO_tc1(tess.shader, VBO) );
+			break;
+		case TCGEN_LIGHTMAP:
+			qglTexCoordPointer( 2, GL_FLOAT, VBO_inc(tess.shader, VBO),
+					    VBO_tc2(tess.shader, VBO) );
+			break;
+		default:
+			//error ?
+			break;
+		}
+		
+		//
+		// do multitexture
+		//
+		for ( bundle = 1; bundle < glConfig.numTextureUnits; bundle++ ) {
+			if ( !pStage->bundle[bundle].multitextureEnv )
+				break;
+
+			// this is an ugly hack to work around a GeForce driver
+			// bug with multitexture and clip planes
+			if ( backEnd.viewParms.isPortal ) {
+				qglPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
+			}
+			
+			//
+			// lightmap/secondary pass
+			//
+			GL_SelectTexture( bundle );
+			qglEnable( GL_TEXTURE_2D );
+			qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+			switch ( pStage->bundle[bundle].tcGen ) {
+			case TCGEN_TEXTURE:
+				qglTexCoordPointer( 2, GL_FLOAT, VBO_inc(tess.shader, VBO),
+						    VBO_tc1(tess.shader, VBO) );
+				break;
+			case TCGEN_LIGHTMAP:
+				qglTexCoordPointer( 2, GL_FLOAT, VBO_inc(tess.shader, VBO),
+						    VBO_tc2(tess.shader, VBO) );
+				break;
+			default:
+				// error ?
+				break;
+			}
+			
+			if ( r_lightmap->integer ) {
+				GL_TexEnv( GL_REPLACE );
+			} else {
+				GL_TexEnv( pStage->bundle[bundle].multitextureEnv );
+			}
+			R_BindAnimatedImage( &pStage->bundle[bundle] );
+		}
+		
+		if ( qglDrawRangeElementsEXT )
+			qglDrawRangeElementsEXT( GL_TRIANGLES,
+						 0, VBO->numVertexes-1,
+						 VBO->numIndexes,
+						 VBO->numVertexes > 65536 ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT,
+						 NULL );
+		else
+			qglDrawElements( GL_TRIANGLES, VBO->numIndexes,
+					 GL_INDEX_TYPE, NULL );
+		
+		//
+		// disable texturing on TEXTURE1, then select TEXTURE0
+		//
+		bundle--;
+		while ( bundle > 0 ) {
+			qglDisable( GL_TEXTURE_COORD_ARRAY );
+			qglDisable( GL_TEXTURE_2D );
+			bundle--;
+			GL_SelectTexture( bundle );
+		}
+
+		// allow skipping out to show just lightmaps during development
+		if ( r_lightmap->integer && ( pStage->bundle[0].isLightmap || pStage->bundle[1].isLightmap || pStage->bundle[0].vertexLightmap ) )
+		{
+			break;
+		}
+	}
+
+	if (qglUnlockArraysEXT) 
+	{
+		qglUnlockArraysEXT();
+		GLimp_LogComment( "glUnlockArraysEXT\n" );
+	}
+	
+	if ( tess.shader->needsNormal )
+		qglDisableClientState( GL_NORMAL_ARRAY );
+}
 static void RB_IterateStagesGeneric( shaderCommands_t *input )
 {
 	int stage;
@@ -1235,7 +1500,7 @@
 			//
 			// draw
 			//
-			R_DrawElements( input->numIndexes, input->indexes );
+			R_DrawElements( input->numIndexes, input->indexes, input->numVertexes-1, GL_UNSIGNED_INT );
 		}
 		// allow skipping out to show just lightmaps during development
 		if ( r_lightmap->integer && ( pStage->bundle[0].isLightmap || pStage->bundle[1].isLightmap || pStage->bundle[0].vertexLightmap ) )
@@ -1282,80 +1547,99 @@
 	//. show me cel outlines.
 	//. there has to be a better place to put this.
 	if(r_celoutline->integer > 0) {
-		DrawCel(&tess);
+		if ( tess.numIndexes > 0 )
+			DrawCel();
 	}
 
-	//
-	// if there is only a single pass then we can enable color
-	// and texture arrays before we compile, otherwise we need
-	// to avoid compiling those arrays since they will change
-	// during multipass rendering
-	//
-	if ( tess.numPasses > 1 || input->shader->multitextureEnv )
-	{
-		setArraysOnce = qfalse;
-		qglDisableClientState (GL_COLOR_ARRAY);
-		qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
-	}
-	else
-	{
-		setArraysOnce = qtrue;
+	if ( tess.renderVBO ) {
+		GL_VBO( tess.renderVBO->vbo, tess.renderVBO->ibo );
 
-		qglEnableClientState( GL_COLOR_ARRAY);
-		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
+		qglVertexPointer (3, GL_FLOAT, VBO_inc(tess.shader, tess.renderVBO),
+				  VBO_xyz(tess.shader, tess.renderVBO));
 
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
-		qglTexCoordPointer( 2, GL_FLOAT, 0, tess.svars.texcoords[0] );
+		if(r_celoutline->integer > 0) {
+			if ( tess.renderVBO )
+				DrawCelVBO( tess.renderVBO );
+		}
+
+		RB_IterateStagesGenericVBO( tess.renderVBO );
 	}
 
-	//
-	// lock XYZ
-	//
-	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);	// padded for SIMD
-	if (qglLockArraysEXT)
-	{
-		qglLockArraysEXT(0, input->numVertexes);
-		GLimp_LogComment( "glLockArraysEXT\n" );
+	if ( tess.numIndexes > 0 ) {
+		//
+
+		GL_VBO( 0, 0 );
+
+		// if there is only a single pass then we can enable color
+		// and texture arrays before we compile, otherwise we need
+		// to avoid compiling those arrays since they will change
+		// during multipass rendering
+		//
+		if ( tess.numPasses > 1 || (tess.numPasses > 0 && input->shader->stages[0]->bundle[1].multitextureEnv) )
+		{
+			setArraysOnce = qfalse;
+			qglDisableClientState (GL_COLOR_ARRAY);
+			qglDisableClientState (GL_TEXTURE_COORD_ARRAY);
+		}
+		else
+		{
+			setArraysOnce = qtrue;
+			
+			qglEnableClientState( GL_COLOR_ARRAY);
+			qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
+			
+			qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
+			qglTexCoordPointer( 2, GL_FLOAT, 0, tess.svars.texcoords[0] );
+		}
+		
+		//
+		// lock XYZ
+		//
+		qglVertexPointer (3, GL_FLOAT, 16, input->xyz);	// padded for SIMD
+		if (qglLockArraysEXT)
+		{
+			qglLockArraysEXT(0, input->numVertexes);
+			GLimp_LogComment( "glLockArraysEXT\n" );
+		}
+		
+		//
+		// enable color and texcoord arrays after the lock if necessary
+		//
+		if ( !setArraysOnce )
+		{
+			qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+			qglEnableClientState( GL_COLOR_ARRAY );
+		}
+		
+		//
+		// call shader function
+		//
+		RB_IterateStagesGeneric( input );
+		
+		// 
+		// now do any dynamic lighting needed
+		//
+		if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE
+		     && !(tess.shader->surfaceFlags & (SURF_NODLIGHT | SURF_SKY) ) ) {
+			ProjectDlightTexture();
+		}
+		
+		//
+		// now do fog
+		//
+		if ( tess.fogNum && tess.shader->fogPass ) {
+			RB_FogPass();
+		}
+		
+		// 
+		// unlock arrays
+		//
+		if (qglUnlockArraysEXT) 
+		{
+			qglUnlockArraysEXT();
+			GLimp_LogComment( "glUnlockArraysEXT\n" );
+		}
 	}
-
-	//
-	// enable color and texcoord arrays after the lock if necessary
-	//
-	if ( !setArraysOnce )
-	{
-		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglEnableClientState( GL_COLOR_ARRAY );
-	}
-
-	//
-	// call shader function
-	//
-	RB_IterateStagesGeneric( input );
-
-	// 
-	// now do any dynamic lighting needed
-	//
-	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE
-		&& !(tess.shader->surfaceFlags & (SURF_NODLIGHT | SURF_SKY) ) ) {
-		ProjectDlightTexture();
-	}
-
-	//
-	// now do fog
-	//
-	if ( tess.fogNum && tess.shader->fogPass ) {
-		RB_FogPass();
-	}
-
-	// 
-	// unlock arrays
-	//
-	if (qglUnlockArraysEXT) 
-	{
-		qglUnlockArraysEXT();
-		GLimp_LogComment( "glUnlockArraysEXT\n" );
-	}
-
 	//
 	// reset polygon offset
 	//
@@ -1398,50 +1682,77 @@
 	//
 	GL_Cull( input->shader->cullType );
 
+	R_BindAnimatedImage( &tess.xstages[0]->bundle[0] );
+	GL_State( tess.xstages[0]->stateBits );
+
 	//
 	// set arrays and lock
 	//
-	qglEnableClientState( GL_COLOR_ARRAY);
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
+	if ( input->renderVBO ) {
+		GL_VBO( input->renderVBO->vbo, input->renderVBO->ibo );
 
-	qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
-	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][0] );
-	qglVertexPointer (3, GL_FLOAT, 16, input->xyz);
+		qglEnableClientState( GL_COLOR_ARRAY);
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
+		
+		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0,
+				 (byte *)NULL +
+				 input->renderVBO->numVertexes *
+				 (sizeof(vec4_t) + sizeof(vec4_t) + sizeof(vec2_t) + sizeof(vec2_t)) );
+		qglTexCoordPointer( 2, GL_FLOAT, 8, 
+				    (byte *)NULL +
+				    input->renderVBO->numVertexes *
+				    (sizeof(vec4_t) + sizeof(vec4_t)) );
+		qglVertexPointer (3, GL_FLOAT, 16, NULL);
+		
+		//
+		// call special shade routine
+		//
+		R_DrawElements( input->renderVBO->numIndexes, NULL, input->renderVBO->numVertexes-1, input->renderVBO->numVertexes > 65536 ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT );
+	}
+	if ( input->numIndexes > 0 ) {
+		GL_VBO( 0, 0 );
+		
+		qglEnableClientState( GL_COLOR_ARRAY);
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY);
+		
+		qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.svars.colors );
+		qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][0] );
+		qglVertexPointer (3, GL_FLOAT, 16, input->xyz);
+		
+		//
+		// lock arrays
+		//
+		if ( qglLockArraysEXT ) {
+			qglLockArraysEXT(0, input->numVertexes);
+			GLimp_LogComment( "glLockArraysEXT\n" );
+		}
+		
+		//
+		// call special shade routine
+		//
+		R_DrawElements( input->numIndexes, input->indexes, input->numVertexes-1, GL_UNSIGNED_INT );
 
-	if ( qglLockArraysEXT )
-	{
-		qglLockArraysEXT(0, input->numVertexes);
-		GLimp_LogComment( "glLockArraysEXT\n" );
-	}
+		// 
+		// now do any dynamic lighting needed
+		//
+		if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE ) {
+			ProjectDlightTexture();
+		}
+		
+		//
+		// now do fog
+		//
+		if ( tess.fogNum && tess.shader->fogPass ) {
+			RB_FogPass();
+		}
 
-	//
-	// call special shade routine
-	//
-	R_BindAnimatedImage( &tess.xstages[0]->bundle[0] );
-	GL_State( tess.xstages[0]->stateBits );
-	R_DrawElements( input->numIndexes, input->indexes );
-
-	// 
-	// now do any dynamic lighting needed
-	//
-	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE ) {
-		ProjectDlightTexture();
-	}
-
-	//
-	// now do fog
-	//
-	if ( tess.fogNum && tess.shader->fogPass ) {
-		RB_FogPass();
-	}
-
-	// 
-	// unlock arrays
-	//
-	if (qglUnlockArraysEXT) 
-	{
-		qglUnlockArraysEXT();
-		GLimp_LogComment( "glUnlockArraysEXT\n" );
+		//
+		// unlock arrays
+		//
+		if ( qglUnlockArraysEXT ) {
+			qglUnlockArraysEXT();
+			GLimp_LogComment( "glUnlockArraysEXT\n" );
+		}
 	}
 }
 
@@ -1466,11 +1777,7 @@
 	//
 	GL_Cull( input->shader->cullType );
 
-	//
-	// set color, pointers, and lock
-	//
 	GL_State( GLS_DEFAULT );
-	qglVertexPointer( 3, GL_FLOAT, 16, input->xyz );
 
 #ifdef REPLACE_MODE
 	qglDisableClientState( GL_COLOR_ARRAY );
@@ -1480,19 +1787,9 @@
 	qglEnableClientState( GL_COLOR_ARRAY );
 	qglColorPointer( 4, GL_UNSIGNED_BYTE, 0, tess.constantColor255 );
 #endif
-
-	//
-	// select base stage
-	//
 	GL_SelectTexture( 0 );
-
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
 	R_BindAnimatedImage( &tess.xstages[0]->bundle[0] );
-	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][0] );
-
-	//
-	// configure second stage
-	//
+	
 	GL_SelectTexture( 1 );
 	qglEnable( GL_TEXTURE_2D );
 	if ( r_lightmap->integer ) {
@@ -1501,51 +1798,117 @@
 		GL_TexEnv( GL_MODULATE );
 	}
 	R_BindAnimatedImage( &tess.xstages[0]->bundle[1] );
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-	qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][1] );
 
-	//
-	// lock arrays
-	//
-	if ( qglLockArraysEXT ) {
-		qglLockArraysEXT(0, input->numVertexes);
-		GLimp_LogComment( "glLockArraysEXT\n" );
+	if ( tess.renderVBO ) {
+		GL_VBO( input->renderVBO->vbo, input->renderVBO->ibo );
+		//
+		// set color, pointers, and lock
+		//
+		qglVertexPointer( 3, GL_FLOAT, 16, NULL );
+		
+		//
+		// select base stage
+		//
+		GL_SelectTexture( 0 );
+		
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+		qglTexCoordPointer( 2, GL_FLOAT, 8,
+				    (byte *)NULL +
+				    input->renderVBO->numVertexes *
+				    (sizeof(vec4_t) + sizeof(vec4_t)) );
+		
+		//
+		// configure second stage
+		//
+		GL_SelectTexture( 1 );
+		qglEnable( GL_TEXTURE_2D );
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+		qglTexCoordPointer( 2, GL_FLOAT, 8,
+				    (byte *)NULL +
+				    input->renderVBO->numVertexes *
+				    (sizeof(vec4_t) + sizeof(vec4_t) + sizeof(vec2_t)) );
+		
+		R_DrawElements( input->renderVBO->numIndexes, NULL, input->renderVBO->numVertexes-1, input->renderVBO->numVertexes > 65536 ? GL_UNSIGNED_INT : GL_UNSIGNED_SHORT );
+		
+		//
+		// disable texturing on TEXTURE1, then select TEXTURE0
+		//
+		qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
+		qglDisable( GL_TEXTURE_2D );
+
+		GL_SelectTexture( 0 );
+#ifdef REPLACE_MODE
+		GL_TexEnv( GL_MODULATE );
+		qglShadeModel( GL_SMOOTH );
+#endif
 	}
+	if ( tess.numIndexes > 0 ) {
+		GL_VBO( 0, 0 );
 
-	R_DrawElements( input->numIndexes, input->indexes );
+		//
+		// set color, pointers, and lock
+		//
+		qglVertexPointer( 3, GL_FLOAT, 16, input->xyz );
+		
+		//
+		// select base stage
+		//
+		GL_SelectTexture( 0 );
+		
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+		qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][0] );
+		
+		//
+		// configure second stage
+		//
+		GL_SelectTexture( 1 );
+		qglEnable( GL_TEXTURE_2D );
+		qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
+		qglTexCoordPointer( 2, GL_FLOAT, 16, tess.texCoords[0][1] );
+		
+		//
+		// lock arrays
+		//
+		if ( qglLockArraysEXT ) {
+			qglLockArraysEXT(0, input->numVertexes);
+			GLimp_LogComment( "glLockArraysEXT\n" );
+		}
+		
+		R_DrawElements( input->numIndexes, input->indexes, input->numVertexes-1, GL_UNSIGNED_INT );
+		
+		//
+		// disable texturing on TEXTURE1, then select TEXTURE0
+		//
+		qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
+		qglDisable( GL_TEXTURE_2D );
+		
+		GL_SelectTexture( 0 );
+#ifdef REPLACE_MODE
+		GL_TexEnv( GL_MODULATE );
+		qglShadeModel( GL_SMOOTH );
+#endif
+		
+		// 
+		// now do any dynamic lighting needed
+		//
+		if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE ) {
+			ProjectDlightTexture();
+		}
+		
+		//
+		// now do fog
+		//
+		if ( tess.fogNum && tess.shader->fogPass ) {
+			RB_FogPass();
+		}
 
-	//
-	// disable texturing on TEXTURE1, then select TEXTURE0
-	//
-	qglDisable( GL_TEXTURE_2D );
-	qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
-
-	GL_SelectTexture( 0 );
-#ifdef REPLACE_MODE
-	GL_TexEnv( GL_MODULATE );
-	qglShadeModel( GL_SMOOTH );
-#endif
-
-	// 
-	// now do any dynamic lighting needed
-	//
-	if ( tess.dlightBits && tess.shader->sort <= SS_OPAQUE ) {
-		ProjectDlightTexture();
-	}
-
-	//
-	// now do fog
-	//
-	if ( tess.fogNum && tess.shader->fogPass ) {
-		RB_FogPass();
-	}
-
-	//
-	// unlock arrays
-	//
-	if ( qglUnlockArraysEXT ) {
-		qglUnlockArraysEXT();
-		GLimp_LogComment( "glUnlockArraysEXT\n" );
+		//
+		// unlock arrays
+		//
+		if ( qglUnlockArraysEXT ) {
+			qglUnlockArraysEXT();
+			GLimp_LogComment( "glUnlockArraysEXT\n" );
+		}
 	}
 }
 
@@ -1557,7 +1920,7 @@
 
 	input = &tess;
 
-	if (input->numIndexes == 0) {
+	if (input->numIndexes == 0 && !input->renderVBO ) {
 		return;
 	}
 
@@ -1595,13 +1958,21 @@
 	// draw debugging stuff
 	//
 	if ( r_showtris->integer ) {
-		DrawTris (input);
+		if ( input->renderVBO )
+			DrawTrisVBO (input->renderVBO);
+		if ( input->numIndexes > 0 )
+			DrawTris ();
 	}
 	if ( r_shownormals->integer ) {
-		DrawNormals (input);
+		DrawNormals ();
 	}
+	if ( r_flush->integer ) {
+		qglFlush();
+	}
+
 	// clear shader so we can tell we don't have any unclosed surfaces
 	tess.numIndexes = 0;
+	tess.renderVBO = NULL;
 
 	GLimp_LogComment( "----------\n" );
 }
diff -r 11104731f8c9 -r 87f98d895296 src/renderer/tr_shader.c
--- a/src/renderer/tr_shader.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/renderer/tr_shader.c	Sun Mar 29 01:15:08 2009 +0800
@@ -835,7 +835,10 @@
 			}
 			else if ( !Q_stricmp( token, "identityLighting" ) )
 			{
-				stage->rgbGen = CGEN_IDENTITY_LIGHTING;
+				if ( r_overBrightBits->integer == 0 )
+					stage->rgbGen = CGEN_IDENTITY;
+				else
+					stage->rgbGen = CGEN_IDENTITY_LIGHTING;
 			}
 			else if ( !Q_stricmp( token, "entity" ) )
 			{
@@ -1010,6 +1013,35 @@
 		}
 	}
 
+	// I assume DST_ALPHA is always 1, so I just replace it with GL_ONE
+	if ( blendSrcBits == GLS_SRCBLEND_DST_ALPHA )
+		blendSrcBits = GLS_SRCBLEND_ONE;
+	else if ( blendSrcBits == GLS_SRCBLEND_ONE_MINUS_DST_ALPHA )
+		blendSrcBits = GLS_SRCBLEND_ZERO;
+
+	if ( blendDstBits == GLS_DSTBLEND_DST_ALPHA )
+		blendDstBits = GLS_DSTBLEND_ONE;
+	else if ( blendDstBits == GLS_DSTBLEND_ONE_MINUS_DST_ALPHA )
+		blendDstBits = GLS_DSTBLEND_ZERO;
+
+	// If the image has no (real) alpha channel, we can do the same
+	// for SRC_ALPHA
+	if ( !stage->bundle[0].image[0]->hasAlpha &&
+	     stage->alphaGen == AGEN_IDENTITY) {
+		if ( blendSrcBits == GLS_SRCBLEND_SRC_ALPHA )
+			blendSrcBits = GLS_SRCBLEND_ONE;
+		else if ( blendSrcBits == GLS_SRCBLEND_ONE_MINUS_SRC_ALPHA )
+			blendSrcBits = GLS_SRCBLEND_ZERO;
+		
+		if ( blendDstBits == GLS_DSTBLEND_SRC_ALPHA )
+			blendDstBits = GLS_DSTBLEND_ONE;
+		else if ( blendDstBits == GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA )
+			blendDstBits = GLS_DSTBLEND_ZERO;
+
+		// also alphaFunc makes no sense without alpha
+		atestBits = 0;
+	}
+
 	//
 	// if cgen isn't explicitly specified, use either identity or identitylighting
 	//
@@ -1023,7 +1055,6 @@
 		}
 	}
 
-
 	//
 	// implicitly assume that a GL_ONE GL_ZERO blend mask disables blending
 	//
@@ -1035,7 +1066,7 @@
 	}
 
 	// decide which agens we can skip
-	if ( stage->alphaGen == CGEN_IDENTITY ) {
+	if ( stage->alphaGen == AGEN_IDENTITY ) {
 		if ( stage->rgbGen == CGEN_IDENTITY
 			|| stage->rgbGen == CGEN_LIGHTING_DIFFUSE ) {
 			stage->alphaGen = AGEN_SKIP;
@@ -1634,6 +1665,11 @@
 */
 static void ComputeStageIteratorFunc( void )
 {
+	int stage;
+	int units = glConfig.numTextureUnits;
+
+	if (!units) units = 1;
+	
 	shader.optimalStageIteratorFunc = RB_StageIteratorGeneric;
 
 	//
@@ -1645,6 +1681,153 @@
 		goto done;
 	}
 
+	shader.needsNormal = qfalse;
+	shader.needsST1 = qfalse;
+	shader.needsST2 = qfalse;
+	shader.needsColor = qfalse;
+	shader.useVBO = qfalse;
+	
+	if ( glConfig.vertexBufferObjects ) {
+		shader.useVBO = qtrue;
+	}
+	
+	// check all deformation stages
+	for ( stage = 0; stage < shader.numDeforms; stage ++ ) {
+		switch ( shader.deforms[stage].deformation ) {
+		case DEFORM_NONE:
+			break;
+		case DEFORM_WAVE:
+		case DEFORM_NORMALS:
+		case DEFORM_BULGE:
+			shader.needsNormal = qtrue;
+			shader.useVBO = qfalse;
+			break;
+		case DEFORM_MOVE:
+		case DEFORM_PROJECTION_SHADOW:
+		case DEFORM_AUTOSPRITE:
+		case DEFORM_AUTOSPRITE2:
+		case DEFORM_TEXT0:
+		case DEFORM_TEXT1:
+		case DEFORM_TEXT2:
+		case DEFORM_TEXT3:
+		case DEFORM_TEXT4:
+		case DEFORM_TEXT5:
+		case DEFORM_TEXT6:
+		case DEFORM_TEXT7:
+			shader.useVBO = qfalse;
+			break;
+		}
+	}
+	
+	// check all shader stages
+	for ( stage = 0; stage < MAX_SHADER_STAGES; stage++ )
+	{
+		shaderStage_t *pStage = &stages[stage];
+		int           bundle;
+		
+		if ( !pStage->active )
+		{
+			break;
+		}
+		
+		switch ( pStage->rgbGen ) {
+		case CGEN_IDENTITY_LIGHTING:
+		case CGEN_IDENTITY:
+		case CGEN_ENTITY:
+		case CGEN_ONE_MINUS_ENTITY:
+		case CGEN_CONST:
+			// constant color, VBO possible
+			break;
+		case CGEN_EXACT_VERTEX:
+		case CGEN_VERTEX:
+			// vertex colors, VBO possible
+			shader.needsColor = qtrue;
+			break;
+		case CGEN_LIGHTING_DIFFUSE:
+			// normals needed, no VBO possible
+			shader.needsNormal = qtrue;
+			shader.useVBO = qfalse;
+			break;
+		case CGEN_ONE_MINUS_VERTEX:
+			// vertex colors needed, no VBO
+			shader.needsColor = qtrue;
+			shader.useVBO = qfalse;
+			break;
+		case CGEN_BAD:
+		case CGEN_WAVEFORM:
+		case CGEN_FOG:
+			// no vertex colors needed, no VBO
+			shader.useVBO = qfalse;
+			break;
+		}
+
+		switch ( pStage->alphaGen ) {
+		case AGEN_SKIP:
+			break;
+		case AGEN_IDENTITY:
+		case AGEN_ENTITY:
+		case AGEN_ONE_MINUS_ENTITY:
+		case AGEN_CONST:
+			if ( pStage->rgbGen == CGEN_VERTEX ||
+			     pStage->rgbGen == CGEN_EXACT_VERTEX ) {
+				// cannot combine const alpha with vertex color
+				shader.useVBO = qfalse;
+			}
+			break;
+		case AGEN_VERTEX:
+			shader.needsColor = qtrue;
+			if ( pStage->rgbGen != CGEN_VERTEX &&
+			     pStage->rgbGen != CGEN_EXACT_VERTEX ) {
+				// cannot combine vertex alpha with const color
+				shader.useVBO = qfalse;
+			}
+			break;
+		case AGEN_ONE_MINUS_VERTEX:
+			shader.useVBO = qfalse;
+			shader.needsColor = qtrue;
+			break;
+		case AGEN_LIGHTING_SPECULAR:
+		case AGEN_PORTAL:
+			shader.useVBO = qfalse;
+			shader.needsNormal = qtrue;
+			break;
+		case AGEN_WAVEFORM:
+			shader.useVBO = qfalse;
+			break;
+		}
+		
+		for ( bundle = 0; bundle < units; bundle++ ) {
+			if ( bundle > 0 && !pStage->bundle[bundle].multitextureEnv )
+				break;
+			
+			switch ( pStage->bundle[bundle].tcGen ) {
+			case TCGEN_BAD:
+				break;
+			case TCGEN_IDENTITY:
+			case TCGEN_VECTOR:
+			case TCGEN_FOG:
+				shader.useVBO = qfalse;
+				break;
+			case TCGEN_LIGHTMAP:
+				shader.needsST2 = qtrue;
+				break;
+			case TCGEN_TEXTURE:
+				shader.needsST1 = qtrue;
+				break;
+			case TCGEN_ENVIRONMENT_MAPPED:
+				shader.needsNormal = qtrue;
+				shader.useVBO = qfalse;
+				break;
+			}
+			if ( pStage->bundle[bundle].numTexMods > 0 )
+				shader.useVBO = qfalse;
+		}
+	}
+
+	// no VBOs for 0-stage shaders (fog)
+	if ( stage == 0 )
+		shader.useVBO = qfalse;
+
 	if ( r_ignoreFastPath->integer )
 	{
 		return;
@@ -1663,7 +1846,7 @@
 				{
 					if ( !shader.polygonOffset )
 					{
-						if ( !shader.multitextureEnv )
+						if ( !stages[0].bundle[1].multitextureEnv )
 						{
 							if ( !shader.numDeforms )
 							{
@@ -1691,7 +1874,7 @@
 				{
 					if ( !shader.numDeforms )
 					{
-						if ( shader.multitextureEnv )
+						if ( stages[0].bundle[1].multitextureEnv )
 						{
 							shader.optimalStageIteratorFunc = RB_StageIteratorLightmappedMultitexture;
 							goto done;
@@ -1749,117 +1932,171 @@
 ================
 CollapseMultitexture
 
-Attempt to combine two stages into a single multitexture stage
+Attempt to combine several stages into a single multitexture stage
 FIXME: I think modulated add + modulated add collapses incorrectly
 =================
 */
-static qboolean CollapseMultitexture( void ) {
+static int CollapseMultitexture( void ) {
+	int stage, bundle;
 	int abits, bbits;
 	int i;
 	textureBundle_t tmpBundle;
 
-	if ( !qglActiveTextureARB ) {
-		return qfalse;
+	stage = 0;
+	bundle = 0;
+
+	while( stages[stage].active ) {
+		if ( bundle + 1 >= glConfig.numTextureUnits ) {
+			// can't add next stage, no more texture units
+			stage++;
+			bundle = 0;
+			continue;
+		}
+		
+		// make sure both stages are active
+		if ( !stages[stage + 1].active ) {
+			// can't add next stage, it doesn't exist
+			stage++;
+			bundle = 0;
+			continue;
+		}
+
+		// on voodoo2, don't combine different tmus
+		if ( glConfig.driverType == GLDRV_VOODOO ) {
+			if ( stages[stage].bundle[0].image[0]->TMU ==
+			     stages[stage + 1].bundle[0].image[0]->TMU ) {
+				stage++;
+				bundle = 0;
+				continue;
+			}
+		}
+
+		abits = stages[stage].stateBits;
+		bbits = stages[stage + 1].stateBits;
+		/*
+		// can't combine if the second stage has an alpha test
+		if ( bbits & GLS_ATEST_BITS ) {
+			stage++;
+			bundle = 0;
+			continue;
+		}
+
+		// can combine alphafunc only if depthwrite is enabled and
+		// the second stage has depthfunc equal
+		if ( abits & GLS_ATEST_BITS ) {
+			if (!((abits & GLS_DEPTHMASK_TRUE) &&
+			      (bbits & GLS_DEPTHFUNC_EQUAL)) ) {
+				stage++;
+				bundle = 0;
+				continue;
+			}
+		} else {
+			if ( (abits & GLS_DEPTHFUNC_EQUAL) !=
+			     (bbits & GLS_DEPTHFUNC_EQUAL) ) {
+				stage++;
+				bundle = 0;
+				continue;
+			}
+		}
+		*/
+		// make sure that both stages have identical state other than blend modes
+		if ( ( abits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) !=
+		     ( bbits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) ) {
+			stage++;
+			bundle = 0;
+			continue;
+		}
+		
+		abits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+		bbits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+		
+		// search for a valid multitexture blend function
+		for ( i = 0; collapse[i].blendA != -1 ; i++ ) {
+			if ( abits == collapse[i].blendA
+			     && bbits == collapse[i].blendB ) {
+				break;
+			}
+		}
+		
+		// nothing found
+		if ( collapse[i].blendA == -1 ) {
+			stage++;
+			bundle = 0;
+			continue;
+		}
+		
+		// GL_ADD is a separate extension
+		if ( collapse[i].multitextureEnv == GL_ADD && !glConfig.textureEnvAddAvailable ) {
+			stage++;
+			bundle = 0;
+			continue;
+		}
+		
+		// make sure waveforms have identical parameters
+		if ( ( stages[stage].rgbGen != stages[stage + 1].rgbGen ) ||
+		     ( stages[stage].alphaGen != stages[stage + 1].alphaGen ) )  {
+			stage++;
+			bundle = 0;
+			continue;
+		}
+		
+		// an add collapse can only have identity colors
+		if ( collapse[i].multitextureEnv == GL_ADD && stages[stage].rgbGen != CGEN_IDENTITY ) {
+			stage++;
+			bundle = 0;
+			continue;
+		}
+		
+		if ( stages[stage].rgbGen == CGEN_WAVEFORM )
+		{
+			if ( memcmp( &stages[stage].rgbWave,
+				     &stages[stage + 1].rgbWave,
+				     sizeof( stages[stage].rgbWave ) ) )
+			{
+				stage++;
+				bundle = 0;
+				continue;
+			}
+		}
+		if ( stages[stage].alphaGen == CGEN_WAVEFORM )
+		{
+			if ( memcmp( &stages[stage].alphaWave,
+				     &stages[stage + 1].alphaWave,
+				     sizeof( stages[stage].alphaWave ) ) )
+			{
+				stage++;
+				bundle = 0;
+				continue;
+			}
+		}
+		
+		
+		// make sure that lightmaps are in bundle 1 for 3dfx
+		if ( bundle == 0 && stages[stage].bundle[0].isLightmap )
+		{
+			tmpBundle = stages[stage].bundle[0];
+			stages[stage].bundle[0] = stages[stage + 1].bundle[0];
+			stages[stage].bundle[1] = tmpBundle;
+		}
+		else
+		{
+			stages[stage].bundle[bundle + 1] = stages[stage + 1].bundle[0];
+		}
+		
+		// set the new blend state bits
+		stages[stage].bundle[bundle + 1].multitextureEnv = collapse[i].multitextureEnv;
+		stages[stage].stateBits &= ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
+		stages[stage].stateBits |= collapse[i].multitextureBlend;
+
+		bundle++;
+
+		//
+		// move down subsequent shaders
+		//
+		memmove( &stages[stage + 1], &stages[stage + 2], sizeof( stages[0] ) * ( MAX_SHADER_STAGES - stage - 2 ) );
+		Com_Memset( &stages[MAX_SHADER_STAGES-1], 0, sizeof( stages[0] ) );
 	}
-
-	// make sure both stages are active
-	if ( !stages[0].active || !stages[1].active ) {
-		return qfalse;
-	}
-
-	// on voodoo2, don't combine different tmus
-	if ( glConfig.driverType == GLDRV_VOODOO ) {
-		if ( stages[0].bundle[0].image[0]->TMU ==
-			 stages[1].bundle[0].image[0]->TMU ) {
-			return qfalse;
-		}
-	}
-
-	abits = stages[0].stateBits;
-	bbits = stages[1].stateBits;
-
-	// make sure that both stages have identical state other than blend modes
-	if ( ( abits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) !=
-		( bbits & ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS | GLS_DEPTHMASK_TRUE ) ) ) {
-		return qfalse;
-	}
-
-	abits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
-	bbits &= ( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
-
-	// search for a valid multitexture blend function
-	for ( i = 0; collapse[i].blendA != -1 ; i++ ) {
-		if ( abits == collapse[i].blendA
-			&& bbits == collapse[i].blendB ) {
-			break;
-		}
-	}
-
-	// nothing found
-	if ( collapse[i].blendA == -1 ) {
-		return qfalse;
-	}
-
-	// GL_ADD is a separate extension
-	if ( collapse[i].multitextureEnv == GL_ADD && !glConfig.textureEnvAddAvailable ) {
-		return qfalse;
-	}
-
-	// make sure waveforms have identical parameters
-	if ( ( stages[0].rgbGen != stages[1].rgbGen ) ||
-		( stages[0].alphaGen != stages[1].alphaGen ) )  {
-		return qfalse;
-	}
-
-	// an add collapse can only have identity colors
-	if ( collapse[i].multitextureEnv == GL_ADD && stages[0].rgbGen != CGEN_IDENTITY ) {
-		return qfalse;
-	}
-
-	if ( stages[0].rgbGen == CGEN_WAVEFORM )
-	{
-		if ( memcmp( &stages[0].rgbWave,
-					 &stages[1].rgbWave,
-					 sizeof( stages[0].rgbWave ) ) )
-		{
-			return qfalse;
-		}
-	}
-	if ( stages[0].alphaGen == CGEN_WAVEFORM )
-	{
-		if ( memcmp( &stages[0].alphaWave,
-					 &stages[1].alphaWave,
-					 sizeof( stages[0].alphaWave ) ) )
-		{
-			return qfalse;
-		}
-	}
-
-
-	// make sure that lightmaps are in bundle 1 for 3dfx
-	if ( stages[0].bundle[0].isLightmap )
-	{
-		tmpBundle = stages[0].bundle[0];
-		stages[0].bundle[0] = stages[1].bundle[0];
-		stages[0].bundle[1] = tmpBundle;
-	}
-	else
-	{
-		stages[0].bundle[1] = stages[1].bundle[0];
-	}
-
-	// set the new blend state bits
-	shader.multitextureEnv = collapse[i].multitextureEnv;
-	stages[0].stateBits &= ~( GLS_DSTBLEND_BITS | GLS_SRCBLEND_BITS );
-	stages[0].stateBits |= collapse[i].multitextureBlend;
-
-	//
-	// move down subsequent shaders
-	//
-	memmove( &stages[1], &stages[2], sizeof( stages[0] ) * ( MAX_SHADER_STAGES - 2 ) );
-	Com_Memset( &stages[MAX_SHADER_STAGES-1], 0, sizeof( stages[0] ) );
-
-	return qtrue;
+	return stage;
 }
 
 /*
@@ -2277,8 +2514,8 @@
 	//
 	// look for multitexture potential
 	//
-	if ( stage > 1 && CollapseMultitexture() ) {
-		stage--;
+	if ( stage > 1 ) {
+		stage = CollapseMultitexture();
 	}
 
 	if ( shader.lightmapIndex >= 0 && !hasLightmapStage ) {
@@ -2335,7 +2572,7 @@
 			return p;
 		}
 	}
-
+#if 0
 	p = s_shaderText;
 
 	if ( !p ) {
@@ -2357,7 +2594,7 @@
 			SkipBracedSection( &p );
 		}
 	}
-
+#endif
 	return NULL;
 }
 
@@ -2489,6 +2726,7 @@
 	shader.needsST1 = qtrue;
 	shader.needsST2 = qtrue;
 	shader.needsColor = qtrue;
+	shader.useVBO = qfalse;
 
 	//
 	// attempt to define shader from an explicit parameter file
@@ -2660,6 +2898,7 @@
 	shader.needsST1 = qtrue;
 	shader.needsST2 = qtrue;
 	shader.needsColor = qtrue;
+	shader.useVBO = qfalse;
 
 	//
 	// create the default shading commands
@@ -2892,7 +3131,7 @@
 ===============
 */
 void	R_ShaderList_f (void) {
-	int			i;
+	int			i, j, k;
 	int			count;
 	shader_t	*shader;
 
@@ -2913,15 +3152,6 @@
 		} else {
 			ri.Printf (PRINT_ALL, "  ");
 		}
-		if ( shader->multitextureEnv == GL_ADD ) {
-			ri.Printf( PRINT_ALL, "MT(a) " );
-		} else if ( shader->multitextureEnv == GL_MODULATE ) {
-			ri.Printf( PRINT_ALL, "MT(m) " );
-		} else if ( shader->multitextureEnv == GL_DECAL ) {
-			ri.Printf( PRINT_ALL, "MT(d) " );
-		} else {
-			ri.Printf( PRINT_ALL, "      " );
-		}
 		if ( shader->explicitlyDefined ) {
 			ri.Printf( PRINT_ALL, "E " );
 		} else {
@@ -2945,6 +3175,21 @@
 		} else {
 			ri.Printf (PRINT_ALL,  ": %s\n", shader->name);
 		}
+		for ( j = 0; j < shader->numUnfoggedPasses; j++ ) {
+			shaderStage_t *stage = shader->stages[j];
+			
+			if ( !stage->active )
+				break;
+
+			ri.Printf (PRINT_DEVELOPER, " %d\n" );
+			
+			for ( k = 0; i < NUM_TEXTURE_BUNDLES; k++ ) {
+				if ( !stage->bundle[k].image[0] )
+					break;
+
+				ri.Printf (PRINT_DEVELOPER, "  %s\n", stage->bundle[k].image[0]->imgName );
+			}
+		}
 		count++;
 	}
 	ri.Printf (PRINT_ALL, "%i total shaders\n", count);
diff -r 11104731f8c9 -r 87f98d895296 src/renderer/tr_surface.c
--- a/src/renderer/tr_surface.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/renderer/tr_surface.c	Sun Mar 29 01:15:08 2009 +0800
@@ -45,6 +45,7 @@
 
 
 //============================================================================
+vec4_t vec4Scratch ALIGNED((16));
 
 
 /*
@@ -53,8 +54,8 @@
 ==============
 */
 void RB_CheckOverflow( int verts, int indexes ) {
-	if (tess.numVertexes + verts < SHADER_MAX_VERTEXES
-		&& tess.numIndexes + indexes < SHADER_MAX_INDEXES) {
+	if (tess.numVertexes + verts < tess.maxVertexes
+	    && tess.numIndexes + indexes < tess.maxVertexes) {
 		return;
 	}
 
@@ -193,29 +194,61 @@
 RB_SurfacePolychain
 =============
 */
-void RB_SurfacePolychain( srfPoly_t *p ) {
+void RB_SurfacePolychain( surfaceType_t *surface ) {
+	srfPoly_t *p = (srfPoly_t *)surface;
 	int		i;
 	int		numv;
+	GLuint		*indexPtr;
+	GLushort	*indexPtrShort;
+	vec4_t		*xyzPtr, *normalPtr;
+	vec2_t		*texCoordPtr;
+	color4ub_t	*vertexColorPtr;
+
+	if ( !tess.indexPtr ) {
+		tess.numVertexes += p->numVerts;
+		tess.numIndexes  += 3*(p->numVerts - 2);
+		return;
+	}
 
 	RB_CHECKOVERFLOW( p->numVerts, 3*(p->numVerts - 2) );
 
+	indexPtr = ptrPlusOffset(tess.indexPtr, tess.indexInc * tess.numIndexes);
+	xyzPtr = ptrPlusOffset(tess.xyzPtr, tess.xyzInc * tess.numVertexes);
+	normalPtr = ptrPlusOffset(tess.normalPtr, tess.normalInc * tess.numVertexes);
+	texCoordPtr = ptrPlusOffset(tess.texCoordPtr, tess.texCoordInc * tess.numVertexes);
+	vertexColorPtr = ptrPlusOffset(tess.vertexColorPtr, tess.vertexColorInc * tess.numVertexes);
+
 	// fan triangles into the tess array
 	numv = tess.numVertexes;
 	for ( i = 0; i < p->numVerts; i++ ) {
-		VectorCopy( p->verts[i].xyz, tess.xyz[numv] );
-		tess.texCoords[numv][0][0] = p->verts[i].st[0];
-		tess.texCoords[numv][0][1] = p->verts[i].st[1];
-		*(int *)&tess.vertexColors[numv] = *(int *)p->verts[ i ].modulate;
+		VectorCopy ( p->verts[i].xyz, *(vec3_t *)xyzPtr );
+		xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
+		Vector2Copy( p->verts[i].st,  *texCoordPtr );
+		texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
+		*(int *)vertexColorPtr = *(int *)p->verts[ i ].modulate;
+		vertexColorPtr = ptrPlusOffset(vertexColorPtr, tess.vertexColorInc);
 
 		numv++;
 	}
 
 	// generate fan indexes into the tess array
-	for ( i = 0; i < p->numVerts-2; i++ ) {
-		tess.indexes[tess.numIndexes + 0] = tess.numVertexes;
-		tess.indexes[tess.numIndexes + 1] = tess.numVertexes + i + 1;
-		tess.indexes[tess.numIndexes + 2] = tess.numVertexes + i + 2;
-		tess.numIndexes += 3;
+	if ( tess.indexInc == sizeof(GLushort) ) {
+		indexPtrShort = (GLushort *)indexPtr;
+		for ( i = 0; i < p->numVerts-2; i++ ) {
+			indexPtrShort[0] = (GLushort)(tess.numVertexes);
+			indexPtrShort[1] = (GLushort)(tess.numVertexes + i + 1);
+			indexPtrShort[2] = (GLushort)(tess.numVertexes + i + 2);
+			indexPtrShort += 3;
+			tess.numIndexes += 3;
+		}
+	} else {
+		for ( i = 0; i < p->numVerts-2; i++ ) {
+			indexPtr[0] = tess.numVertexes;
+			indexPtr[1] = tess.numVertexes + i + 1;
+			indexPtr[2] = tess.numVertexes + i + 2;
+			indexPtr += 3;
+			tess.numIndexes += 3;
+		}
 	}
 
 	tess.numVertexes = numv;
@@ -227,55 +260,75 @@
 RB_SurfaceTriangles
 =============
 */
-void RB_SurfaceTriangles( srfTriangles_t *srf ) {
+void RB_SurfaceTriangles( surfaceType_t *surface ) {
+	srfTriangles_t *srf = (srfTriangles_t *)surface;
 	int			i;
 	drawVert_t	*dv;
-	float		*xyz, *normal, *texCoords;
-	byte		*color;
 	int			dlightBits;
-	qboolean	needsNormal;
+	GLuint		*indexPtr;
+	GLushort	*indexPtrShort;
+	vec4_t		*xyzPtr, *normalPtr;
+	vec2_t		*texCoordPtr, *texCoord2Ptr;
+	color4ub_t	*vertexColorPtr;
+	int		*vertexDlightBitPtr;
 
 	dlightBits = srf->dlightBits[backEnd.smpFrame];
 	tess.dlightBits |= dlightBits;
 
+	if ( !tess.indexPtr ) {
+		tess.numVertexes += srf->numVerts;
+		tess.numIndexes  += srf->numIndexes;
+		return;
+	}
+
 	RB_CHECKOVERFLOW( srf->numVerts, srf->numIndexes );
+	
+	indexPtr = ptrPlusOffset(tess.indexPtr, tess.indexInc * tess.numIndexes);
+	xyzPtr = ptrPlusOffset(tess.xyzPtr, tess.xyzInc * tess.numVertexes);
+	normalPtr = ptrPlusOffset(tess.normalPtr, tess.normalInc * tess.numVertexes);
+	texCoordPtr = ptrPlusOffset(tess.texCoordPtr, tess.texCoordInc * tess.numVertexes);
+	texCoord2Ptr = ptrPlusOffset(tess.texCoord2Ptr, tess.texCoord2Inc * tess.numVertexes);
+	vertexColorPtr = ptrPlusOffset(tess.vertexColorPtr, tess.vertexColorInc * tess.numVertexes);
+	vertexDlightBitPtr = ptrPlusOffset(tess.vertexDlightBitPtr, tess.vertexDlightBitInc * tess.numVertexes);
 
-	for ( i = 0 ; i < srf->numIndexes ; i += 3 ) {
-		tess.indexes[ tess.numIndexes + i + 0 ] = tess.numVertexes + srf->indexes[ i + 0 ];
-		tess.indexes[ tess.numIndexes + i + 1 ] = tess.numVertexes + srf->indexes[ i + 1 ];
-		tess.indexes[ tess.numIndexes + i + 2 ] = tess.numVertexes + srf->indexes[ i + 2 ];
+	if ( tess.indexInc == sizeof(GLushort) ) {
+		indexPtrShort = (GLushort *)indexPtr;
+		for ( i = 0 ; i < srf->numIndexes ; i += 3 ) {
+			indexPtrShort[ i + 0 ] = (GLushort)(tess.numVertexes + srf->indexes[ i + 0 ]);
+			indexPtrShort[ i + 1 ] = (GLushort)(tess.numVertexes + srf->indexes[ i + 1 ]);
+			indexPtrShort[ i + 2 ] = (GLushort)(tess.numVertexes + srf->indexes[ i + 2 ]);
+		}
+	} else {
+		for ( i = 0 ; i < srf->numIndexes ; i += 3 ) {
+			indexPtr[ i + 0 ] = tess.numVertexes + srf->indexes[ i + 0 ];
+			indexPtr[ i + 1 ] = tess.numVertexes + srf->indexes[ i + 1 ];
+			indexPtr[ i + 2 ] = tess.numVertexes + srf->indexes[ i + 2 ];
+		}
 	}
 	tess.numIndexes += srf->numIndexes;
+	
+	dv = srf->verts;
+	
+	for ( i = 0 ; i < srf->numVerts ; i++, dv++ ) {
+		VectorCopy( dv->xyz, *(vec3_t *)xyzPtr );
+		xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
+	  
+		VectorCopy( dv->normal, *(vec3_t *)normalPtr );
+		normalPtr = ptrPlusOffset(normalPtr, tess.normalInc);
+	  
+		Vector2Copy( dv->st,       *texCoordPtr );
+		texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
 
-	dv = srf->verts;
-	xyz = tess.xyz[ tess.numVertexes ];
-	normal = tess.normal[ tess.numVertexes ];
-	texCoords = tess.texCoords[ tess.numVertexes ][0];
-	color = tess.vertexColors[ tess.numVertexes ];
-	needsNormal = tess.shader->needsNormal;
-
-	for ( i = 0 ; i < srf->numVerts ; i++, dv++, xyz += 4, normal += 4, texCoords += 4, color += 4 ) {
-		xyz[0] = dv->xyz[0];
-		xyz[1] = dv->xyz[1];
-		xyz[2] = dv->xyz[2];
-
-		if ( needsNormal ) {
-			normal[0] = dv->normal[0];
-			normal[1] = dv->normal[1];
-			normal[2] = dv->normal[2];
-		}
-
-		texCoords[0] = dv->st[0];
-		texCoords[1] = dv->st[1];
-
-		texCoords[2] = dv->lightmap[0];
-		texCoords[3] = dv->lightmap[1];
-
-		*(int *)color = *(int *)dv->color;
+		Vector2Copy( dv->lightmap, *texCoord2Ptr );
+		texCoord2Ptr = ptrPlusOffset(texCoord2Ptr, tess.texCoord2Inc);
+	  
+		*(int *)vertexColorPtr = *(int *)dv->color;
+		vertexColorPtr = ptrPlusOffset(vertexColorPtr, tess.vertexColorInc);
 	}
 
 	for ( i = 0 ; i < srf->numVerts ; i++ ) {
-		tess.vertexDlightBits[ tess.numVertexes + i] = dlightBits;
+		*vertexDlightBitPtr = dlightBits;
+		vertexDlightBitPtr = ptrPlusOffset(vertexDlightBitPtr, tess.vertexDlightBitInc);
 	}
 
 	tess.numVertexes += srf->numVerts;
@@ -638,6 +691,7 @@
 {
 	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
 	float	*outXyz, *outNormal;
+	size_t	 incXyz, incNormal;
 	float	oldXyzScale ALIGNED(16);
 	float   newXyzScale ALIGNED(16);
 	float	oldNormalScale ALIGNED(16);
@@ -646,8 +700,10 @@
 	unsigned lat, lng;
 	int		numVerts;
 
-	outXyz = tess.xyz[tess.numVertexes];
-	outNormal = tess.normal[tess.numVertexes];
+	outXyz = (float *)ptrPlusOffset(tess.xyzPtr, tess.numVertexes * tess.xyzInc);
+	outNormal = (float *)ptrPlusOffset(tess.normalPtr, tess.numVertexes * tess.normalInc);
+	incXyz = tess.xyzInc;
+	incNormal = tess.normalInc;
 
 	newXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
 		+ (backEnd.currentEntity->e.frame * surf->numVerts * 4);
@@ -680,7 +736,8 @@
 		//
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
 			newXyz += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
+		       outXyz = ptrPlusOffset(outXYZ, incXyz),
+		       outNormal = ptrPlusOffset(outNormal, incNormal) )
 		{
 			newNormalsLoadPermute = vec_lvsl(0,newXyz);
 			newNormalsStorePermute = vec_lvsr(0,outXyz);
@@ -725,7 +782,8 @@
 
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
 			oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
+		       outXyz = ptrPlusOffset(outXyz, incXyz),
+		       outNormal = ptrPlusOffset(outNormal, incNormal) )
 		{
 			vec3_t uncompressedOldNormal, uncompressedNewNormal;
 
@@ -758,7 +816,7 @@
 
 //			VectorNormalize (outNormal);
 		}
-    	VectorArrayNormalize((vec4_t *)tess.normal[tess.numVertexes], numVerts);
+    	VectorArrayNormalize((vec4_t *)tess->normalPtr + tess.numVertexes, numVerts);
    	}
 }
 #endif
@@ -768,6 +826,7 @@
 {
 	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
 	float	*outXyz, *outNormal;
+	size_t	 incXyz, incNormal;
 	float    oldXyzScale;
 	float    newXyzScale;
 	float    oldNormalScale;
@@ -776,8 +835,10 @@
 	unsigned lat, lng;
 	int	 numVerts;
 
-	outXyz = tess.xyz[tess.numVertexes];
-	outNormal = tess.normal[tess.numVertexes];
+	outXyz = (float *)ptrPlusOffset(tess.xyzPtr, tess.numVertexes * tess.xyzInc);
+	outNormal = (float *)ptrPlusOffset(tess.normalPtr, tess.numVertexes * tess.normalInc);
+	incXyz = tess.xyzInc;
+	incNormal = tess.normalInc;
 
 	newXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
 		+ (backEnd.currentEntity->e.frame * surf->numVerts * 4);
@@ -799,7 +860,8 @@
 		//
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
 			newXyz += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
+		       outXyz = ptrPlusOffset(outXyz, incXyz),
+		       outNormal = ptrPlusOffset(outNormal, incNormal) )
 		{
 			newNormalsVec = v8sLoadU(newXyz);
 			v8s_to_v4i(newNormalsVec, newNormalsIntVec, dummy);
@@ -837,7 +899,8 @@
 
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
 			oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
+		       outXyz = ptrPlusOffset(outXyz, incXyz),
+		       outNormal = ptrPlusOffset(outNormal, incNormal) )
 		{
 			vec3_t uncompressedOldNormal, uncompressedNewNormal;
 
@@ -870,7 +933,8 @@
 
 //			VectorNormalize (outNormal);
 		}
-    	VectorArrayNormalize((vec4_t *)tess.normal[tess.numVertexes], numVerts);
+		if ( tess.normalPtr )
+			VectorArrayNormalize(tess.normalPtr + tess.numVertexes, numVerts);
    	}
 }
 #endif
@@ -879,14 +943,17 @@
 {
 	short	*oldXyz, *newXyz, *oldNormals, *newNormals;
 	float	*outXyz, *outNormal;
+	size_t	 incXyz, incNormal;
 	float	oldXyzScale, newXyzScale;
 	float	oldNormalScale, newNormalScale;
 	int		vertNum;
 	unsigned lat, lng;
 	int		numVerts;
 
-	outXyz = tess.xyz[tess.numVertexes];
-	outNormal = tess.normal[tess.numVertexes];
+	outXyz = (float *)ptrPlusOffset(tess.xyzPtr, tess.numVertexes * tess.xyzInc);
+	outNormal = (float *)ptrPlusOffset(tess.normalPtr, tess.numVertexes * tess.normalInc);
+	incXyz = tess.xyzInc;
+	incNormal = tess.normalInc;
 
 	newXyz = (short *)((byte *)surf + surf->ofsXyzNormals)
 		+ (backEnd.currentEntity->e.frame * surf->numVerts * 4);
@@ -903,7 +970,8 @@
 		//
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
 			newXyz += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
+		       outXyz = ptrPlusOffset(outXyz, incXyz),
+		       outNormal = ptrPlusOffset(outNormal, incNormal) )
 		{
 
 			outXyz[0] = newXyz[0] * newXyzScale;
@@ -936,7 +1004,8 @@
 
 		for (vertNum=0 ; vertNum < numVerts ; vertNum++,
 			oldXyz += 4, newXyz += 4, oldNormals += 4, newNormals += 4,
-			outXyz += 4, outNormal += 4) 
+		       outXyz = ptrPlusOffset(outXyz, incXyz),
+		       outNormal = ptrPlusOffset(outNormal, incNormal) )
 		{
 			vec3_t uncompressedOldNormal, uncompressedNewNormal;
 
@@ -969,7 +1038,8 @@
 
 //			VectorNormalize (outNormal);
 		}
-    	VectorArrayNormalize((vec4_t *)tess.normal[tess.numVertexes], numVerts);
+		if ( tess.normalPtr )
+			VectorArrayNormalize(tess.normalPtr + tess.numVertexes, numVerts);
    	}
 }
 
@@ -988,6 +1058,7 @@
 	int				indexes;
 	int				Bob, Doug;
 	int				numVerts;
+	vec2_t		*texCoordPtr;
 
 	if (  backEnd.currentEntity->e.oldframe == backEnd.currentEntity->e.frame ) {
 		backlerp = 0;
@@ -995,6 +1066,12 @@
 		backlerp = backEnd.currentEntity->e.backlerp;
 	}
 
+	if ( !tess.indexPtr ) {
+		tess.numVertexes += surface->numVerts;
+		tess.numIndexes  += 3*surface->numTriangles;
+		return;
+	}
+
 	RB_CHECKOVERFLOW( surface->numVerts, surface->numTriangles*3 );
 
 	LerpMeshVertexes_altivec (surface, backlerp);
@@ -1009,11 +1086,13 @@
 	tess.numIndexes += indexes;
 
 	texCoords = (float *) ((byte *)surface + surface->ofsSt);
+	texCoordPtr = ptrPlusOffset(tess.texCoordPtr, Doug * tess.texCoordInc);
 
 	numVerts = surface->numVerts;
 	for ( j = 0; j < numVerts; j++ ) {
-		tess.texCoords[Doug + j][0][0] = texCoords[j*2+0];
-		tess.texCoords[Doug + j][0][1] = texCoords[j*2+1];
+		(*texCoordPtr)[0] = texCoords[j*2+0];
+		(*texCoordPtr)[1] = texCoords[j*2+1];
+		texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
 		// FIXME: fill in lightmapST for completeness?
 	}
 
@@ -1031,6 +1110,7 @@
 	int				indexes;
 	int				Bob, Doug;
 	int				numVerts;
+	vec2_t		*texCoordPtr;
 
 	if (  backEnd.currentEntity->e.oldframe == backEnd.currentEntity->e.frame ) {
 		backlerp = 0;
@@ -1038,6 +1118,12 @@
 		backlerp = backEnd.currentEntity->e.backlerp;
 	}
 
+	if ( !tess.indexPtr ) {
+		tess.numVertexes += surface->numVerts;
+		tess.numIndexes  += 3*surface->numTriangles;
+		return;
+	}
+
 	RB_CHECKOVERFLOW( surface->numVerts, surface->numTriangles*3 );
 
 	LerpMeshVertexes_sse2 (surface, backlerp);
@@ -1047,16 +1133,24 @@
 	Bob = tess.numIndexes;
 	Doug = tess.numVertexes;
 	
-	CopyArrayAndAddConstant_sse2(&tess.indexes[Bob], triangles,
-				     Doug, indexes);
+	if ( tess.indexInc == sizeof(GLushort) ) {
+		GLushort *indexPtrShort = (GLushort *)(tess.indexPtr);
+		CopyArrayAndAddConstantShort_sse2(indexPtrShort + Bob, triangles,
+						  Doug, indexes);
+	} else {
+		CopyArrayAndAddConstant_sse2(tess.indexPtr + Bob, triangles,
+					     Doug, indexes);
+	}
 	tess.numIndexes += indexes;
 
 	texCoords = (float *) ((byte *)surface + surface->ofsSt);
+	texCoordPtr = ptrPlusOffset(tess.texCoordPtr, Doug * tess.texCoordInc);
 
 	numVerts = surface->numVerts;
 	for ( j = 0; j < numVerts; j++ ) {
-		tess.texCoords[Doug + j][0][0] = texCoords[j*2+0];
-		tess.texCoords[Doug + j][0][1] = texCoords[j*2+1];
+		(*texCoordPtr)[0] = texCoords[j*2+0];
+		(*texCoordPtr)[1] = texCoords[j*2+1];
+		texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
 		// FIXME: fill in lightmapST for completeness?
 	}
 
@@ -1073,6 +1167,7 @@
 	int				indexes;
 	int				Bob, Doug;
 	int				numVerts;
+	vec2_t		*texCoordPtr;
 
 	if (  backEnd.currentEntity->e.oldframe == backEnd.currentEntity->e.frame ) {
 		backlerp = 0;
@@ -1080,6 +1175,12 @@
 		backlerp = backEnd.currentEntity->e.backlerp;
 	}
 
+	if ( !tess.indexPtr ) {
+		tess.numVertexes += surface->numVerts;
+		tess.numIndexes  += 3*surface->numTriangles;
+		return;
+	}
+
 	RB_CHECKOVERFLOW( surface->numVerts, surface->numTriangles*3 );
 
 	LerpMeshVertexes_scalar (surface, backlerp);
@@ -1088,17 +1189,27 @@
 	indexes = surface->numTriangles * 3;
 	Bob = tess.numIndexes;
 	Doug = tess.numVertexes;
-	for (j = 0 ; j < indexes ; j++) {
-		tess.indexes[Bob + j] = Doug + triangles[j];
+
+	if ( tess.indexInc == sizeof(GLushort) ) {
+		GLushort *indexPtrShort = (GLushort *)tess.indexPtr;
+		for (j = 0 ; j < indexes ; j++) {
+			indexPtrShort[Bob + j] = (GLushort)(Doug + triangles[j]);
+		}
+	} else {
+		for (j = 0 ; j < indexes ; j++) {
+			tess.indexPtr[Bob + j] = Doug + triangles[j];
+		}
 	}
 	tess.numIndexes += indexes;
 
 	texCoords = (float *) ((byte *)surface + surface->ofsSt);
+	texCoordPtr = tess.texCoordPtr + Doug * tess.texCoordInc;
 
 	numVerts = surface->numVerts;
 	for ( j = 0; j < numVerts; j++ ) {
-		tess.texCoords[Doug + j][0][0] = texCoords[j*2+0];
-		tess.texCoords[Doug + j][0][1] = texCoords[j*2+1];
+		(*texCoordPtr)[0] = texCoords[j*2+0];
+		(*texCoordPtr)[1] = texCoords[j*2+1];
+		texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
 		// FIXME: fill in lightmapST for completeness?
 	}
 
@@ -1106,7 +1217,8 @@
 
 }
 
-void RB_SurfaceMesh(md3Surface_t *surface) {
+void RB_SurfaceMesh( surfaceType_t *surf) {
+	md3Surface_t *surface = (md3Surface_t *)surf;
 #if idppc_altivec
   if (com_altivec->integer) {
     RB_SurfaceMesh_altivec( surface );
@@ -1133,12 +1245,21 @@
 	int		 i;
 	unsigned	*indices, *tessIndexes;
 	float		*v;
-	int		 ndx;
 	int		 Bob;
 	v4i              Mask1, Mask2, dataVec, nextVec;
 	int		 numPoints;
 	int		 dlightBits;
+	vec4_t		*xyzPtr, *normalPtr;
+	vec2_t		*texCoordPtr, *texCoord2Ptr;
+	color4ub_t	*vertexColorPtr;
+	int		*vertexDlightBitPtr;
 	
+	if ( !tess.indexPtr ) {
+		tess.numVertexes += surf->numPoints;
+		tess.numIndexes  += surf->numIndices;
+		return;
+	}
+
 	RB_CHECKOVERFLOW( surf->numPoints, surf->numIndices );
 	
 	dlightBits = surf->dlightBits[backEnd.smpFrame];
@@ -1147,54 +1268,135 @@
 	indices = ( unsigned * ) ( ( ( char  * ) surf ) + surf->ofsIndices );
 	
 	Bob = tess.numVertexes;
-	tessIndexes = tess.indexes + tess.numIndexes;
+	tessIndexes = ptrPlusOffset(tess.indexPtr, tess.indexInc * tess.numIndexes);
 	
-	CopyArrayAndAddConstant_sse2(tessIndexes, indices, Bob, surf->numIndices);
+	if ( tess.indexInc == sizeof(GLushort) ) {
+		GLushort *indexPtrShort = (GLushort *)tessIndexes;
+		CopyArrayAndAddConstantShort_sse2(indexPtrShort, indices, Bob, surf->numIndices);
+	} else {
+		CopyArrayAndAddConstant_sse2(tessIndexes, indices, Bob, surf->numIndices);
+	}
 	tess.numIndexes += surf->numIndices;
 	
 	v = surf->points[0];
 	
-	ndx = tess.numVertexes;
+	numPoints = surf->numPoints;
+
+	xyzPtr = ptrPlusOffset(tess.xyzPtr, tess.xyzInc * tess.numVertexes);
+	normalPtr = ptrPlusOffset(tess.normalPtr, tess.normalInc * tess.numVertexes);
+	texCoordPtr = ptrPlusOffset(tess.texCoordPtr, tess.texCoordInc * tess.numVertexes);
+	texCoord2Ptr = ptrPlusOffset(tess.texCoord2Ptr, tess.texCoord2Inc * tess.numVertexes);
+	vertexColorPtr = ptrPlusOffset(tess.vertexColorPtr, tess.vertexColorInc * tess.numVertexes);
+	vertexDlightBitPtr = ptrPlusOffset(tess.vertexDlightBitPtr, tess.vertexDlightBitInc * tess.numVertexes);
 	
-	numPoints = surf->numPoints;
-	
-	if ( tess.shader->needsNormal ) {
+	if ( tess.normalInc > 0 ) {
 		v4i normalVec = v4iLoadU((int *)surf->plane.normal);
-		for ( i = 0, ndx = tess.numVertexes; i < numPoints; i++, ndx++ ) {
-			v4iStoreA((int *)&(tess.normal[ndx]), normalVec);
+		for ( i = 0; i < numPoints; i++ ) {
+			v4iStoreA((int *)normalPtr, normalVec);
+			normalPtr = ptrPlusOffset(normalPtr, tess.normalInc);
 		}
 	}
-	
-	Mask1 = v4iInit(0, 0, 0, -1);
-	Mask2 = v4iInit(-1, -1, -1, 0);
-	for ( i = 0, v = surf->points[0], ndx = tess.numVertexes; i < numPoints; i++, v += VERTEXSIZE, ndx++ ) {
-		dataVec = v4iLoadU((int *)v);
-		nextVec = v4iLoadU((int *)(v + 4));
-		
-		v4iStoreA((int *)&(tess.xyz[ndx]), dataVec);
-		dataVec = v4iOr(v4iAnd(Mask1, dataVec), v4iAnd(Mask2, nextVec));
-		dataVec = _mm_shuffle_epi32(dataVec, 0x93);
-		v4iStoreA((int *)&(tess.texCoords[ndx][0][0]), dataVec);
-		
-		nextVec = _mm_shuffle_epi32(nextVec, 0xff);
-		* ( unsigned int * ) &tess.vertexColors[ndx] = _mm_cvtsi128_si32(nextVec);
-		tess.vertexDlightBits[ndx] = dlightBits;
+
+	if ( tess.texCoordInc > 0 && tess.texCoord2Inc > 0 ) {
+		/* the SSE code assumes that texture coords are always
+		   interleaved, because it uses only 1 v4fStore !! */
+		Mask1 = v4iInit(0, 0, 0, -1);
+		Mask2 = v4iInit(-1, -1, -1, 0);
+		for ( i = 0, v = surf->points[0]; i < numPoints; i++, v += VERTEXSIZE ) {
+			dataVec = v4iLoadU((int *)v);
+			nextVec = v4iLoadU((int *)(v + 4));
+			
+			v4iStoreA((int *)xyzPtr, dataVec);
+			xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
+			dataVec = v4iOr(v4iAnd(Mask1, dataVec), v4iAnd(Mask2, nextVec));
+			dataVec = _mm_shuffle_epi32(dataVec, 0x93);
+			v4iStoreA((int *)texCoordPtr, dataVec);
+			texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
+			
+			nextVec = _mm_shuffle_epi32(nextVec, 0xff);
+			*(unsigned int *)vertexColorPtr = _mm_cvtsi128_si32(nextVec);
+			vertexColorPtr = ptrPlusOffset(vertexColorPtr, tess.vertexColorInc);
+			
+			*vertexDlightBitPtr = dlightBits;
+			vertexDlightBitPtr = ptrPlusOffset(vertexDlightBitPtr, tess.vertexDlightBitInc);
+		}
+	} else if ( tess.texCoordInc > 0 ) {
+		Mask1 = v4iInit(0, 0, 0, -1);
+		Mask2 = v4iInit(-1, -1, -1, 0);
+		for ( i = 0, v = surf->points[0]; i < numPoints; i++, v += VERTEXSIZE ) {
+			dataVec = v4iLoadU((int *)v);
+			nextVec = v4iLoadU((int *)(v + 4));
+			
+			v4iStoreA((int *)xyzPtr, dataVec);
+			xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
+			dataVec = v4iOr(v4iAnd(Mask1, dataVec), v4iAnd(Mask2, nextVec));
+			dataVec = _mm_shuffle_epi32(dataVec, 0x93);
+			v4iStoreLoA((int *)texCoordPtr, dataVec);
+			texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
+			
+			nextVec = _mm_shuffle_epi32(nextVec, 0xff);
+			*(unsigned int *)vertexColorPtr = _mm_cvtsi128_si32(nextVec);
+			vertexColorPtr = ptrPlusOffset(vertexColorPtr, tess.vertexColorInc);
+			
+			*vertexDlightBitPtr = dlightBits;
+			vertexDlightBitPtr = ptrPlusOffset(vertexDlightBitPtr, tess.vertexDlightBitInc);
+		}
+	} else if ( tess.texCoord2Inc > 0 ) {
+		for ( i = 0, v = surf->points[0]; i < numPoints; i++, v += VERTEXSIZE ) {
+			dataVec = v4iLoadU((int *)v);
+			nextVec = v4iLoadU((int *)(v + 4));
+			
+			v4iStoreA((int *)xyzPtr, dataVec);
+			xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
+			dataVec = _mm_shuffle_epi32(nextVec, 0x39);
+			v4iStoreLoA((int *)texCoordPtr, dataVec);
+			texCoord2Ptr = ptrPlusOffset(texCoord2Ptr, tess.texCoord2Inc);
+			
+			nextVec = _mm_shuffle_epi32(nextVec, 0xff);
+			*(unsigned int *)vertexColorPtr = _mm_cvtsi128_si32(nextVec);
+			vertexColorPtr = ptrPlusOffset(vertexColorPtr, tess.vertexColorInc);
+			
+			*vertexDlightBitPtr = dlightBits;
+			vertexDlightBitPtr = ptrPlusOffset(vertexDlightBitPtr, tess.vertexDlightBitInc);
+		}
+	} else {
+		for ( i = 0, v = surf->points[0]; i < numPoints; i++, v += VERTEXSIZE ) {
+			dataVec = v4iLoadU((int *)v);
+			nextVec = v4iLoadU((int *)(v + 4));
+			
+			v4iStoreA((int *)xyzPtr, dataVec);
+			xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
+			
+			nextVec = _mm_shuffle_epi32(nextVec, 0xff);
+			*(unsigned int *)vertexColorPtr = _mm_cvtsi128_si32(nextVec);
+			vertexColorPtr = ptrPlusOffset(vertexColorPtr, tess.vertexColorInc);
+			
+			*vertexDlightBitPtr = dlightBits;
+			vertexDlightBitPtr = ptrPlusOffset(vertexDlightBitPtr, tess.vertexDlightBitInc);
+		}
 	}
 	
-	
 	tess.numVertexes += surf->numPoints;
 }
 #endif
-
 static ID_INLINE void RB_SurfaceFace_scalar( srfSurfaceFace_t *surf ) {
 	int			i;
 	unsigned	*indices, *tessIndexes;
 	float		*v;
 	float		*normal;
-	int			ndx;
 	int			Bob;
 	int			numPoints;
 	int			dlightBits;
+	vec4_t		*xyzPtr, *normalPtr;
+	vec2_t		*texCoordPtr, *texCoord2Ptr;
+	color4ub_t	*vertexColorPtr;
+	int		*vertexDlightBitPtr;
+
+	if ( !tess.indexPtr ) {
+		tess.numVertexes += surf->numPoints;
+		tess.numIndexes  += surf->numIndices;
+		return;
+	}
 
 	RB_CHECKOVERFLOW( surf->numPoints, surf->numIndices );
 
@@ -1204,41 +1406,57 @@
 	indices = ( unsigned * ) ( ( ( char  * ) surf ) + surf->ofsIndices );
 
 	Bob = tess.numVertexes;
-	tessIndexes = tess.indexes + tess.numIndexes;
-	for ( i = surf->numIndices-1 ; i >= 0  ; i-- ) {
-		tessIndexes[i] = indices[i] + Bob;
+	tessIndexes = ptrPlusOffset(tess.indexPtr, tess.indexInc * tess.numIndexes);
+	if ( tess.indexInc == sizeof(GLushort) ) {
+		GLushort *indexPtrShort = (GLushort *)tessIndexes;
+		for ( i = surf->numIndices-1 ; i >= 0  ; i-- ) {
+			indexPtrShort[i] = (GLushort)(indices[i] + Bob);
+		}
+	} else {
+		for ( i = surf->numIndices-1 ; i >= 0  ; i-- ) {
+			tessIndexes[i] = indices[i] + Bob;
+		}
 	}
 
 	tess.numIndexes += surf->numIndices;
 
 	v = surf->points[0];
 
-	ndx = tess.numVertexes;
-
 	numPoints = surf->numPoints;
 
-	if ( tess.shader->needsNormal ) {
+	xyzPtr = ptrPlusOffset(tess.xyzPtr, tess.xyzInc * tess.numVertexes);
+	normalPtr = ptrPlusOffset(tess.normalPtr, tess.normalInc * tess.numVertexes);
+	texCoordPtr = ptrPlusOffset(tess.texCoordPtr, tess.texCoordInc * tess.numVertexes);
+	texCoord2Ptr = ptrPlusOffset(tess.texCoord2Ptr, tess.texCoord2Inc * tess.numVertexes);
+	vertexColorPtr = ptrPlusOffset(tess.vertexColorPtr, tess.vertexColorInc * tess.numVertexes);
+	vertexDlightBitPtr = ptrPlusOffset(tess.vertexDlightBitPtr, tess.vertexDlightBitInc * tess.numVertexes);
+
+	if ( tess.normalInc > 0 ) {
 		normal = surf->plane.normal;
-		for ( i = 0, ndx = tess.numVertexes; i < numPoints; i++, ndx++ ) {
-			VectorCopy( normal, tess.normal[ndx] );
+		for ( i = 0; i < numPoints; i++ ) {
+			VectorCopy( normal, *(vec3_t *)normalPtr );
+			normalPtr = ptrPlusOffset(normalPtr, tess.normalInc);
 		}
 	}
 
-	for ( i = 0, v = surf->points[0], ndx = tess.numVertexes; i < numPoints; i++, v += VERTEXSIZE, ndx++ ) {
-		VectorCopy( v, tess.xyz[ndx]);
-		tess.texCoords[ndx][0][0] = v[3];
-		tess.texCoords[ndx][0][1] = v[4];
-		tess.texCoords[ndx][1][0] = v[5];
-		tess.texCoords[ndx][1][1] = v[6];
-		* ( unsigned int * ) &tess.vertexColors[ndx] = * ( unsigned int * ) &v[7];
-		tess.vertexDlightBits[ndx] = dlightBits;
+	for ( i = 0, v = surf->points[0]; i < numPoints; i++, v += VERTEXSIZE ) {
+		VectorCopy ( v, *(vec3_t *)xyzPtr);
+		xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
+		Vector2Copy( v+3, *texCoordPtr );
+		texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
+		Vector2Copy( v+5, *texCoord2Ptr );
+		texCoord2Ptr = ptrPlusOffset(texCoord2Ptr, tess.texCoord2Inc);
+		*(unsigned int *)vertexColorPtr = *(unsigned int *)&v[7];
+		vertexColorPtr = ptrPlusOffset(vertexColorPtr, tess.vertexColorInc);
+		*vertexDlightBitPtr = dlightBits;
+		vertexDlightBitPtr = ptrPlusOffset(vertexDlightBitPtr, tess.vertexDlightBitInc);
 	}
 
-
 	tess.numVertexes += surf->numPoints;
 }
 
-void RB_SurfaceFace( srfSurfaceFace_t *surf ) {
+void RB_SurfaceFace( surfaceType_t *surface ) {
+	srfSurfaceFace_t *surf = (srfSurfaceFace_t *)surface;
 #if id386_sse >= 2
 	if (com_sse->integer >= 2) {
 		RB_SurfaceFace_sse2( surf );
@@ -1286,12 +1504,13 @@
 Just copy the grid of points and triangulate
 =============
 */
-void RB_SurfaceGrid( srfGridMesh_t *cv ) {
+void RB_SurfaceGrid( surfaceType_t *surface ) {
+	srfGridMesh_t *cv = (srfGridMesh_t *)surface;
 	int		i, j;
-	float	*xyz;
-	float	*texCoords;
-	float	*normal;
-	unsigned char *color;
+	vec4_t	*xyzPtr;
+	vec2_t	*texCoordPtr, *texCoord2Ptr;
+	vec4_t	*normalPtr;
+	color4ub_t	*colorPtr;
 	drawVert_t	*dv;
 	int		rows, irows, vrows;
 	int		used;
@@ -1302,7 +1521,6 @@
 	int		numVertexes;
 	int		dlightBits;
 	int		*vDlightBits;
-	qboolean	needsNormal;
 
 	dlightBits = cv->dlightBits[backEnd.smpFrame];
 	tess.dlightBits |= dlightBits;
@@ -1335,66 +1553,70 @@
 	lodHeight++;
 
 
+	if ( !tess.indexPtr ) {
+		tess.numVertexes += lodWidth * lodHeight;
+		tess.numIndexes  += 6 * (lodWidth - 1) * (lodHeight - 1);
+		return;
+	}
+
 	// very large grids may have more points or indexes than can be fit
 	// in the tess structure, so we may have to issue it in multiple passes
 
 	used = 0;
 	rows = 0;
 	while ( used < lodHeight - 1 ) {
-		// see how many rows of both verts and indexes we can add without overflowing
-		do {
-			vrows = ( SHADER_MAX_VERTEXES - tess.numVertexes ) / lodWidth;
-			irows = ( SHADER_MAX_INDEXES - tess.numIndexes ) / ( lodWidth * 6 );
-
-			// if we don't have enough space for at least one strip, flush the buffer
-			if ( vrows < 2 || irows < 1 ) {
-				RB_EndSurface();
-				RB_BeginSurface(tess.shader, tess.fogNum );
-			} else {
-				break;
+		if ( tess.xyzPtr == &tess.xyz[0] ) {
+			// see how many rows of both verts and indexes we can add without overflowing
+			do {
+				vrows = ( SHADER_MAX_VERTEXES - tess.numVertexes ) / lodWidth;
+				irows = ( SHADER_MAX_INDEXES - tess.numIndexes ) / ( lodWidth * 6 );
+				
+				// if we don't have enough space for at least one strip, flush the buffer
+				if ( vrows < 2 || irows < 1 ) {
+					RB_EndSurface();
+					RB_BeginSurface(tess.shader, tess.fogNum );
+				} else {
+					break;
+				}
+			} while ( 1 );
+			
+			rows = irows;
+			if ( vrows < irows + 1 ) {
+				rows = vrows - 1;
 			}
-		} while ( 1 );
-		
-		rows = irows;
-		if ( vrows < irows + 1 ) {
-			rows = vrows - 1;
-		}
-		if ( used + rows > lodHeight ) {
-			rows = lodHeight - used;
+			if ( used + rows > lodHeight ) {
+				rows = lodHeight - used;
+			}
+		} else {
+			rows = lodHeight;
 		}
 
 		numVertexes = tess.numVertexes;
 
-		xyz = tess.xyz[numVertexes];
-		normal = tess.normal[numVertexes];
-		texCoords = tess.texCoords[numVertexes][0];
-		color = ( unsigned char * ) &tess.vertexColors[numVertexes];
-		vDlightBits = &tess.vertexDlightBits[numVertexes];
-		needsNormal = tess.shader->needsNormal;
+		xyzPtr = ptrPlusOffset(tess.xyzPtr, tess.xyzInc * numVertexes);
+		normalPtr = ptrPlusOffset(tess.normalPtr, tess.normalInc * numVertexes);
+		texCoordPtr = ptrPlusOffset(tess.texCoordPtr, tess.texCoordInc * numVertexes);
+		texCoord2Ptr = ptrPlusOffset(tess.texCoord2Ptr, tess.texCoord2Inc * numVertexes);
+		colorPtr = ptrPlusOffset(tess.vertexColorPtr, tess.vertexColorInc * numVertexes);
+		vDlightBits = ptrPlusOffset(tess.vertexDlightBitPtr, tess.vertexDlightBitInc * numVertexes);
 
 		for ( i = 0 ; i < rows ; i++ ) {
 			for ( j = 0 ; j < lodWidth ; j++ ) {
 				dv = cv->verts + heightTable[ used + i ] * cv->width
 					+ widthTable[ j ];
 
-				xyz[0] = dv->xyz[0];
-				xyz[1] = dv->xyz[1];
-				xyz[2] = dv->xyz[2];
-				texCoords[0] = dv->st[0];
-				texCoords[1] = dv->st[1];
-				texCoords[2] = dv->lightmap[0];
-				texCoords[3] = dv->lightmap[1];
-				if ( needsNormal ) {
-					normal[0] = dv->normal[0];
-					normal[1] = dv->normal[1];
-					normal[2] = dv->normal[2];
-				}
-				* ( unsigned int * ) color = * ( unsigned int * ) dv->color;
-				*vDlightBits++ = dlightBits;
-				xyz += 4;
-				normal += 4;
-				texCoords += 4;
-				color += 4;
+				VectorCopy( dv->xyz, *(vec3_t *)xyzPtr );
+				xyzPtr = ptrPlusOffset(xyzPtr, tess.xyzInc);
+				Vector2Copy ( dv->st, *texCoordPtr );
+				texCoordPtr = ptrPlusOffset(texCoordPtr, tess.texCoordInc);
+				Vector2Copy ( dv->lightmap, *texCoord2Ptr );
+				texCoord2Ptr = ptrPlusOffset(texCoord2Ptr, tess.texCoord2Inc);
+				VectorCopy( dv->normal, *(vec3_t *)normalPtr );
+				normalPtr = ptrPlusOffset(normalPtr, tess.normalInc);
+				*(unsigned int *)colorPtr = *(unsigned int *)dv->color;
+				colorPtr = ptrPlusOffset(colorPtr, tess.vertexColorInc);
+				*vDlightBits = dlightBits;
+				vDlightBits = ptrPlusOffset(vDlightBits, tess.vertexDlightBitInc);
 			}
 		}
 
@@ -1407,27 +1629,51 @@
 			h = rows - 1;
 			w = lodWidth - 1;
 			numIndexes = tess.numIndexes;
-			for (i = 0 ; i < h ; i++) {
-				for (j = 0 ; j < w ; j++) {
-					int		v1, v2, v3, v4;
-			
-					// vertex order to be reckognized as tristrips
-					v1 = numVertexes + i*lodWidth + j + 1;
-					v2 = v1 - 1;
-					v3 = v2 + lodWidth;
-					v4 = v3 + 1;
 
-					tess.indexes[numIndexes] = v2;
-					tess.indexes[numIndexes+1] = v3;
-					tess.indexes[numIndexes+2] = v1;
-					
-					tess.indexes[numIndexes+3] = v1;
-					tess.indexes[numIndexes+4] = v3;
-					tess.indexes[numIndexes+5] = v4;
-					numIndexes += 6;
+			if ( tess.indexInc == sizeof(GLushort) ) {
+				GLushort *indexPtrShort = (GLushort *)tess.indexPtr;
+				for (i = 0 ; i < h ; i++) {
+					for (j = 0 ; j < w ; j++) {
+						int		v1, v2, v3, v4;
+						
+						// vertex order to be reckognized as tristrips
+						v1 = numVertexes + i*lodWidth + j + 1;
+						v2 = v1 - 1;
+						v3 = v2 + lodWidth;
+						v4 = v3 + 1;
+						
+						indexPtrShort[numIndexes] = v2;
+						indexPtrShort[numIndexes+1] = v3;
+						indexPtrShort[numIndexes+2] = v1;
+						
+						indexPtrShort[numIndexes+3] = v1;
+						indexPtrShort[numIndexes+4] = v3;
+						indexPtrShort[numIndexes+5] = v4;
+						numIndexes += 6;
+					}
+				}
+			} else {
+				for (i = 0 ; i < h ; i++) {
+					for (j = 0 ; j < w ; j++) {
+						int		v1, v2, v3, v4;
+						
+						// vertex order to be reckognized as tristrips
+						v1 = numVertexes + i*lodWidth + j + 1;
+						v2 = v1 - 1;
+						v3 = v2 + lodWidth;
+						v4 = v3 + 1;
+						
+						tess.indexPtr[numIndexes] = v2;
+						tess.indexPtr[numIndexes+1] = v3;
+						tess.indexPtr[numIndexes+2] = v1;
+						
+						tess.indexPtr[numIndexes+3] = v1;
+						tess.indexPtr[numIndexes+4] = v3;
+						tess.indexPtr[numIndexes+5] = v4;
+						numIndexes += 6;
+					}
 				}
 			}
-
 			tess.numIndexes = numIndexes;
 		}
 
@@ -1507,35 +1753,38 @@
 	ri.Printf( PRINT_ALL, "Bad surface tesselated.\n" );
 }
 
-void RB_SurfaceFlare(srfFlare_t *surf)
+void RB_SurfaceFlare( surfaceType_t *surface )
 {
+	srfFlare_t *surf = (srfFlare_t *)surface;
+
 	if (r_flares->integer)
 		RB_AddFlare(surf, tess.fogNum, surf->origin, surf->color, surf->normal);
 }
 
-void RB_SurfaceDisplayList( srfDisplayList_t *surf ) {
+void RB_SurfaceDisplayList( surfaceType_t *surface ) {
+	srfDisplayList_t *surf = (srfDisplayList_t *)surface;
 	// all apropriate state must be set in RB_BeginSurface
 	// this isn't implemented yet...
 	qglCallList( surf->listNum );
 }
 
-void RB_SurfaceSkip( void *surf ) {
+void RB_SurfaceSkip( surfaceType_t *surf ) {
 }
 
 
-void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])( void *) = {
-	(void(*)(void*))RB_SurfaceBad,			// SF_BAD, 
-	(void(*)(void*))RB_SurfaceSkip,			// SF_SKIP, 
-	(void(*)(void*))RB_SurfaceFace,			// SF_FACE,
-	(void(*)(void*))RB_SurfaceGrid,			// SF_GRID,
-	(void(*)(void*))RB_SurfaceTriangles,		// SF_TRIANGLES,
-	(void(*)(void*))RB_SurfacePolychain,		// SF_POLY,
-	(void(*)(void*))RB_SurfaceMesh,			// SF_MD3,
-	(void(*)(void*))RB_SurfaceAnim,			// SF_MD4,
+void (*rb_surfaceTable[SF_NUM_SURFACE_TYPES])( surfaceType_t * ) = {
+	RB_SurfaceBad,			// SF_BAD, 
+	RB_SurfaceSkip,			// SF_SKIP, 
+	RB_SurfaceFace,			// SF_FACE,
+	RB_SurfaceGrid,			// SF_GRID,
+	RB_SurfaceTriangles,		// SF_TRIANGLES,
+	RB_SurfacePolychain,		// SF_POLY,
+	RB_SurfaceMesh,			// SF_MD3,
+	RB_SurfaceAnim,			// SF_MD4,
 #ifdef RAVENMD4
-	(void(*)(void*))RB_MDRSurfaceAnim,		// SF_MDR,
+	RB_MDRSurfaceAnim,		// SF_MDR,
 #endif
-	(void(*)(void*))RB_SurfaceFlare,		// SF_FLARE,
-	(void(*)(void*))RB_SurfaceEntity,		// SF_ENTITY
-	(void(*)(void*))RB_SurfaceDisplayList		// SF_DISPLAY_LIST
+	RB_SurfaceFlare,		// SF_FLARE,
+	RB_SurfaceEntity,		// SF_ENTITY
+	RB_SurfaceDisplayList		// SF_DISPLAY_LIST
 };
diff -r 11104731f8c9 -r 87f98d895296 src/renderer/tr_types.h
--- a/src/renderer/tr_types.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/renderer/tr_types.h	Sun Mar 29 01:15:08 2009 +0800
@@ -212,6 +212,8 @@
 
 	qboolean				textureFilterAnisotropic;
 	int							maxAnisotropy;
+	qboolean                                vertexBufferObjects;
+	qboolean				vertexShaders;
                 
 } glconfig_t;
 
diff -r 11104731f8c9 -r 87f98d895296 src/renderer/tr_world.c
--- a/src/renderer/tr_world.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/renderer/tr_world.c	Sun Mar 29 01:15:08 2009 +0800
@@ -166,6 +166,11 @@
 	int			i;
 	dlight_t	*dl;
 
+	if ( !dlightBits ) {
+		face->dlightBits[ tr.smpFrame ] = dlightBits;
+		return dlightBits;
+	}
+
 	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
 		if ( ! ( dlightBits & ( 1 << i ) ) ) {
 			continue;
@@ -190,6 +195,11 @@
 	int			i;
 	dlight_t	*dl;
 
+	if ( !dlightBits ) {
+		grid->dlightBits[ tr.smpFrame ] = dlightBits;
+		return dlightBits;
+	}
+
 	for ( i = 0 ; i < tr.refdef.num_dlights ; i++ ) {
 		if ( ! ( dlightBits & ( 1 << i ) ) ) {
 			continue;
@@ -216,10 +226,6 @@
 
 
 static int R_DlightTrisurf( srfTriangles_t *surf, int dlightBits ) {
-	// FIXME: more dlight culling to trisurfs...
-	surf->dlightBits[ tr.smpFrame ] = dlightBits;
-	return dlightBits;
-#if 0
 	int			i;
 	dlight_t	*dl;
 
@@ -228,12 +234,12 @@
 			continue;
 		}
 		dl = &tr.refdef.dlights[i];
-		if ( dl->origin[0] - dl->radius > grid->meshBounds[1][0]
-			|| dl->origin[0] + dl->radius < grid->meshBounds[0][0]
-			|| dl->origin[1] - dl->radius > grid->meshBounds[1][1]
-			|| dl->origin[1] + dl->radius < grid->meshBounds[0][1]
-			|| dl->origin[2] - dl->radius > grid->meshBounds[1][2]
-			|| dl->origin[2] + dl->radius < grid->meshBounds[0][2] ) {
+		if ( dl->origin[0] - dl->radius > surf->bounds[1][0]
+			|| dl->origin[0] + dl->radius < surf->bounds[0][0]
+			|| dl->origin[1] - dl->radius > surf->bounds[1][1]
+			|| dl->origin[1] + dl->radius < surf->bounds[0][1]
+			|| dl->origin[2] - dl->radius > surf->bounds[1][2]
+			|| dl->origin[2] + dl->radius < surf->bounds[0][2] ) {
 			// dlight doesn't reach the bounds
 			dlightBits &= ~( 1 << i );
 		}
@@ -243,9 +249,8 @@
 		tr.pc.c_dlightSurfacesCulled++;
 	}
 
-	grid->dlightBits[ tr.smpFrame ] = dlightBits;
+	surf->dlightBits[ tr.smpFrame ] = dlightBits;
 	return dlightBits;
-#endif
 }
 
 /*
@@ -291,15 +296,14 @@
 	// FIXME: bmodel fog?
 
 	// try to cull before dlighting or adding
-	if ( R_CullSurface( surf->data, surf->shader ) ) {
+	if ( !qglBindBufferARB &&
+	     R_CullSurface( surf->data, surf->shader ) ) {
 		return;
 	}
 
 	// check for dlighting
-	if ( dlightBits ) {
-		dlightBits = R_DlightSurface( surf, dlightBits );
-		dlightBits = ( dlightBits != 0 );
-	}
+	dlightBits = R_DlightSurface( surf, dlightBits );
+	dlightBits = ( dlightBits != 0 );
 
 	R_AddDrawSurf( surf->data, surf->shader, surf->fogIndex, dlightBits );
 }
@@ -367,7 +371,7 @@
 		// if the bounding volume is outside the frustum, nothing
 		// inside can be visible OPTIMIZE: don't do this all the way to leafs?
 
-		if ( !r_nocull->integer ) {
+		if ( !r_nocull->integer && !qglBindBufferARB ) {
 			int		r;
 
 			if ( planeBits & 1 ) {
@@ -623,7 +627,8 @@
 		}
 
 		// check for door connection
-		if ( (tr.refdef.areamask[leaf->area>>3] & (1<<(leaf->area&7)) ) ) {
+		if ( !qglBindBufferARB &&
+		    (tr.refdef.areamask[leaf->area>>3] & (1<<(leaf->area&7)) ) ) {
 			continue;		// not visible
 		}
 
diff -r 11104731f8c9 -r 87f98d895296 src/sdl/sdl_glimp.c
--- a/src/sdl/sdl_glimp.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/sdl/sdl_glimp.c	Sun Mar 29 01:15:08 2009 +0800
@@ -24,6 +24,9 @@
 
 #ifdef SMP
 #	include <SDL_thread.h>
+#	ifdef SDL_VIDEO_DRIVER_X11
+#		include <X11/Xlib.h>
+#	endif
 #endif
 
 #include <stdarg.h>
@@ -44,7 +47,7 @@
 
 static QGLContext opengl_context;
 
-static void GLimp_GetCurrentContext()
+static void GLimp_GetCurrentContext(void)
 {
 	opengl_context = CGLGetCurrentContext();
 }
@@ -58,20 +61,46 @@
 		CGLSetCurrentContext(NULL);
 }
 #endif
+#elif SDL_VIDEO_DRIVER_X11
+#include <GL/glx.h>
+typedef struct
+{
+	GLXContext      ctx;
+	Display         *dpy;
+	GLXDrawable     drawable;
+} QGLContext_t;
+typedef QGLContext_t QGLContext;
+
+static QGLContext opengl_context;
+
+static void GLimp_GetCurrentContext(void)
+{
+	opengl_context.ctx = glXGetCurrentContext();
+	opengl_context.dpy = glXGetCurrentDisplay();
+	opengl_context.drawable = glXGetCurrentDrawable();
+}
+
+#ifdef SMP
+static void GLimp_SetCurrentContext(qboolean enable)
+{
+	if(enable)
+		glXMakeCurrent(opengl_context.dpy, opengl_context.drawable, opengl_context.ctx);
+	else
+		glXMakeCurrent(opengl_context.dpy, None, NULL);
+}
+#endif
 #elif WIN32
 typedef struct
 {
 	HDC             hDC;		// handle to device context
 	HGLRC           hGLRC;		// handle to GL rendering context
 } QGLContext_t;
-typedef QGLContext_t *QGLContext;
+typedef QGLContext_t QGLContext;
 
 static QGLContext opengl_context;
 
 static void GLimp_GetCurrentContext(void)
 {
-	static QGLContext_t ctx;
-
 	SDL_SysWMinfo info;
 
 	SDL_VERSION(&info.version);
@@ -81,19 +110,17 @@
 		return;
 	}
 
-	ctx.hDC = GetDC(info.window);
-	ctx.hGLRC = info.hglrc;
-
-	opengl_context = &ctx;
+	opengl_context.hDC = GetDC(info.window);
+	opengl_context.hGLRC = info.hglrc;
 }
 
 #ifdef SMP
 static void GLimp_SetCurrentContext(qboolean enable)
 {
 	if(enable)
-		wglMakeCurrent(opengl_context->hDC, opengl_context->hGLRC);
+		wglMakeCurrent(opengl_context.hDC, opengl_context.hGLRC);
 	else
-		wglMakeCurrent(opengl_context->hDC, NULL);
+		wglMakeCurrent(opengl_context.hDC, NULL);
 }
 #endif
 #else
@@ -119,6 +146,8 @@
 cvar_t *r_allowSoftwareGL; // Don't abort out if a hardware visual can't be obtained
 cvar_t *r_sdlDriver;
 
+void (APIENTRYP qglDrawRangeElementsEXT) (GLenum mode, GLsizei count, GLuint start, GLuint end, GLenum type, const GLvoid *indices);
+
 void (APIENTRYP qglActiveTextureARB) (GLenum texture);
 void (APIENTRYP qglClientActiveTextureARB) (GLenum texture);
 void (APIENTRYP qglMultiTexCoord2fARB) (GLenum target, GLfloat s, GLfloat t);
@@ -126,6 +155,148 @@
 void (APIENTRYP qglLockArraysEXT) (GLint first, GLsizei count);
 void (APIENTRYP qglUnlockArraysEXT) (void);
 
+void (APIENTRYP qglBindBufferARB) (GLenum target, GLuint buffer);
+void (APIENTRYP qglDeleteBuffersARB) (GLsizei n, const GLuint *buffers);
+void (APIENTRYP qglGenBuffersARB) (GLsizei n, GLuint *buffers);
+GLboolean (APIENTRYP qglIsBufferARB) (GLuint buffer);
+void (APIENTRYP qglBufferDataARB) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
+void (APIENTRYP qglBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
+void (APIENTRYP qglGetBufferSubDataARB) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
+GLvoid *(APIENTRYP qglMapBufferARB) (GLenum target, GLenum access);
+GLboolean (APIENTRYP qglUnmapBufferARB) (GLenum target);
+void (APIENTRYP qglGetBufferParameterivARB) (GLenum target, GLenum pname, GLint *params);
+void (APIENTRYP qglGetBufferPointervARB) (GLenum target, GLenum pname, GLvoid **params);
+
+// GL_ARB_shader_objects
+GLvoid (APIENTRYP qglDeleteObjectARB) (GLhandleARB obj);
+GLhandleARB (APIENTRYP qglGetHandleARB) (GLenum pname);
+GLvoid (APIENTRYP qglDetachObjectARB) (GLhandleARB containerObj, GLhandleARB attachedObj);
+GLhandleARB (APIENTRYP qglCreateShaderObjectARB) (GLenum shaderType);
+GLvoid (APIENTRYP qglShaderSourceARB) (GLhandleARB shaderObj, GLsizei count, const GLcharARB **string,
+				       const GLint *length);
+GLvoid (APIENTRYP qglCompileShaderARB) (GLhandleARB shaderObj);
+GLhandleARB (APIENTRYP qglCreateProgramObjectARB) (void);
+GLvoid (APIENTRYP qglAttachObjectARB) (GLhandleARB containerObj, GLhandleARB obj);
+GLvoid (APIENTRYP qglLinkProgramARB) (GLhandleARB programObj);
+GLvoid (APIENTRYP qglUseProgramObjectARB) (GLhandleARB programObj);
+GLvoid (APIENTRYP qglValidateProgramARB) (GLhandleARB programObj);
+GLvoid (APIENTRYP qglUniform1fARB) (GLint location, GLfloat v0);
+GLvoid (APIENTRYP qglUniform2fARB) (GLint location, GLfloat v0, GLfloat v1);
+GLvoid (APIENTRYP qglUniform3fARB) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+GLvoid (APIENTRYP qglUniform4fARB) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+GLvoid (APIENTRYP qglUniform1iARB) (GLint location, GLint v0);
+GLvoid (APIENTRYP qglUniform2iARB) (GLint location, GLint v0, GLint v1);
+GLvoid (APIENTRYP qglUniform3iARB) (GLint location, GLint v0, GLint v1, GLint v2);
+GLvoid (APIENTRYP qglUniform4iARB) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+GLvoid (APIENTRYP qglUniform1fvARB) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRYP qglUniform2fvARB) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRYP qglUniform3fvARB) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRYP qglUniform4fvARB) (GLint location, GLsizei count, const GLfloat *value);
+GLvoid (APIENTRYP qglUniform1ivARB) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRYP qglUniform2ivARB) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRYP qglUniform3ivARB) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRYP qglUniform4ivARB) (GLint location, GLsizei count, const GLint *value);
+GLvoid (APIENTRYP qglUniformMatrix2fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+GLvoid (APIENTRYP qglUniformMatrix3fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+GLvoid (APIENTRYP qglUniformMatrix4fvARB) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+GLvoid (APIENTRYP qglGetObjectParameterfvARB) (GLhandleARB obj, GLenum pname, GLfloat *params);
+GLvoid (APIENTRYP qglGetObjectParameterivARB) (GLhandleARB obj, GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglGetInfoLogARB) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
+GLvoid (APIENTRYP qglGetAttachedObjectsARB) (GLhandleARB containerObj, GLsizei maxCount, GLsizei *count,
+					     GLhandleARB *obj);
+GLint (APIENTRYP qglGetUniformLocationARB) (GLhandleARB programObj, const GLcharARB *name);
+GLvoid (APIENTRYP qglGetActiveUniformARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
+					   GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+GLvoid (APIENTRYP qglGetUniformfvARB) (GLhandleARB programObj, GLint location, GLfloat *params);
+GLvoid (APIENTRYP qglGetUniformivARB) (GLhandleARB programObj, GLint location, GLint *params);
+GLvoid (APIENTRYP qglGetShaderSourceARB) (GLhandleARB obj, GLsizei maxLength, GLsizei *length,
+					  GLcharARB *source);
+
+// GL_ARB_vertex_shader
+GLvoid (APIENTRYP qglVertexAttrib1fARB) (GLuint index, GLfloat v0);
+GLvoid (APIENTRYP qglVertexAttrib1sARB) (GLuint index, GLshort v0);
+GLvoid (APIENTRYP qglVertexAttrib1dARB) (GLuint index, GLdouble v0);
+GLvoid (APIENTRYP qglVertexAttrib2fARB) (GLuint index, GLfloat v0, GLfloat v1);
+GLvoid (APIENTRYP qglVertexAttrib2sARB) (GLuint index, GLshort v0, GLshort v1);
+GLvoid (APIENTRYP qglVertexAttrib2dARB) (GLuint index, GLdouble v0, GLdouble v1);
+GLvoid (APIENTRYP qglVertexAttrib3fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2);
+GLvoid (APIENTRYP qglVertexAttrib3sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2);
+GLvoid (APIENTRYP qglVertexAttrib3dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
+GLvoid (APIENTRYP qglVertexAttrib4fARB) (GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+GLvoid (APIENTRYP qglVertexAttrib4sARB) (GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3);
+GLvoid (APIENTRYP qglVertexAttrib4dARB) (GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
+GLvoid (APIENTRYP qglVertexAttrib4NubARB) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+GLvoid (APIENTRYP qglVertexAttrib1fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRYP qglVertexAttrib1svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib1dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRYP qglVertexAttrib2fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRYP qglVertexAttrib2svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib2dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRYP qglVertexAttrib3fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRYP qglVertexAttrib3svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib3dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRYP qglVertexAttrib4fvARB) (GLuint index, GLfloat *v);
+GLvoid (APIENTRYP qglVertexAttrib4svARB) (GLuint index, GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib4dvARB) (GLuint index, GLdouble *v);
+GLvoid (APIENTRYP qglVertexAttrib4ivARB) (GLuint index, GLint *v);
+GLvoid (APIENTRYP qglVertexAttrib4bvARB) (GLuint index, GLbyte *v);
+GLvoid (APIENTRYP qglVertexAttrib4ubvARB) (GLuint index, GLubyte *v);
+GLvoid (APIENTRYP qglVertexAttrib4usvARB) (GLuint index, GLushort *v);
+GLvoid (APIENTRYP qglVertexAttrib4uivARB) (GLuint index, GLuint *v);
+GLvoid (APIENTRYP qglVertexAttrib4NbvARB) (GLuint index, const GLbyte *v);
+GLvoid (APIENTRYP qglVertexAttrib4NsvARB) (GLuint index, const GLshort *v);
+GLvoid (APIENTRYP qglVertexAttrib4NivARB) (GLuint index, const GLint *v);
+GLvoid (APIENTRYP qglVertexAttrib4NubvARB) (GLuint index, const GLubyte *v);
+GLvoid (APIENTRYP qglVertexAttrib4NusvARB) (GLuint index, const GLushort *v);
+GLvoid (APIENTRYP qglVertexAttrib4NuivARB) (GLuint index, const GLuint *v);
+GLvoid (APIENTRYP qglVertexAttribPointerARB) (GLuint index, GLint size, GLenum type, GLboolean normalized,
+					      GLsizei stride, const GLvoid *pointer);
+GLvoid (APIENTRYP qglEnableVertexAttribArrayARB) (GLuint index);
+GLvoid (APIENTRYP qglDisableVertexAttribArrayARB) (GLuint index);
+GLvoid (APIENTRYP qglBindAttribLocationARB) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
+GLvoid (APIENTRYP qglGetActiveAttribARB) (GLhandleARB programObj, GLuint index, GLsizei maxLength,
+					  GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+GLint (APIENTRYP qglGetAttribLocationARB) (GLhandleARB programObj, const GLcharARB *name);
+GLvoid (APIENTRYP qglGetVertexAttribdvARB) (GLuint index, GLenum pname, GLdouble *params);
+GLvoid (APIENTRYP qglGetVertexAttribfvARB) (GLuint index, GLenum pname, GLfloat *params);
+GLvoid (APIENTRYP qglGetVertexAttribivARB) (GLuint index, GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglGetVertexAttribPointervARB) (GLuint index, GLenum pname, GLvoid **pointer);
+
+// GL_ARB_framebuffer_object
+GLboolean (APIENTRYP qglIsRenderbuffer) (GLuint renderbuffer);
+GLvoid (APIENTRYP qglBindRenderbuffer) (GLenum target, GLuint renderbuffer);
+GLvoid (APIENTRYP qglDeleteRenderbuffers) (GLsizei n, const GLuint *renderbuffers);
+GLvoid (APIENTRYP qglGenRenderbuffers) (GLsizei n, GLuint *renderbuffers);
+GLvoid (APIENTRYP qglRenderbufferStorage) (GLenum target, GLenum internalformat,
+					   GLsizei width, GLsizei height);
+GLvoid (APIENTRYP qglRenderbufferStorageMultisample) (GLenum target, GLsizei samples,
+						      GLenum internalformat,
+						      GLsizei width, GLsizei height);
+GLvoid (APIENTRYP qglGetRenderbufferParameteriv) (GLenum target, GLenum pname, GLint *params);
+GLboolean (APIENTRYP qglIsFramebuffer) (GLuint framebuffer);
+GLvoid (APIENTRYP qglBindFramebuffer) (GLenum target, GLuint framebuffer);
+GLvoid (APIENTRYP qglDeleteFramebuffers) (GLsizei n, const GLuint *framebuffers);
+GLvoid (APIENTRYP qglGenFramebuffers) (GLsizei n, GLuint *framebuffers);
+GLenum (APIENTRYP qglCheckFramebufferStatus) (GLenum target);
+GLvoid (APIENTRYP qglFramebufferTexture1D) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture, GLint level);
+GLvoid (APIENTRYP qglFramebufferTexture2D) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture, GLint level);
+GLvoid (APIENTRYP qglFramebufferTexture3D) (GLenum target, GLenum attachment,
+					    GLenum textarget, GLuint texture,
+					    GLint level, GLint layer);
+GLvoid (APIENTRYP qglFramebufferTextureLayer) (GLenum target, GLenum attachment,
+					       GLuint texture, GLint level, GLint layer);
+GLvoid (APIENTRYP qglFramebufferRenderbuffer) (GLenum target, GLenum attachment,
+					       GLenum renderbuffertarget, GLuint renderbuffer);
+GLvoid (APIENTRYP qglGetFramebufferAttachmentParameteriv) (GLenum target, GLenum attachment,
+							   GLenum pname, GLint *params);
+GLvoid (APIENTRYP qglBlitFramebuffer) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
+				       GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
+				       GLbitfield mask, GLenum filter);
+GLvoid (APIENTRYP qglGenerateMipmap) (GLenum target);
+
+
 /*
 ===============
 GLimp_Shutdown
@@ -273,6 +444,7 @@
 	int i = 0;
 	SDL_Surface *vidscreen = NULL;
 	Uint32 flags = SDL_OPENGL;
+	static int desktop_w, desktop_h;  // desktop resolution 
 
 	ri.Printf( PRINT_DEVELOPER, "Initializing OpenGL display\n");
 
@@ -280,7 +452,11 @@
 	// by assuming (relatively safely) that it is set at or close to
 	// the display's native aspect ratio
 	videoInfo = SDL_GetVideoInfo();
-	glConfig.displayAspect = (float)videoInfo->current_w / (float)videoInfo->current_h;
+	if( !desktop_w ) { // first time through, resolve desktop resolution
+		desktop_w = videoInfo->current_w;
+		desktop_h = videoInfo->current_h;
+	}
+	glConfig.displayAspect = (float)desktop_w / (float)desktop_h;
 
 	ri.Printf( PRINT_DEVELOPER, "Estimated display aspect: %.3f\n", glConfig.displayAspect );
 
@@ -311,10 +487,9 @@
 		r_height->modified = qfalse;
 		r_pixelAspect->modified = qfalse;
 		r_mode->modified = qfalse;
-		glConfig.vidWidth = r_width->integer;
-		glConfig.vidHeight = r_height->integer;
-		glConfig.windowAspect = r_width->value /
-			( r_height->value * r_pixelAspect->value );
+		glConfig.vidWidth = ( r_width->integer ? r_width->integer : desktop_w );
+		glConfig.vidHeight = ( r_height->integer ? r_height->integer : desktop_h );
+		glConfig.windowAspect = glConfig.vidWidth / ( (float)glConfig.vidHeight * r_pixelAspect->value );
 	}
 	else if( glConfig.vidWidth != R_FAILSAFE_WIDTH &&
 			glConfig.vidHeight != R_FAILSAFE_HEIGHT )
@@ -563,6 +738,12 @@
 
 	ri.Printf( PRINT_DEVELOPER, "Initializing OpenGL extensions\n" );
 
+	// GL_EXT_draw_range_elements
+	if ( GLimp_HaveExtension( "GL_EXT_draw_range_elements" ) )
+	{
+		qglDrawRangeElementsEXT = SDL_GL_GetProcAddress( "glDrawRangeElementsEXT" );
+	}
+
 	glConfig.textureCompression = TC_NONE;
 
 	// GL_EXT_texture_compression_s3tc
@@ -643,9 +824,14 @@
 				GLint glint = 0;
 				qglGetIntegerv( GL_MAX_TEXTURE_UNITS_ARB, &glint );
 				glConfig.numTextureUnits = (int) glint;
+				if ( glConfig.numTextureUnits > NUM_TEXTURE_BUNDLES )
+					glConfig.numTextureUnits = NUM_TEXTURE_BUNDLES;
+				if ( r_ext_multitexture->integer > 1 &&
+				     glConfig.numTextureUnits > r_ext_multitexture->integer )
+					glConfig.numTextureUnits = r_ext_multitexture->integer;
 				if ( glConfig.numTextureUnits > 1 )
 				{
-					ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_multitexture\n" );
+					ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_multitexture (%d of %d units)\n", glConfig.numTextureUnits, glint );
 				}
 				else
 				{
@@ -666,6 +852,45 @@
 		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_multitexture not found\n" );
 	}
 
+	glConfig.vertexBufferObjects = qfalse;
+	qglBindBufferARB = NULL;
+	qglDeleteBuffersARB = NULL;
+	qglGenBuffersARB = NULL;
+	qglIsBufferARB = NULL;
+	qglBufferDataARB = NULL;
+	qglBufferSubDataARB = NULL;
+	qglGetBufferSubDataARB = NULL;
+	qglMapBufferARB = NULL;
+	qglUnmapBufferARB = NULL;
+	qglGetBufferParameterivARB = NULL;
+	qglGetBufferPointervARB = NULL;
+	if ( GLimp_HaveExtension( "GL_ARB_vertex_buffer_object" ) )
+	{
+		if ( r_ext_vertex_buffer_object->integer ) {
+			qglBindBufferARB = (void (APIENTRYP)(GLenum, GLuint)) SDL_GL_GetProcAddress("glBindBufferARB");
+			qglDeleteBuffersARB = (void (APIENTRYP)(GLsizei, const GLuint *)) SDL_GL_GetProcAddress("glDeleteBuffersARB");
+			qglGenBuffersARB = (void (APIENTRYP)(GLsizei, GLuint *)) SDL_GL_GetProcAddress("glGenBuffersARB");
+			qglIsBufferARB = (GLboolean (APIENTRYP)(GLuint)) SDL_GL_GetProcAddress("glIsBufferARB");
+			qglBufferDataARB = (void (APIENTRYP)(GLenum, GLsizeiptrARB, const GLvoid *, GLenum)) SDL_GL_GetProcAddress("glBufferDataARB");
+			qglBufferSubDataARB = (void (APIENTRYP)(GLenum, GLintptrARB, GLsizeiptrARB, const GLvoid *)) SDL_GL_GetProcAddress("glBufferSubDataARB");
+			qglGetBufferSubDataARB = (void (APIENTRYP)(GLenum, GLintptrARB, GLsizeiptrARB, GLvoid *)) SDL_GL_GetProcAddress("glGetBufferSubDataARB");
+			qglMapBufferARB = (GLvoid *(APIENTRYP)(GLenum, GLenum)) SDL_GL_GetProcAddress("glMapBufferARB");
+			qglUnmapBufferARB = (GLboolean (APIENTRYP)(GLenum)) SDL_GL_GetProcAddress("glUnmapBufferARB");
+			qglGetBufferParameterivARB = (void (APIENTRYP)(GLenum, GLenum, GLint *)) SDL_GL_GetProcAddress("glGetBufferParameterivARB");
+			qglGetBufferPointervARB = (void (APIENTRYP)(GLenum, GLenum, GLvoid **)) SDL_GL_GetProcAddress("glGetBufferPointervARB");
+			glConfig.vertexBufferObjects = qtrue;
+			ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_vertex_buffer_object\n" );
+		}
+		else
+		{
+			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_vertex_buffer_object\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_vertex_buffer_object not found\n" );
+	}
+
 	// GL_EXT_compiled_vertex_array
 	if ( GLimp_HaveExtension( "GL_EXT_compiled_vertex_array" ) )
 	{
@@ -713,6 +938,171 @@
 	{
 		ri.Printf( PRINT_DEVELOPER, "...GL_EXT_texture_filter_anisotropic not found\n" );
 	}
+
+	glConfig.vertexShaders = qfalse;
+	if ( GLimp_HaveExtension( "GL_ARB_shader_objects" )
+	     && GLimp_HaveExtension( "GL_ARB_fragment_shader" )
+	     && GLimp_HaveExtension( "GL_ARB_vertex_shader" )
+	     && GLimp_HaveExtension( "GL_ARB_shading_language_100" ) )
+	{
+		if ( r_ext_vertex_shader->integer ) {
+		  ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_vertex_shader\n" );
+		  
+		  qglDeleteObjectARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glDeleteObjectARB");
+		  qglGetHandleARB = (GLhandleARB (APIENTRYP)(GLenum)) SDL_GL_GetProcAddress("glGetHandleARB");
+		  qglDetachObjectARB = (GLvoid (APIENTRYP)(GLhandleARB, GLhandleARB)) SDL_GL_GetProcAddress("glDetachObjectARB");
+		  qglCreateShaderObjectARB = (GLhandleARB (APIENTRYP)(GLenum)) SDL_GL_GetProcAddress("glCreateShaderObjectARB");
+		  qglShaderSourceARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, const GLcharARB **,
+							   const GLint *)) SDL_GL_GetProcAddress("glShaderSourceARB");
+		  qglCompileShaderARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glCompileShaderARB");
+		  qglCreateProgramObjectARB = (GLhandleARB (APIENTRYP)(void)) SDL_GL_GetProcAddress("glCreateProgramObjectARB");
+		  qglAttachObjectARB = (GLvoid (APIENTRYP)(GLhandleARB, GLhandleARB)) SDL_GL_GetProcAddress("glAttachObjectARB");
+		  qglLinkProgramARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glLinkProgramARB");
+		  qglUseProgramObjectARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glUseProgramObjectARB");
+		  qglValidateProgramARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glValidateProgramARB");
+		  qglUniform1fARB = (GLvoid (APIENTRYP)(GLint, GLfloat)) SDL_GL_GetProcAddress("glUniform1fARB");
+		  qglUniform2fARB = (GLvoid (APIENTRYP)(GLint, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform2fARB");
+		  qglUniform3fARB = (GLvoid (APIENTRYP)(GLint, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform3fARB");
+		  qglUniform4fARB = (GLvoid (APIENTRYP)(GLint, GLfloat, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform4fARB");
+		  qglUniform1iARB = (GLvoid (APIENTRYP)(GLint, GLint)) SDL_GL_GetProcAddress("glUniform1iARB");
+		  qglUniform2iARB = (GLvoid (APIENTRYP)(GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform2iARB");
+		  qglUniform3iARB = (GLvoid (APIENTRYP)(GLint, GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform3iARB");
+		  qglUniform4iARB = (GLvoid (APIENTRYP)(GLint, GLint, GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform4iARB");
+		  qglUniform1fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform1fvARB");
+		  qglUniform2fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform2fvARB");
+		  qglUniform3fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform3fvARB");
+		  qglUniform4fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform4fvARB");
+		  qglUniform1ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform1viARB");
+		  qglUniform2ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform2ivARB");
+		  qglUniform3ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform3ivARB");
+		  qglUniform4ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform4ivARB");
+		  qglUniformMatrix2fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv2ARB");
+		  qglUniformMatrix3fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv3ARB");
+		  qglUniformMatrix4fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv4ARB");
+		  qglGetObjectParameterfvARB = (GLvoid (APIENTRYP)(GLhandleARB, GLenum, GLfloat *)) SDL_GL_GetProcAddress("glGetObjectParameterfvARB");
+		  qglGetObjectParameterivARB = (GLvoid (APIENTRYP)(GLhandleARB, GLenum, GLint *)) SDL_GL_GetProcAddress("glGetObjectParameterivARB");
+		  qglGetInfoLogARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, GLsizei *, GLcharARB *)) SDL_GL_GetProcAddress("glGetInfoLogARB");
+		  qglGetAttachedObjectsARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, GLsizei *, GLhandleARB *)) SDL_GL_GetProcAddress("glGetAttachedObjectsARB");
+		  qglGetUniformLocationARB = (GLint (APIENTRYP)(GLhandleARB, const GLcharARB *)) SDL_GL_GetProcAddress("glGetUniformLocationARB");
+		  qglGetActiveUniformARB = (GLvoid (APIENTRYP)(GLhandleARB, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLcharARB *)) SDL_GL_GetProcAddress("glGetActiveUniformARB");
+		  qglGetUniformfvARB = (GLvoid (APIENTRYP)(GLhandleARB, GLint, GLfloat *)) SDL_GL_GetProcAddress("glGetUniformfvARB");
+		  qglGetUniformivARB = (GLvoid (APIENTRYP)(GLhandleARB, GLint, GLint *)) SDL_GL_GetProcAddress("glGetUniformivARB");
+		  qglGetShaderSourceARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, GLsizei *, GLcharARB *)) SDL_GL_GetProcAddress("glGetShaderSourceARB");
+
+		  qglVertexAttrib1fARB = (GLvoid (APIENTRYP)(GLuint, GLfloat)) SDL_GL_GetProcAddress("glVertexAttrib1fARB");
+		  qglVertexAttrib1sARB = (GLvoid (APIENTRYP)(GLuint, GLshort)) SDL_GL_GetProcAddress("glVertexAttrib1sARB");
+		  qglVertexAttrib1dARB = (GLvoid (APIENTRYP)(GLuint, GLdouble)) SDL_GL_GetProcAddress("glVertexAttrib1dARB");
+		  qglVertexAttrib2fARB = (GLvoid (APIENTRYP)(GLuint, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glVertexAttrib2fARB");
+		  qglVertexAttrib2sARB = (GLvoid (APIENTRYP)(GLuint, GLshort, GLshort)) SDL_GL_GetProcAddress("glVertexAttrib2sARB");
+		  qglVertexAttrib2dARB = (GLvoid (APIENTRYP)(GLuint, GLdouble, GLdouble)) SDL_GL_GetProcAddress("glVertexAttrib2dARB");
+		  qglVertexAttrib3fARB = (GLvoid (APIENTRYP)(GLuint, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glVertexAttrib3fARB");
+		  qglVertexAttrib3sARB = (GLvoid (APIENTRYP)(GLuint, GLshort, GLshort, GLshort)) SDL_GL_GetProcAddress("glVertexAttrib3sARB");
+		  qglVertexAttrib3dARB = (GLvoid (APIENTRYP)(GLuint, GLdouble, GLdouble, GLdouble)) SDL_GL_GetProcAddress("glVertexAttrib3dARB");
+		  qglVertexAttrib4fARB = (GLvoid (APIENTRYP)(GLuint, GLfloat, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glVertexAttrib4fARB");
+		  qglVertexAttrib4sARB = (GLvoid (APIENTRYP)(GLuint, GLshort, GLshort, GLshort, GLshort)) SDL_GL_GetProcAddress("glVertexAttrib4sARB");
+		  qglVertexAttrib4dARB = (GLvoid (APIENTRYP)(GLuint, GLdouble, GLdouble, GLdouble, GLdouble)) SDL_GL_GetProcAddress("glVertexAttrib4dARB");
+		  qglVertexAttrib4NubARB = (GLvoid (APIENTRYP)(GLuint, GLubyte, GLubyte, GLubyte, GLubyte)) SDL_GL_GetProcAddress("glVertexAttrib4NubARB");
+		  qglVertexAttrib1fvARB = (GLvoid (APIENTRYP)(GLuint, GLfloat *)) SDL_GL_GetProcAddress("glVertexAttrib1fvARB");
+		  qglVertexAttrib1svARB = (GLvoid (APIENTRYP)(GLuint, GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib1svARB");
+		  qglVertexAttrib1dvARB = (GLvoid (APIENTRYP)(GLuint, GLdouble *)) SDL_GL_GetProcAddress("glVertexAttrib1dvARB");
+		  qglVertexAttrib2fvARB = (GLvoid (APIENTRYP)(GLuint, GLfloat *)) SDL_GL_GetProcAddress("glVertexAttrib2fvARB");
+		  qglVertexAttrib2svARB = (GLvoid (APIENTRYP)(GLuint, GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib2svARB");
+		  qglVertexAttrib2dvARB = (GLvoid (APIENTRYP)(GLuint, GLdouble *)) SDL_GL_GetProcAddress("glVertexAttrib2dvARB");
+		  qglVertexAttrib3fvARB = (GLvoid (APIENTRYP)(GLuint, GLfloat *)) SDL_GL_GetProcAddress("glVertexAttrib3fvARB");
+		  qglVertexAttrib3svARB = (GLvoid (APIENTRYP)(GLuint, GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib3svARB");
+		  qglVertexAttrib3dvARB = (GLvoid (APIENTRYP)(GLuint, GLdouble *)) SDL_GL_GetProcAddress("glVertexAttrib3dvARB");
+		  qglVertexAttrib4fvARB = (GLvoid (APIENTRYP)(GLuint, GLfloat *)) SDL_GL_GetProcAddress("glVertexAttrib4fvARB");
+		  qglVertexAttrib4svARB = (GLvoid (APIENTRYP)(GLuint, GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib4svARB");
+		  qglVertexAttrib4dvARB = (GLvoid (APIENTRYP)(GLuint, GLdouble *)) SDL_GL_GetProcAddress("glVertexAttrib4dvARB");
+		  qglVertexAttrib4ivARB = (GLvoid (APIENTRYP)(GLuint, GLint *)) SDL_GL_GetProcAddress("glVertexAttrib4ivARB");
+		  qglVertexAttrib4bvARB = (GLvoid (APIENTRYP)(GLuint, GLbyte *)) SDL_GL_GetProcAddress("glVertexAttrib4bvARB");
+		  qglVertexAttrib4ubvARB = (GLvoid (APIENTRYP)(GLuint, GLubyte *)) SDL_GL_GetProcAddress("glVertexAttrib4ubvARB");
+		  qglVertexAttrib4usvARB = (GLvoid (APIENTRYP)(GLuint, GLushort *)) SDL_GL_GetProcAddress("glVertexAttrib4usvARB");
+		  qglVertexAttrib4uivARB = (GLvoid (APIENTRYP)(GLuint, GLuint *)) SDL_GL_GetProcAddress("glVertexAttrib4uivARB");
+		  qglVertexAttrib4NbvARB = (GLvoid (APIENTRYP)(GLuint, const GLbyte *)) SDL_GL_GetProcAddress("glVertexAttrib4NbvARB");
+		  qglVertexAttrib4NsvARB = (GLvoid (APIENTRYP)(GLuint, const GLshort *)) SDL_GL_GetProcAddress("glVertexAttrib4NsvARB");
+		  qglVertexAttrib4NivARB = (GLvoid (APIENTRYP)(GLuint, const GLint *)) SDL_GL_GetProcAddress("glVertexAttrib4NivARB");
+		  qglVertexAttrib4NubvARB = (GLvoid (APIENTRYP)(GLuint, const GLubyte *)) SDL_GL_GetProcAddress("glVertexAttrib4NubvARB");
+		  qglVertexAttrib4NusvARB = (GLvoid (APIENTRYP)(GLuint, const GLushort *)) SDL_GL_GetProcAddress("glVertexAttrib4NusvARB");
+		  qglVertexAttrib4NuivARB = (GLvoid (APIENTRYP)(GLuint, const GLuint *)) SDL_GL_GetProcAddress("glVertexAttrib4NuivARB");
+		  qglVertexAttribPointerARB = (GLvoid (APIENTRYP)(GLuint, GLint, GLenum, GLboolean, GLsizei, const GLvoid *)) SDL_GL_GetProcAddress("glVertexAttribPointerARB");
+		  qglEnableVertexAttribArrayARB = (GLvoid (APIENTRYP)(GLuint)) SDL_GL_GetProcAddress("glEnableVertexAttribArrayARB");
+		  qglDisableVertexAttribArrayARB = (GLvoid (APIENTRYP)(GLuint)) SDL_GL_GetProcAddress("glDisableVertexAttribArrayARB");
+		  qglBindAttribLocationARB = (GLvoid (APIENTRYP)(GLhandleARB, GLuint, const GLcharARB *)) SDL_GL_GetProcAddress("glBindAttribLocationARB");
+		  qglGetActiveAttribARB = (GLvoid (APIENTRYP)(GLhandleARB, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLcharARB *)) SDL_GL_GetProcAddress("glGetActiveAttribARB");
+		  qglGetAttribLocationARB = (GLint (APIENTRYP)(GLhandleARB, const GLcharARB *)) SDL_GL_GetProcAddress("glGetAttribLocationARB");
+		  qglGetVertexAttribdvARB = (GLvoid (APIENTRYP)(GLuint, GLenum, GLdouble *)) SDL_GL_GetProcAddress("glGetVertexAttribdvARB");
+		  qglGetVertexAttribfvARB = (GLvoid (APIENTRYP)(GLuint, GLenum, GLfloat *)) SDL_GL_GetProcAddress("glGetVertexAttribfvARB");
+		  qglGetVertexAttribivARB = (GLvoid (APIENTRYP)(GLuint, GLenum, GLint *)) SDL_GL_GetProcAddress("glGetVertexAAttribivARB");
+		  qglGetVertexAttribPointervARB = (GLvoid (APIENTRYP)(GLuint, GLenum, GLvoid **)) SDL_GL_GetProcAddress("glGetVertexAttribPointervARB");
+
+		  glConfig.vertexShaders = qtrue;
+		}
+		else
+		{
+			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_vertex_shader\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_vertex_shader\n" );
+	}
+
+	if ( GLimp_HaveExtension( "GL_ARB_framebuffer_object" ) )
+	{
+		if ( r_ext_framebuffer_object->integer ) {
+		  ri.Printf( PRINT_DEVELOPER, "...using GL_ARB_framebuffer_object\n" );
+		  
+		  qglDeleteObjectARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glDeleteObjectARB");
+		  qglGetHandleARB = (GLhandleARB (APIENTRYP)(GLenum)) SDL_GL_GetProcAddress("glGetHandleARB");
+		  qglDetachObjectARB = (GLvoid (APIENTRYP)(GLhandleARB, GLhandleARB)) SDL_GL_GetProcAddress("glDetachObjectARB");
+		  qglCreateShaderObjectARB = (GLhandleARB (APIENTRYP)(GLenum)) SDL_GL_GetProcAddress("glCreateShaderObjectARB");
+		  qglShaderSourceARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, const GLcharARB **,
+							   const GLint *)) SDL_GL_GetProcAddress("glShaderSourceARB");
+		  qglCompileShaderARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glCompileShaderARB");
+		  qglCreateProgramObjectARB = (GLhandleARB (APIENTRYP)(void)) SDL_GL_GetProcAddress("glCreateProgramObjectARB");
+		  qglAttachObjectARB = (GLvoid (APIENTRYP)(GLhandleARB, GLhandleARB)) SDL_GL_GetProcAddress("glAttachObjectARB");
+		  qglLinkProgramARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glLinkProgramARB");
+		  qglUseProgramObjectARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glUseProgramObjectARB");
+		  qglValidateProgramARB = (GLvoid (APIENTRYP)(GLhandleARB)) SDL_GL_GetProcAddress("glValidateProgramARB");
+		  qglUniform1fARB = (GLvoid (APIENTRYP)(GLint, GLfloat)) SDL_GL_GetProcAddress("glUniform1fARB");
+		  qglUniform2fARB = (GLvoid (APIENTRYP)(GLint, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform2fARB");
+		  qglUniform3fARB = (GLvoid (APIENTRYP)(GLint, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform3fARB");
+		  qglUniform4fARB = (GLvoid (APIENTRYP)(GLint, GLfloat, GLfloat, GLfloat, GLfloat)) SDL_GL_GetProcAddress("glUniform4fARB");
+		  qglUniform1iARB = (GLvoid (APIENTRYP)(GLint, GLint)) SDL_GL_GetProcAddress("glUniform1iARB");
+		  qglUniform2iARB = (GLvoid (APIENTRYP)(GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform2iARB");
+		  qglUniform3iARB = (GLvoid (APIENTRYP)(GLint, GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform3iARB");
+		  qglUniform4iARB = (GLvoid (APIENTRYP)(GLint, GLint, GLint, GLint, GLint)) SDL_GL_GetProcAddress("glUniform4iARB");
+		  qglUniform1fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform1fvARB");
+		  qglUniform2fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform2fvARB");
+		  qglUniform3fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform3fvARB");
+		  qglUniform4fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLfloat *)) SDL_GL_GetProcAddress("glUniform4fvARB");
+		  qglUniform1ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform1viARB");
+		  qglUniform2ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform2ivARB");
+		  qglUniform3ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform3ivARB");
+		  qglUniform4ivARB = (GLvoid (APIENTRYP)(GLint, GLsizei, const GLint *)) SDL_GL_GetProcAddress("glUniform4ivARB");
+		  qglUniformMatrix2fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv2ARB");
+		  qglUniformMatrix3fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv3ARB");
+		  qglUniformMatrix4fvARB = (GLvoid (APIENTRYP)(GLint, GLsizei, GLboolean, const GLfloat *)) SDL_GL_GetProcAddress("glUniformMatrixfv4ARB");
+		  qglGetObjectParameterfvARB = (GLvoid (APIENTRYP)(GLhandleARB, GLenum, GLfloat *)) SDL_GL_GetProcAddress("glGetObjectParameterfvARB");
+		  qglGetObjectParameterivARB = (GLvoid (APIENTRYP)(GLhandleARB, GLenum, GLint *)) SDL_GL_GetProcAddress("glGetObjectParameterivARB");
+		  qglGetInfoLogARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, GLsizei *, GLcharARB *)) SDL_GL_GetProcAddress("glGetInfoLogARB");
+		  qglGetAttachedObjectsARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, GLsizei *, GLhandleARB *)) SDL_GL_GetProcAddress("glGetAttachedObjectsARB");
+		  qglGetUniformLocationARB = (GLint (APIENTRYP)(GLhandleARB, const GLcharARB *)) SDL_GL_GetProcAddress("glGetUniformLocationARB");
+		  qglGetActiveUniformARB = (GLvoid (APIENTRYP)(GLhandleARB, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLcharARB *)) SDL_GL_GetProcAddress("glGetActiveUniformARB");
+		  qglGetUniformfvARB = (GLvoid (APIENTRYP)(GLhandleARB, GLint, GLfloat *)) SDL_GL_GetProcAddress("glGetUniformfvARB");
+		  qglGetUniformivARB = (GLvoid (APIENTRYP)(GLhandleARB, GLint, GLint *)) SDL_GL_GetProcAddress("glGetUniformivARB");
+		  qglGetShaderSourceARB = (GLvoid (APIENTRYP)(GLhandleARB, GLsizei, GLsizei *, GLcharARB *)) SDL_GL_GetProcAddress("glGetShaderSourceARB");
+		}
+		else
+		{
+			ri.Printf( PRINT_DEVELOPER, "...ignoring GL_ARB_framebuffer_object\n" );
+		}
+	}
+	else
+	{
+		ri.Printf( PRINT_DEVELOPER, "...GL_ARB_framebuffer_object\n" );
+	}
 }
 
 /*
@@ -732,6 +1122,10 @@
 
 	Sys_GLimpInit( );
 
+#if defined(SMP) && defined(SDL_VIDEO_DRIVER_X11)
+	XInitThreads( );
+#endif
+
 	// create the window and set up the context
 	if( !GLimp_StartDriverAndSetMode( qfalse, r_fullscreen->integer ) )
 	{
@@ -916,13 +1310,14 @@
 */
 static int GLimp_RenderThreadWrapper( void *arg )
 {
-	Com_Printf( "Render thread starting\n" );
+	// These printfs cause race conditions which mess up the console output
+	//Com_Printf( "Render thread starting\n" );
 
 	glimpRenderThread();
 
 	GLimp_SetCurrentContext(qfalse);
 
-	Com_Printf( "Render thread terminating\n" );
+	//Com_Printf( "Render thread terminating\n" );
 
 	return 0;
 }
@@ -941,7 +1336,7 @@
 		warned = qtrue;
 	}
 
-#if !defined(MACOS_X) && !defined(WIN32)
+#if !defined(MACOS_X) && !defined(WIN32) && !defined (SDL_VIDEO_DRIVER_X11)
 	return qfalse;  /* better safe than sorry for now. */
 #endif
 
diff -r 11104731f8c9 -r 87f98d895296 src/sdl/sdl_icon.h
--- a/src/sdl/sdl_icon.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/sdl/sdl_icon.h	Sun Mar 29 01:15:08 2009 +0800
@@ -4,135 +4,367 @@
   unsigned int 	 width;
   unsigned int 	 height;
   unsigned int 	 bytes_per_pixel; /* 3:RGB, 4:RGBA */ 
-  unsigned char	 pixel_data[32 * 32 * 4 + 1];
+  unsigned char	 pixel_data[48 * 48 * 4 + 1];
 } CLIENT_WINDOW_ICON = {
-  32, 32, 4,
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\17\17\17\34\17\17"
-  "\17U\17\17\17""9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\30\30\30q\2\2\2\306\5\5\5\377\4\4\4\343\33\33\33"
-  "\252\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\31\31"
-  "\31\216\7\7\7\377\0\0\0\377\0\0\0\377\0\0\0\377\3\3\3\377\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0%%%9\0\0"
-  "\0\0\0\0\0\0\10\10\10q\16\16\16q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\11\11\11\377\0\0\0\377\0"
-  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\13\13\13q\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\14\14\14q\15\15\15\343\16\16\16"
-  """9\0\0\0\0\12\12\12\252\10\10\10\377\30\30\30U\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\3\3\377\0\0\0\377"
-  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\252\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\12\12\12\216\3\3\3\377\2\2\2\252\0\0\0"
-  "\0\0\0\0\0\37\37\37""9\3\3\3\377\3\3\3\306\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\2\2\377\0\0\0\377\0"
-  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\3\3\3\343\15\15\15""9\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\14\14\14q\3\3\3\377\2\2\2\377\5\5\5""9\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\16\16\16\306\2\2\2\377\2\2\2\306\5\5\5\34\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\36\36\252\0\0\0\377\0\0\0"
-  "\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\13\13\13\306\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\13\13\13\216\3\3\3\377\4\4\4\377\15\15\15U\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\17\17\17\34\14\14\14\306\1\1\1\377\2\2\2\306"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\36\36\252\0\0"
-  "\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0"
-  "U\0\0\0\0\0\0\0\0(((9\16\16\16\252\3\3\3\377\0\0\0\377\16\16\16\306\36\36"
-  "\36\34\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\306\0\0\0\377"
-  "\3\3\3\306\3\3\3\34\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\36\36q\0\0"
-  "\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\6\6\6\343\31\31"
-  "\31""9\0\0\0\0\0\0\0\0\0\0\0\216\0\0\0\377\2\2\2\377\12\12\12\306\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\26\26\26U\7\7\7"
-  "\377\0\0\0\377\3\3\3\306\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\3\3\3\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\6\6\6\252\0"
-  "\0\0\0\15\15\15""9\6\6\6\252\0\0\0\377\0\0\0\377\12\12\12\306\16\16\16\34"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\6\6\6q\1\1\1\377\0\0\0\377\4\4\4\306\5\5\5\34\0\0\0\0\0\0\0\0\22\22\22\34"
-  "\32\32\32\306\1\1\1\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
-  "\21\21\21\216\33\33\33\306\3\3\3\377\0\0\0\377\1\1\1\377\11\11\11\306\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\3\3\3\216\1\1\1\377\1\1\1\377\4\4\4\306\0\0\0\0\0\0"
-  "\0\0\14\14\14U\4\4\4\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
-  "\0\0\0\377\4\4\4\306\3\3\3\377\0\0\0\377\0\0\0\377\11\11\11\306\15\15\15"
-  "\34\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\5\5\5\252\0\0\0\377\0\0\0\377\3\3\3\377"
-  "\5\5\5\377\3\3\3\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
-  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\1\1\1\343\12\12\12\252\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\16\16""9\7\7\7\377\0\0\0\377\0\0"
-  "\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0"
-  "\377\0\0\0\377\0\0\0\377\0\0\0\377\2\2\2\377\2\2\2""9\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\2\2q\3\3\3\377\0\0"
-  "\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0"
-  "\377\0\0\0\377\0\0\0\377\0\0\0U\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\20\20\216\5\5\5\377\0\0"
-  "\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0"
-  "\377\0\0\0\377\0\0\0\306\0\0\0\252\0\0\0\252\0\0\0\252\0\0\0\252\0\0\0\252"
-  "\0\0\0\252\12\12\12\252\36\36\36""9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\15\15\15U\6\6"
-  "\6\306\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0"
-  "\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\1\1\1\377\0\0\0\252\0\0\0\252"
-  "\0\0\0\252\0\0\0\252\12\12\12\252\36\36\36""9\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\14\14\14""9\4\4\4\252"
-  "\4\4\4\377\1\1\1\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
-  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\2\2\2\216\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\31\31\31U\20\20\20\306\5\5\5\377\0\0\0\377\0\0\0\377"
-  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
-  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\12\12\12\343\26"
-  "\26\26""9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\10\10\377\0\0\0\377\5\5\5\377\5\5\5\377"
-  "\0\0\0U\6\6\6\306\1\1\1\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0"
-  "\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\24\24\24"
-  """9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\"\"\"\252###\252\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\21\21\21""9\7\7\7\343\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
-  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\20\20\20\306"
-  "\30\30\30\34\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\7\7\7\252\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
-  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\3\3\3\377\22\22"
-  "\22\306\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\23\23\23U\6\6\6\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0"
-  "\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
-  "\22\22\22\306\36\36\36\34\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\14\14\14\306\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0"
-  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\2\2\2\377\4\4\4\216\3\3\3\216\2\2"
-  "\2\377\5\5\5\377\17\17\17U\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\2\2\2\377\4\4\4\377\1\1\1\252\1\1\1\252\4\4\4\377\0\0\0\377\0"
-  "\0\0\377\0\0\0\377\0\0\0\377\2\2\2\377\11\11\11q\0\0\0\0\0\0\0\0\6\6\6q\2"
-  "\2\2\377\4\4\4\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\14\14"
-  "\14q\0\0\0\377\6\6\6\216\0\0\0\0\0\0\0\0\15\15\15U\2\2\2\306\0\0\0\377\0"
-  "\0\0\377\1\1\1\306\7\7\7U\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\5\5\5\216\1\1\1"
-  "\377\3\3\3q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\3\3\252\2\2\2\377\5"
-  "\5\5U\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\31\31\31""9\31\31\31\252\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\26\26\26""9\13\13\13\343\5\5\5\377"
-  "\30\30\30\216\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\2\2\252\6\6\6\377\21\21\21"
-  "U\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\26\26\26""9\10\10\10\377\14\14\14\377\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\32\32\32U\11\11\11\377\0\0\0\252\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\2\2""9\12\12\12\343\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\32\32\32U\11\11\11\377\33\33\33\252\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0%%%9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\32\32""9\12\12\12"
-  "\343\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\17\17\17""9\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
-  "\0\0\0\0",
+  48, 48, 4,
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0H\212\234\13<r~\263,V\\\367\40DG\376\32:<\377\27""56\377"
+  "\32=?\377\31<>\377\26""56\377\27""56\377\36@B\377+RV\373;lv\320P\225\257"
+  "\36\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0T\240"
+  "\275\"6jt\3528nv\3754go\376\32?B\377\16##\377\16##\377'SW\377\21+,\377\20"
+  ",,\377\23""57\377\23""45\377\24""8:\377\17'(\377\16%%\377\16##\377\20)*\377"
+  "\34=?\3771ai\350N\217\245$\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0,V\\\370\24""12\377+]a\3773ho\3774"
+  "jr\377'QU\376/\\b\363@|\213\227Y\246\305\26\27""68\377\23""79\377\16$$\377"
+  "\20)*\377\16##\377\16%%\377\17&'\377\16$$\377\16##\377\16##\377\16##\377"
+  "\21+,\377)OU\374E\204\224B\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0_\257"
+  "\324\7\26""56\377\21*+\377%JN\376>w\206\272_\257\324\11\377\377\377\0\377"
+  "\377\377\0\377\377\377\0""8my\310\24""9;\3770dk\377\23""57\377\25""89\377"
+  "\21/0\377\17()\377\16##\377\16##\377\16##\377\20((\377\22-.\377\16$$\377"
+  "\16$$\377\24/0\3772_g\360\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0/Zb\365"
+  "D\202\225X\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0#GJ\376\16$$\377\22""01\377\21,-\377\20))\377\16##\377"
+  "\16##\377\17)*\377\21""01\377\17'(\3773dm\357I\205\225+Ax\205\2542aj\344"
+  "2bl\345@}\214\214\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0>x\207\204"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0V\246\304"
+  "\7)PU\374\16$$\377\17&'\377\26EH\377\23""57\377\16##\377\21""01\377\17&&"
+  "\377\22""12\377\24""79\377\22""46\377\34EG\377$JM\376*SY\3706is\332H\211"
+  "\234]\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0-Za\367\34=?\377\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0A|\215q\32;=\377\16##\377"
+  "\16##\377\16##\377\23""8:\377\35NQ\377\16##\377\20*+\377\17''\377\16##\377"
+  "\17()\377\20+,\377\23""79\377\16##\377\16##\377\16##\377\17&&\377\30""68"
+  "\377'NR\374A}\215p_\257\324\13_\257\324\5\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0*V\\\370\22""45\377\36?B\377\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0C\201\221~&KP\376"
+  "\37SX\377$X]\377\22""35\377\32IL\377\17()\377\26EH\377\33QU\377\31GJ\377"
+  "(Y]\377\27""8:\377)X\\\377!SX\377%PT\377\24<?\377\17%%\377\16##\377\16##"
+  "\377\16##\377\26""45\377\40AC\377\32""9:\377\22-.\377\30""9;\377*W^\361\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0.]e\366\27GJ\377\26""89\377<t\201\221\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0K\213\237\23)QU\374%NQ\377$PS\377!]a\377"
+  "-af\377*_d\3773py\377\35W[\377%X\\\377&^b\377\40\\a\377']a\377\25<>\377,"
+  "_d\3777\202\221\3774lt\377\30BD\377\27GJ\377\20,-\377\16##\377\27""45\377"
+  "H\204\225\4\377\377\377\0\377\377\377\0""0_g\347\20()\377\16$$\377,X`\346"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0""7kv\320\"IL\377\31"
+  ";=\3775hr\331\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0L\224\251\34#IL\377\34V[\377\27GJ\377$]b\377$[`\377+^c\3774r{\377"
+  "*^c\3772v\201\3777~\215\377)_c\3773nx\3773lt\3771fn\3771fl\3771gn\377\31"
+  "BD\377\23""8:\377\36KN\377\33CE\377\25""89\3777hr\343\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0""1bk\345\16$$\377\20*+\3775hr\261\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0F\207\233A\24""02\377\16##\377)QV\373\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0N\225\254\21\35>@\377"
+  "\25>A\377#\\`\377+[a\3774mt\377$X\\\377+^b\3778y\204\3775s\177\377;\203\222"
+  "\377.`e\3773iq\3774y\204\3771ek\377$SV\377\40SW\3771hq\3773jr\377/ag\377"
+  "2hn\377.bg\377;pz\363\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0#NS\373\21./\377\24""12\377D\202\224\"\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0!DG\376\21""02\377\35>@\377[\253\315\5\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0P\222\252\14*TX\377\20--\377\27IM\377\33\\a\377"
+  "/ci\377(^c\377\32NR\377$[`\3771dj\377*^c\377-^d\377\30LP\377\32OS\377&Z_"
+  "\3771hp\377\36HK\3770dj\3773{\207\3773mu\377)_c\377.`g\377\40\\a\377+UY\377"
+  "J\214\2402\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0C\216\244\13\30;<\377\17%%\377#GK\375\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0""6jt\331\31FI\377\"JL\377B\200\222"
+  "W\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0/"
+  "Z`\375)_c\377\35QU\377$]b\377\40\\a\377.bg\3772ho\377\35X]\377%OS\377!Z^"
+  "\377\"]a\377!SX\377\34GJ\377\36\\a\377*^c\3776v\200\3773nx\3773lu\3774qz"
+  "\3773ip\377;{\211\3776s~\3774{\211\3773v\200\377*UY\377K\217\245-\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0=w\206\221"
+  "\22""01\377\26:;\3778ny\254\377\377\377\0\377\377\377\0\377\377\377\0_\257"
+  "\324\1\"HK\377\31<>\3779mv\356\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0<u\203\256\36IM\377\"[`\377$]b\377-_e\377(^b"
+  "\377+^c\377<\204\222\3773ks\377*Y_\3773ho\377$]b\377/ci\3779\206\225\377"
+  "\37\\a\377#]a\3774\200\215\3772|\212\377/{\211\3770{\211\3774\203\222\377"
+  "1\177\215\3774z\206\377+_d\3774mv\377-[`\377\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0&N"
+  "R\373\17((\377\34>A\377\377\377\377\0\377\377\377\0\377\377\377\0""8p}\272"
+  "\23""79\377\37GJ\377M\217\245!\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0,V\\\3742ho\3774y\206\377)]b\3772js\3778\201"
+  "\220\377\40[`\377B\221\243\377@\217\243\3774q|\3774x\204\3774\202\220\377"
+  "3lt\3773ox\3773z\207\3773lt\3779\216\236\3778\213\233\3770|\212\3770|\213"
+  "\3773\202\221\3777\206\226\3772w\202\3773oz\377,^c\377>w\203\263\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0D\212\2367\21+,\377\17''\377?{\212\223\377\377\377\0\377"
+  "\377\377\0._f\374\40KN\3773ah\373\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0""2`g\3753t\177\3771t\177\377"
+  "3nw\3772ny\3773\201\221\3777x\204\3776\212\231\3779\214\235\377:\217\240"
+  "\377J\232\261\377>\221\244\377A\222\247\377A\215\240\377.`g\3776|\212\377"
+  "1\200\216\3776\213\233\3779\214\235\377=\220\242\3773\203\222\3773\204\223"
+  "\3775\201\220\377,]c\3773dl\360\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0%OS\376\17'(\377$IM\376\377\377\377\0\\\254\317\17\23/0\377\31"
+  "AC\377F\205\226a\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0<w\202\3743y\207\3777z\206\3772oy\3773~\215\377"
+  "1\177\216\377@\214\236\3778x\204\377:\202\217\377=\221\243\3778\215\235\377"
+  "5w\201\377\35CF\377*W[\3775jq\3772mv\3777~\213\377:v\201\377N\236\267\377"
+  "6v\201\377<\206\226\3777\204\224\3772{\207\3770_e\376\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0>}\215\216\17'(\377\22--\377"
+  "Q\231\262\33""8lx\321\26FI\377'PU\377\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0""6iq\3764"
+  "lu\377[\253\315\377B\223\250\377<\211\233\377H\231\260\377P\235\273\3778"
+  "s~\377B\221\244\377>\221\243\3779\216\236\3777~\213\3777x\204\3774oy\377"
+  "?\222\245\377J\233\262\377:lu\376E\204\225\244.ah\3779\203\222\3773ku\377"
+  "9\213\234\377/dl\377C\177\216R\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\32<>\377\16##\377<r~\2726hp\372\34"
+  "PT\377*TZ\371\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0""7nw\376<\210\232\377I\231\260\377"
+  "B\225\251\3779x\204\377B\217\243\377\\\254\315\377N\235\266\3771kt\377F\227"
+  "\254\377>\220\243\3773\202\221\377:\215\236\377C\223\250\3779\207\227\377"
+  "3\200\214\3772dj\376_\257\324\1""0_e\377,V[\377/pz\3772{\210\377<u\201\337"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0/Za\367\20--\377+T[\3666fm\376\35PS\377=s\200\275\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0=x\205\372L\235\265\377W\246\306\377U\246\306\377^\253"
+  "\316\377'RW\377)V[\377>{\214\377@\210\233\377L\235\265\377B\224\250\377H"
+  "\230\257\377G\227\256\377Q\240\273\377L\234\265\3776t\177\377:oz\320E\205"
+  "\227l\37AD\377C\203\224\216/^e\377/z\210\3774ir\376F\212\234\7\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0H\205"
+  "\226\233(UZ\377#HK\376+Y^\377(PT\377L\216\243\26\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "B|\211\367?\222\246\377?\220\243\3772}\214\377%KN\377!@B\377\20*+\377#LP"
+  "\377;\200\216\377M\232\265\377L\235\267\377>\221\244\377F\227\253\377D\212"
+  "\236\377;\214\235\3777lu\375\377\377\377\0*RW\376-\\b\376O\221\250>6gn\377"
+  "/z\211\3775w\205\3777mv\350\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0V\236\273\12""2Z_\376$JM\377%NR\377(OS"
+  "\377\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0;q|\367<\216\240\377C\216\242"
+  "\3772em\377:nx\342N\231\263\16As~\350#CE\3771t~\377)Y_\377D\225\252\377B"
+  "\224\250\3776\204\223\377O\236\271\377L\233\263\3779lu\370>z\211\223!HK\377"
+  "2bh\376K\214\241?7px\377I\232\262\3774dk\377=u\202\264\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0T\244\302\2<u\202\2052^f\357\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0:oy\3518\211\231\377K\232\261\377(TY\377@\177\220\201\377\377\377"
+  "\0\377\377\377\0J\212\234\31""8go\363!HK\377K\232\262\377J\231\260\377.b"
+  "i\377J\231\260\377J\231\260\377;v\202\377\37HK\3775cl\347%SV\377K\216\243"
+  "\2224ow\377:\213\234\3771hq\377F\210\233Y\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0=u\202\2775|\210\377D\224\251\377<\177\214\377H\213\240?\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0?t\200\313;x\203\377@\221"
+  "\244\377,\\a\377K\231\262\377J\231\260\377H\227\256\377.Z`\375B~\216\232"
+  ".]c\377=w\202\377D\221\245\377;\207\230\3771|\212\377-W\\\377L\213\237H\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0M\221\247P0bg\3773\202\221\3777\205\224\3779t\177"
+  "\335\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0E\202\224\40"
+  """2js\3761~\215\377&NR\377#GJ\377E\224\251\377?\214\235\3774cm\353_\257\324"
+  "\4""7ku\375<\201\217\377?\210\232\377K\234\265\377F\227\255\377;\210\230"
+  "\3770\\b\377B~\215\251\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0_\257\324\3,Y]\3771\177\215\3772\202"
+  "\221\377,Y_\377Av\204\272F\201\220\236C}\212\2756nx\365,\\b\377/s\200\377"
+  "0gp\377'RV\377\31""8:\377,Z_\377:z\206\377>t\177\351D\202\223T*UX\377<lv"
+  "\3624nw\377N\237\271\377J\232\261\377I\231\260\377;\216\237\3778jr\377K\214"
+  "\241`I\212\237B\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0?~\217g_\257\324\1\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0""8nv\377C\224\250\377J\231\260\377B\224\251\3777}\211\3775z\207\3770q"
+  "|\377/y\207\377/y\207\3770nx\3775go\366#IM\377.[a\376:p|\335<u\200\3727k"
+  "t\3762dl\3761`e\374C\177\220\2508|\210\3777js\374<w\203\376?\214\236\377"
+  ":\200\216\3774mv\377O\225\254cC\201\222{\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0)TX\377,U[\376\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0""7s~\376B\224\250\377;\216\240\3778\214\235"
+  "\3777\213\233\377D\225\252\377<\216\240\3775\207\226\3771x\204\377/^e\374"
+  "\377\377\377\0""2`i\370\40DG\3766it\363>x\205\365G\227\255\377=\177\215\377"
+  ">p|\355$IM\377;s\177\376[\253\315\12;s~\3556\204\224\3775w\203\377,Y^\376"
+  "@{\211\3018lx\321\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0P\227\257#4el\3774fl\377P\237\272"
+  "\7\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0>{"
+  "\210\372C\224\251\3774\206\226\3772\201\217\377/z\210\3772\203\222\3771\201"
+  "\217\377/y\207\377+[b\377K\220\250\35""7lw\307B\177\216\302/[b\376;~\214"
+  "\3777el\3761`h\3767mu\3776em\376&KN\377;s}\345<t\200\3204go\3769\177\214"
+  "\377+UY\376E\202\222\231+V[\3778lw\327\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0A{\211\310"
+  "1fm\3779s~\3741]b\3722_g\364\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0?{\211\3342x\204\377/z\210\3771\201\217\3770|\212\377/v\203\377\"H"
+  "L\3770kt\3777w\203\3770bk\3725nx\3779mv\375;t\177\376J\231\260\3777go\377"
+  "3^d\3753mw\3773jr\377&RV\377[\251\312$9ox\376J\231\260\3777lv\377N\227\260"
+  "\23""5el\374\"JM\377M\217\246;\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0""4cj\372(^c\377"
+  "8kt\365:pz\335\33UZ\377/X^\371\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0J\231"
+  "\260\2""1dm\3710en\377A\210\231\3775r}\3775mv\373?w\206\2566lu\3612gp\377"
+  "I\230\257\377J\231\260\3771`f\3779u\201\377;y\205\377.JM\3776t\177\3772g"
+  "q\3777el\3770ci\377@{\211\274=~\214\377E\217\244\377>v\203\357C\177\216\253"
+  "7pz\377$JN\376\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0*UY\377)Z^\377>v\202"
+  "\311R\235\271\"(^c\377\35BE\377N\230\262\27\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0>y\211w8js\361F\206\230i\377\377\377\0?w\203\333<\202"
+  "\221\3770^f\376)QV\377$GJ\377\23""01\377#JN\377'IK\377A\206\230\3776fm\377"
+  "%NR\377:cj\374,Y_\375=u\201\3366t\177\375:q|\363N\224\254!7jt\376<w\203\376"
+  "I\214\2405\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0?y\2125\36KN\377\35FI\377N\223\251\24\377"
+  "\377\377\0""4r}\374\36GJ\3773dn\353\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0F\205\22632cj\377.[a\377:s\200\242E\203\224\215=\202\220\377"
+  "9gn\376:x\204\377!IL\3777el\377\30""79\377'KN\377\"HK\377:dk\3751bi\3773"
+  "bj\375_\257\324\2\377\377\377\0\377\377\377\0\377\377\377\0/Z`\3757\211\230"
+  "\3779u\200\375\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0,Y_\3662w\202\3778nw"
+  "\373\377\377\377\0\377\377\377\0B\206\230\264<\205\225\377\"LO\377L\231\257"
+  "\22\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0;r|\367N\235\270"
+  "\377.X_\376F\205\227A=w\203\376:mv\376?\204\224\3776]b\377;io\3771\\c\377"
+  "Gv\200\3620ai\377@nw\351:r\177\3550^d\374\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0""9nw\3721\200\217\3774hn\377\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0@\201\223-&QV\3771hp\377?z\207\265\377\377\377\0\377\377\377\0_\257\324"
+  "\6.ci\377\35W[\3774gp\360\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0F\205\226\215+X^\377\"BD\377<pz\352?|\211\267C\201\220\2415fn\376;r}\361"
+  ">|\214\2427hp\377U\236\27389oy\376?py\353\377\377\377\0B\202\224V\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0/W\\\3753jr\377&SV\377_\257"
+  "\324\3\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0)W]\3701dk\377-Z_\377\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0>z\206\3334ox\377.`f\377A\203\226!\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0""7r}\3757kt\377>t\177\335D}\213\356;s"
+  "}\3738jt\3630ah\3775gn\365=nw\366_\257\324\1=v\204\227E\202\223r\377\377"
+  "\377\0\377\377\377\0\377\377\377\0_\257\324\7R\233\2663B~\214\274(PT\377"
+  "1t\177\377(VZ\377P\225\254)\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0=\200\222>\33OS\377'^b\377>w\204\313\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0_\257\324\5""7mv\3769\202\221"
+  "\377.`g\370\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0B\210\231\371"
+  "A\203\223\377E\177\215\263<w\202\3777u\200\377=ek\3773\204\223\3778q{\375"
+  "\377\377\377\0\377\377\377\0A\177\220s\377\377\377\0:p|\323\377\377\377\0"
+  "\377\377\377\0?y\210\303.ah\377:x\206\377;{\211\3773\202\221\3773gn\377L"
+  "\216\244S\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0)V[\376)^c\3773fm\376\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0D\204\225\2013el\377,Y_\3778lw\321"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0?|\212\372C\207\232\377G\201\222\276"
+  "6pz\377;y\205\377@el\377?\222\244\3779w\202\374E\206\231q?z\210\344-Z_\377"
+  "_\257\324\2+UY\377?t~\341/\\c\375.^f\3777\210\230\377H\230\257\377I\230\257"
+  "\3777\202\221\377'UY\377N\221\2503\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0""8gp\357&VZ\377*[a\377G\214\241U\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  """9kt\352&UY\377\37MP\3779u\201\210\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0:v\202\375;\215"
+  "\236\377*TX\377/[b\376\33>@\3777X\\\3771_f\377%HK\377:go\375Du\201\3772e"
+  "l\377E\203\224\2042ck\375?iq\3756\202\220\3778\214\234\377<\215\235\377@"
+  "\210\233\377;\216\237\377/cj\3774em\365\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0>w\204\266,X]\3775q{\377:q|\323\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0-SX\375*Y_\377!OS\3775p}t\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0""9t\201"
+  "\375;\216\237\377/s\177\3771_f\3770s\177\3773ir\377(V[\377/]e\3777bg\377"
+  "F|\211\3766kr\3775`f\376)QV\3765gn\3763r|\3771y\207\3772iq\377\35RV\377("
+  "QU\377.\\d\362\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0>z"
+  "\212Z\36HL\377'Y^\377:js\362\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0X\250\310\3*X^\374-_e\377!LO\3778q~\230\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0""9r}\375=\216\240"
+  "\377<\215\236\3773u\200\3772\200\217\3777}\211\377\37MQ\377*Y_\377\33<?\377"
+  "2SV\377+TX\3777]b\377=\220\242\377>\215\240\377:\206\226\3773mv\377!LO\377"
+  "8mx\271\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0T\244\302\2.`g\375$TW\377.[c\365\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0J\231\260\1)V[\375"
+  "&X]\377\40OR\377:p{\303\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0B\202\224q&NR\377\36IL\377\36W[\3771t\177\377/bh\377\32SW\377'JM\377"
+  "2OR\377-^c\377&PT\3771ir\3772\203\221\377C\224\251\377B\223\250\377+X]\377"
+  "A\200\222D\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0M\224\252C.`f\3773kv\355\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0J\231\260\1'PU\374\33HK\377(NR\377W\247\307\13\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0;s\201\305"
+  "\40FI\3772|\211\377\37Z_\377+`e\377!HK\377\33IL\3773lt\3773t}\3774\207\226"
+  "\3771fl\377#]b\377\40X]\3777jt\336\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0K\214\2372/cl\350"
+  "_\257\324\1\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0Q\232\265#\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0,UZ\3769\212"
+  "\233\3773{\207\3774\206\225\3776\212\232\3773t\177\377+`e\377-`f\3773q{\377"
+  "1gn\377/ch\377*SX\376M\221\251@\377\377\377\0\377\377\377\0U\240\275\22>"
+  "v\204\324W\237\276\13\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0_\257\324\2\377\377\377\0@|\213"
+  "\2033hp\377(X\\\377&QV\377-_f\377?\204\223\377.bg\3775nw\3774r{\3774y\204"
+  "\377+\\a\377B~\216DH\212\2367C\202\222\2211`g\373+Y]\3771ag\377T\233\266"
+  "#\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0P\230"
+  "\261\11""2`f\373'OS\377)SX\3762_f\366F\202\221\302M\221\251j@z\210\2510["
+  "`\377H\210\233\377A\205\226\377=\204\224\377E\220\247\377C\225\252\377,["
+  "b\377+V[\3731`f\3774hp\377.bf\377,Y_\377-X^\375\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0J\215\242C2[b\374"
+  ",Z^\3774t~\3775kt\377<y\206\377E\203\223\376=}\212\3766oz\377\"JL\377\30"
+  "BE\377#KO\377\33?B\377;\203\221\377\32DF\377,\\a\377'VZ\3778nx\3760Z`\374"
+  "?x\205\237\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0_\257\324\2"
+  "?|\212\257C{\210\353>{\210\363?\177\220\363=|\210\375?u\200\376Aoy\376H\177"
+  "\216\374J\204\225\373:oy\376;v\202\3757lt\3751`f\370=t\201\264_\257\324\2"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0",
 };
 
diff -r 11104731f8c9 -r 87f98d895296 src/sdl/sdl_input.c
--- a/src/sdl/sdl_input.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/sdl/sdl_input.c	Sun Mar 29 01:15:08 2009 +0800
@@ -571,7 +571,7 @@
 		SDL_WM_GrabInput( SDL_GRAB_OFF );
 
 		// Don't warp the mouse unless the cursor is within the window
-		if( SDL_GetAppState( ) & SDL_APPMOUSEFOCUS )
+		if( SDL_GetAppState( ) & (SDL_APPMOUSEFOCUS|SDL_APPACTIVE) )
 		{
 			int x, y;
 			IN_GetUIMousePosition( &x, &y );
diff -r 11104731f8c9 -r 87f98d895296 src/server/server.h
--- a/src/server/server.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/server/server.h	Sun Mar 29 01:15:08 2009 +0800
@@ -177,8 +177,6 @@
 	int				timeoutCount;		// must timeout a few frames in a row so debugging doesn't break
 	clientSnapshot_t	frames[PACKET_BACKUP];	// updates can be delta'd from here
 	int				ping;
-	int				delayRate;
-	int				lastCheck;
 	int				rate;				// bytes / second
 	int				snapshotMsec;		// requests a snapshot every snapshotMsec unless rate choked
 	netchan_t		netchan;
@@ -279,7 +277,6 @@
 extern	cvar_t	*sv_autoDemo;
 extern	cvar_t	*sv_pure;
 
-extern	cvar_t	*sv_minPing;
 #ifdef USE_VOIP
 extern	cvar_t	*sv_voip;
 #endif
diff -r 11104731f8c9 -r 87f98d895296 src/server/sv_ccmds.c
--- a/src/server/sv_ccmds.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/server/sv_ccmds.c	Sun Mar 29 01:15:08 2009 +0800
@@ -308,7 +308,7 @@
 */
 static client_t *redirect_client = NULL;
 static void SV_ClientRedirect( char *outputbuf ) {
-	SV_SendServerCommand( redirect_client, "%s", outputbuf );
+	SV_SendServerCommand( redirect_client, "print \"%s\"", outputbuf );
 }
 static void SV_StartRedirect_f( void ) {
 #define SV_OUTPUTBUF_LENGTH (1024 - 16)
diff -r 11104731f8c9 -r 87f98d895296 src/server/sv_game.c
--- a/src/server/sv_game.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/server/sv_game.c	Sun Mar 29 01:15:08 2009 +0800
@@ -29,7 +29,6 @@
 	SYSCALL_OLD,
 	SYSCALL_NEW
 } syscallVersion_t;
-syscallVersion_t syscallVersion;
 
 void SV_GameError( const char *string ) {
 	Com_Error( ERR_DROP, "%s", string );
@@ -307,6 +306,9 @@
 ====================
 */
 intptr_t SV_GameSystemCalls( intptr_t *args ) {
+	static syscallVersion_t syscallVersion;
+	static int serverId = -1;
+
 	if ( syscallVersion == SYSCALL_OLD ) {
 		if ( args[0] >= 36 && args[0] <= 38 )
 			args[0] -= 2;
@@ -437,12 +439,15 @@
 		}
 
 	case G_REAL_TIME:
-		if ( syscallVersion == SYSCALL_UNKNOWN && args[2] == 1024 ) {
+		if ( serverId != sv.serverId && syscallVersion == SYSCALL_UNKNOWN && args[2] == 1024 ) {
 			syscallVersion = SYSCALL_OLD;
+			serverId = sv.serverId;
 			return SV_GameSystemCalls( args );
-		} else
+		} else {
 			syscallVersion = SYSCALL_NEW;
-		return Com_RealTime( VMA(1) );
+			serverId = sv.serverId;
+			return Com_RealTime( VMA(1) );
+		}
 	case G_SNAPVECTOR:
 		Sys_SnapVector( VMA(1) );
 		return 0;
@@ -498,18 +503,6 @@
 	case TRAP_SQRT:
 		return FloatAsInt( sqrt( VMF(1) ) );
 
-	case TRAP_MATRIXMULTIPLY:
-		MatrixMultiply( VMA(1), VMA(2), VMA(3) );
-		return 0;
-
-	case TRAP_ANGLEVECTORS:
-		AngleVectors( VMA(1), VMA(2), VMA(3), VMA(4) );
-		return 0;
-
-	case TRAP_PERPENDICULARVECTOR:
-		PerpendicularVector( VMA(1), VMA(2) );
-		return 0;
-
 	case TRAP_FLOOR:
 		return FloatAsInt( floor( VMF(1) ) );
 
@@ -552,9 +545,6 @@
 	// start the entity parsing at the beginning
 	sv.entityParsePoint = CM_EntityString();
 
-	// we don't know what syscalls this vm is using
-	syscallVersion = SYSCALL_UNKNOWN;
-
 	// clear all gentity pointers that might still be set from
 	// a previous level
 	// https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=522
diff -r 11104731f8c9 -r 87f98d895296 src/server/sv_init.c
--- a/src/server/sv_init.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/server/sv_init.c	Sun Mar 29 01:15:08 2009 +0800
@@ -637,8 +637,7 @@
 	sv_lanForceRate = Cvar_Get ("sv_lanForceRate", "1", CVAR_ARCHIVE );
 	sv_dequeuePeriod = Cvar_Get ("sv_dequeuePeriod", "500", CVAR_ARCHIVE );
 	sv_demoState = Cvar_Get ("sv_demoState", "0", CVAR_ROM );
-	sv_autoDemo = Cvar_Get ("sv_autoDemo", "0", CVAR_ARCHIVE );	
-	sv_minPing = Cvar_Get ("sv_minPing", "0", CVAR_ARCHIVE );
+	sv_autoDemo = Cvar_Get ("sv_autoDemo", "0", CVAR_ARCHIVE );
 }
 
 
diff -r 11104731f8c9 -r 87f98d895296 src/server/sv_main.c
--- a/src/server/sv_main.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/server/sv_main.c	Sun Mar 29 01:15:08 2009 +0800
@@ -60,7 +60,6 @@
 cvar_t	*sv_autoDemo;
 cvar_t	*sv_pure;
 
-cvar_t	*sv_minPing;
 /*
 =============================================================================
 
diff -r 11104731f8c9 -r 87f98d895296 src/server/sv_net_chan.c
--- a/src/server/sv_net_chan.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/server/sv_net_chan.c	Sun Mar 29 01:15:08 2009 +0800
@@ -133,23 +133,7 @@
 =================
 */
 void SV_Netchan_TransmitNextFragment( client_t *client ) {
-
-	int delay = 0;
-	
-	if( client->ping < sv_minPing->integer && client->lastCheck <= svs.time  )
-	{
-		client->delayRate += 5;
-		client->lastCheck = svs.time + 750;
-	}
-	else if( client->ping >= sv_minPing->integer && client->delayRate != 0  && client->lastCheck <= svs.time )
-	{
-		client->delayRate -= 5;
-		client->lastCheck = svs.time + 750;
-	}
-	
-	delay = client->delayRate;
-	
-	Netchan_TransmitNextFragment( &client->netchan, delay );
+	Netchan_TransmitNextFragment( &client->netchan );
 	if (!client->netchan.unsentFragments)
 	{
 		// make sure the netchan queue has been properly initialized (you never know)
@@ -162,7 +146,7 @@
 			Com_DPrintf("#462 Netchan_TransmitNextFragment: popping a queued message for transmit\n");
 			netbuf = client->netchan_start_queue;
 			SV_Netchan_Encode( client, &netbuf->msg );
-			Netchan_Transmit( &client->netchan, netbuf->msg.cursize, netbuf->msg.data, delay );
+			Netchan_Transmit( &client->netchan, netbuf->msg.cursize, netbuf->msg.data );
 			// pop from queue
 			client->netchan_start_queue = netbuf->next;
 			if (!client->netchan_start_queue) {
@@ -189,22 +173,6 @@
 */
 
 void SV_Netchan_Transmit( client_t *client, msg_t *msg) {	//int length, const byte *data ) {
-
-	int delay = 0;
-	
-	if( client->ping < sv_minPing->integer && client->lastCheck <= svs.time  )
-	{
-		client->delayRate += 5;
-		client->lastCheck = svs.time + 750;
-	}
-	else if( client->ping >= sv_minPing->integer && client->delayRate != 0  && client->lastCheck <= svs.time )
-	{
-		client->delayRate -= 5;
-		client->lastCheck = svs.time + 750;
-	}
-	
-	delay = client->delayRate;
-	
 	MSG_WriteByte( msg, svc_EOF );
 	if (client->netchan.unsentFragments) {
 		netchan_buffer_t *netbuf;
@@ -217,10 +185,10 @@
 		*client->netchan_end_queue = netbuf;
 		client->netchan_end_queue = &(*client->netchan_end_queue)->next;
 		// emit the next fragment of the current message for now
-		Netchan_TransmitNextFragment(&client->netchan, delay);
+		Netchan_TransmitNextFragment(&client->netchan);
 	} else {
 		SV_Netchan_Encode( client, msg );
-		Netchan_Transmit( &client->netchan, msg->cursize, msg->data, delay );
+		Netchan_Transmit( &client->netchan, msg->cursize, msg->data );
 	}
 }
 
diff -r 11104731f8c9 -r 87f98d895296 src/server/sv_world.c
--- a/src/server/sv_world.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/server/sv_world.c	Sun Mar 29 01:15:08 2009 +0800
@@ -24,6 +24,11 @@
 
 #include "server.h"
 
+#if id386_sse >= 1
+#include "../qcommon/qsse.h"
+clipHandle_t CM_TempBoxModel_sse( v4f mins, v4f maxs, int capsule );
+#endif
+
 /*
 ================
 SV_ClipHandleForEntity
@@ -40,10 +45,20 @@
 	}
 	if ( ent->r.svFlags & SVF_CAPSULE ) {
 		// create a temp capsule from bounding box sizes
+#if id386_sse >= 1
+		if ( com_sse->integer >= 1 ) {
+			return CM_TempBoxModel_sse( vec3Load(ent->r.mins), vec3Load(ent->r.maxs), qtrue );
+		}
+#endif
 		return CM_TempBoxModel( ent->r.mins, ent->r.maxs, qtrue );
 	}
-
+	
 	// create a temp tree from bounding box sizes
+#if id386_sse >= 1
+	if ( com_sse->integer >= 1 ) {
+		return CM_TempBoxModel_sse( vec3Load(ent->r.mins), vec3Load(ent->r.maxs),  qfalse );
+	}
+#endif
 	return CM_TempBoxModel( ent->r.mins, ent->r.maxs, qfalse );
 }
 
diff -r 11104731f8c9 -r 87f98d895296 src/sys/con_curses.c
--- a/src/sys/con_curses.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/sys/con_curses.c	Sun Mar 29 01:15:08 2009 +0800
@@ -62,6 +62,7 @@
 static WINDOW *logwin;
 static WINDOW *inputwin;
 static WINDOW *scrollwin;
+static WINDOW *clockwin;
 
 static char logbuf[LOG_BUF_SIZE];
 static char *insert = logbuf;
@@ -207,6 +208,22 @@
 
 /*
 ==================
+CON_UpdateClock
+
+Update the clock
+==================
+*/
+static void CON_UpdateClock(void)
+{
+	qtime_t realtime;
+	Com_RealTime(&realtime);
+	werase(clockwin);
+	CON_ColorPrint(clockwin, va("^0[^3%02d%c%02d^0]^7 ", realtime.tm_hour, (realtime.tm_sec & 1) ? ':' : ' ', realtime.tm_min), qtrue);
+	wnoutrefresh(clockwin);
+}
+
+/*
+==================
 CON_Resize
 
 The window has just been resized, move everything back into place
@@ -218,7 +235,7 @@
 	struct winsize winsz = {0, };
 
 	ioctl(fileno(stdout), TIOCGWINSZ, &winsz);
-	if (winsz.ws_col < 4 || winsz.ws_row < 5)
+	if (winsz.ws_col < 12 || winsz.ws_row < 5)
 		return;
 	resizeterm(winsz.ws_row + 1, winsz.ws_col + 1);
 	resizeterm(winsz.ws_row, winsz.ws_col);
@@ -299,8 +316,8 @@
 	if (!curses_on) {
 		SCREEN *test = newterm(NULL, stdout, stdin);
 		if (!test) {
+			CON_Init_tty();
 			CON_Print_tty("Couldn't initialize curses, falling back to tty\n");
-			CON_Init_tty();
 			return;
 		}
 		endwin();
@@ -357,8 +374,8 @@
 	mvaddch(LINES - 2, COLS - 1, SCRLBAR_DOWN);
 
 	// Create the input field
-	inputwin = newwin(1, COLS - Q_PrintStrlen(PROMPT), LINES - 1, Q_PrintStrlen(PROMPT));
-	input_field.widthInChars = COLS - Q_PrintStrlen(PROMPT) - 1;
+	inputwin = newwin(1, COLS - Q_PrintStrlen(PROMPT) - 8, LINES - 1, Q_PrintStrlen(PROMPT) + 8);
+	input_field.widthInChars = COLS - Q_PrintStrlen(PROMPT) - 9;
 	if (curses_on) {
 		if (input_field.cursor < input_field.scroll)
 			input_field.scroll = input_field.cursor;
@@ -369,10 +386,14 @@
 	CON_UpdateCursor();
 	wnoutrefresh(inputwin);
 
+	// Create the clock
+	clockwin = newwin(1, 8, LINES - 1, 0);
+	CON_UpdateClock();
+
 	// Display the title and input prompt
 	move(0, (COLS - Q_PrintStrlen(TITLE)) / 2);
 	CON_ColorPrint(stdscr, TITLE, qtrue);
-	move(LINES - 1, 0);
+	move(LINES - 1, 8);
 	CON_ColorPrint(stdscr, PROMPT, qtrue);
 	wnoutrefresh(stdscr);
 	doupdate();
@@ -394,6 +415,7 @@
 {
 	int chr, num_chars = 0;
 	static char text[MAX_EDIT_LINE];
+	static int lasttime = -1;
 
 	if (!curses_on)
 		return CON_Input_tty();
@@ -403,6 +425,12 @@
 		com_ansiColor->modified = qfalse;
 	}
 
+	if (Com_RealTime(NULL) != lasttime) {
+		lasttime = Com_RealTime(NULL);
+		CON_UpdateClock();
+		num_chars++;
+	}
+
 	while (1) {
 		chr = getch();
 		num_chars++;
diff -r 11104731f8c9 -r 87f98d895296 src/sys/sys_main.c
--- a/src/sys/sys_main.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/sys/sys_main.c	Sun Mar 29 01:15:08 2009 +0800
@@ -352,13 +352,11 @@
 Sys_TryLibraryLoad
 =================
 */
-static void* Sys_TryLibraryLoad(const char* base, const char* gamedir, const char* fname, char* fqpath )
+static void* Sys_TryLibraryLoad(const char* base, const char* gamedir, const char* fname)
 {
 	void* libHandle;
 	char* fn;
 
-	*fqpath = 0;
-
 	fn = FS_BuildOSPath( base, gamedir, fname );
 	Com_DPrintf( "Sys_LoadDll(%s)... \n", fn );
 
@@ -369,8 +367,7 @@
 		return NULL;
 	}
 
-	Com_Printf ( "Sys_LoadDll(%s): succeeded ...\n", fn );
-	Q_strncpyz ( fqpath , fn , MAX_QPATH ) ;
+	Com_Printf ( "Sys_LoadDll(%s): succeeded ...\n", fn );\
 
 	return libHandle;
 }
@@ -385,7 +382,7 @@
 #3 look in fs_basepath
 =================
 */
-void *Sys_LoadDll( const char *name, char *fqpath ,
+void *Sys_LoadDll( const char *name,
 	intptr_t (**entryPoint)(int, ...),
 	intptr_t (*systemcalls)(intptr_t, ...) )
 {
@@ -409,16 +406,16 @@
 	extrapath = Cvar_VariableString( "fs_extrapath" );
 	gamedir = Cvar_VariableString( "fs_game" );
 
-	libHandle = Sys_TryLibraryLoad(pwdpath, gamedir, fname, fqpath);
+	libHandle = Sys_TryLibraryLoad(pwdpath, gamedir, fname);
 
 	if(!libHandle && *homepath)
-		libHandle = Sys_TryLibraryLoad(homepath, gamedir, fname, fqpath);
+		libHandle = Sys_TryLibraryLoad(homepath, gamedir, fname);
 
 	if(!libHandle && *extrapath)
-		libHandle = Sys_TryLibraryLoad(extrapath, gamedir, fname, fqpath);
+		libHandle = Sys_TryLibraryLoad(extrapath, gamedir, fname);
 
 	if(!libHandle && *basepath)
-		libHandle = Sys_TryLibraryLoad(basepath, gamedir, fname, fqpath);
+		libHandle = Sys_TryLibraryLoad(basepath, gamedir, fname);
 
 	if(!libHandle) {
 		Com_Printf ( "Sys_LoadDll(%s) failed to load library\n", name );
@@ -545,6 +542,9 @@
 
 	Sys_PlatformInit( );
 
+	// Set the initial time base
+	Sys_Milliseconds( );
+
 	Sys_ParseArgs( argc, argv );
 	Sys_SetBinaryPath( Sys_Dirname( Sys_ResolveLink( argv[ 0 ] ) ) );
 	Sys_SetDefaultInstallPath( DEFAULT_BASEDIR );
@@ -552,6 +552,8 @@
 	// Concatenate the command line for passing to Com_Init
 	for( i = 1; i < argc; i++ )
 	{
+		if( !strcmp( argv[ i ], "+nocurses" ) )
+			continue;
 		Q_strcat( commandLine, sizeof( commandLine ), argv[ i ] );
 		Q_strcat( commandLine, sizeof( commandLine ), " " );
 	}
diff -r 11104731f8c9 -r 87f98d895296 src/sys/sys_unix.c
--- a/src/sys/sys_unix.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/sys/sys_unix.c	Sun Mar 29 01:15:08 2009 +0800
@@ -530,8 +530,8 @@
 
 	Sys_Print( va( "%s\n", error ) );
 
-	// Write console log to file
-	f = FS_FOpenFileWrite( fileName );
+	// Write console log to file and to stderr
+	f = FS_SV_FOpenFileWrite( fileName );
 	if( !f )
 	{
 		Com_Printf( "ERROR: couldn't open %s\n", fileName );
@@ -539,7 +539,10 @@
 	}
 
 	while( ( size = CON_LogRead( buffer, sizeof( buffer ) ) ) > 0 )
+	{
 		FS_Write( buffer, size, f );
+		fputs( buffer, stderr );
+	}
 
 	FS_FCloseFile( f );
 }
diff -r 11104731f8c9 -r 87f98d895296 src/sys/sys_win32.c
--- a/src/sys/sys_win32.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/sys/sys_win32.c	Sun Mar 29 01:15:08 2009 +0800
@@ -67,30 +67,14 @@
 char *Sys_DefaultHomePath( char **path2 )
 {
 	TCHAR szPath[MAX_PATH];
-	FARPROC qSHGetFolderPath;
-	HMODULE shfolder = LoadLibrary("shfolder.dll");
 	
 	if( !*homePath )
 	{
-		if(shfolder == NULL)
-		{
-			Com_Printf("Unable to load SHFolder.dll\n");
-			return NULL;
-		}
-
-		qSHGetFolderPath = GetProcAddress(shfolder, "SHGetFolderPathA");
-		if(qSHGetFolderPath == NULL)
-		{
-			Com_Printf("Unable to find SHGetFolderPath in SHFolder.dll\n");
-			FreeLibrary(shfolder);
-			return NULL;
-		}
-
 #if USE_OLD_HOMEPATH
-		if( !SUCCEEDED( qSHGetFolderPath( NULL, CSIDL_APPDATA,
+		if( !SUCCEEDED( SHGetFolderPath( NULL, CSIDL_APPDATA,
 						NULL, 0, szPath ) ) )
 #else
-		if( !SUCCEEDED( qSHGetFolderPath( NULL, CSIDL_PERSONAL,
+		if( !SUCCEEDED( SHGetFolderPath( NULL, CSIDL_PERSONAL,
 						NULL, 0, szPath ) ) )
 #endif
 		{
@@ -99,7 +83,6 @@
 #else
 			Com_Printf("Unable to find CSIDL_PERSONAL\n");
 #endif
-			FreeLibrary(shfolder);
 			return NULL;
 		}
 		Q_strncpyz( homePath, szPath, sizeof( homePath ) );
@@ -110,11 +93,10 @@
 #endif
 
 #if USE_OLD_HOMEPATH
-		if( !SUCCEEDED( qSHGetFolderPath( NULL, CSIDL_LOCAL_APPDATA,
+		if( !SUCCEEDED( SHGetFolderPath( NULL, CSIDL_LOCAL_APPDATA,
 						NULL, 0, szPath ) ) )
 		{
-			Com_Printf("Unable to detect CSIDL_LOCAL_APPDATA\n");
-			FreeLibrary(shfolder);
+			Com_Printf("Unable to find CSIDL_LOCAL_APPDATA\n");
 			return NULL;
 		}
 		Q_strncpyz( homePathOld, szPath, sizeof( homePath ) );
@@ -123,7 +105,6 @@
 #else
 		*path2 = NULL;
 #endif
-		FreeLibrary(shfolder);
 	}
 
 	return homePath;
@@ -244,8 +225,6 @@
 				data = Z_Malloc( GlobalSize( hClipboardData ) + 1 );
 				Q_strncpyz( data, cliptext, GlobalSize( hClipboardData ) );
 				GlobalUnlock( hClipboardData );
-				
-				strtok( data, "\n\r\b" );
 			}
 		}
 		CloseClipboard();
@@ -566,7 +545,7 @@
 	if( msec == 0 )
 		return;
 
-#ifdef DEDICATED
+#if DEDICATED || BUILD_TTY_CLIENT
 	if( msec < 0 )
 		WaitForSingleObject( GetStdHandle( STD_INPUT_HANDLE ), INFINITE );
 	else
@@ -621,7 +600,7 @@
 	}
 }
 
-#ifndef DEDICATED
+#if !DEDICATED && !BUILD_TTY_CLIENT
 static qboolean SDL_VIDEODRIVER_externallySet = qfalse;
 #endif
 
@@ -634,7 +613,7 @@
 */
 void Sys_GLimpInit( void )
 {
-#ifndef DEDICATED
+#if !DEDICATED && !BUILD_TTY_CLIENT
 	if( !SDL_VIDEODRIVER_externallySet )
 	{
 		// It's a little bit weird having in_mouse control the
@@ -664,7 +643,7 @@
 */
 void Sys_PlatformInit( void )
 {
-#ifndef DEDICATED
+#if !DEDICATED && !BUILD_TTY_CLIENT
 	const char *SDL_VIDEODRIVER = getenv( "SDL_VIDEODRIVER" );
 
 	if( SDL_VIDEODRIVER )
diff -r 11104731f8c9 -r 87f98d895296 src/sys/win_resource.h
--- a/src/sys/win_resource.h	Thu Feb 19 05:06:14 2009 +0800
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-/*
-===========================================================================
-Copyright (C) 1999-2005 Id Software, Inc.
-
-This file is part of Tremfusion.
-
-Tremfusion is free software; you can redistribute it
-and/or modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the License,
-or (at your option) any later version.
-
-Tremfusion is distributed in the hope that it will be
-useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Tremfusion; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-===========================================================================
-*/
-//{{NO_DEPENDENCIES}}
-// Microsoft Developer Studio generated include file.
-// Used by winquake.rc
-//
-#define IDS_STRING1                     1
-#define IDI_ICON1                       1
-#define IDB_BITMAP1                     1
-#define IDB_BITMAP2                     128
-#define IDC_CURSOR1                     129
-#define IDC_CURSOR2                     130
-#define IDC_CURSOR3                     131
-
-// Next default values for new objects
-// 
-#ifdef APSTUDIO_INVOKED
-#ifndef APSTUDIO_READONLY_SYMBOLS
-#define _APS_NO_MFC                     1
-#define _APS_NEXT_RESOURCE_VALUE        132
-#define _APS_NEXT_COMMAND_VALUE         40001
-#define _APS_NEXT_CONTROL_VALUE         1005
-#define _APS_NEXT_SYMED_VALUE           101
-#endif
-#endif
diff -r 11104731f8c9 -r 87f98d895296 src/sys/win_resource.rc
--- a/src/sys/win_resource.rc	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/sys/win_resource.rc	Sun Mar 29 01:15:08 2009 +0800
@@ -1,76 +1,5 @@
-//Microsoft Developer Studio generated resource script.
-//
-#include "win_resource.h"
-
-#define APSTUDIO_READONLY_SYMBOLS
-/////////////////////////////////////////////////////////////////////////////
-//
-// Generated from the TEXTINCLUDE 2 resource.
-//
-#include <winresrc.h>
-
-/////////////////////////////////////////////////////////////////////////////
-#undef APSTUDIO_READONLY_SYMBOLS
-
-/////////////////////////////////////////////////////////////////////////////
-// English (U.S.) resources
-
-#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
-#ifdef _WIN32
-LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
-#pragma code_page(1252)
-#endif //_WIN32
-
-#ifdef APSTUDIO_INVOKED
-/////////////////////////////////////////////////////////////////////////////
-//
-// TEXTINCLUDE
-//
-
-1 TEXTINCLUDE DISCARDABLE 
-BEGIN
-    "resource.h\0"
-END
-
-2 TEXTINCLUDE DISCARDABLE 
-BEGIN
-    "#include ""winres.h""\r\n"
-    "\0"
-END
-
-3 TEXTINCLUDE DISCARDABLE 
-BEGIN
-    "\0"
-END
-
-#endif    // APSTUDIO_INVOKED
-
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// Icon
-//
-
-// Icon with lowest ID value placed first to ensure application icon
-// remains consistent on all systems.
 #ifdef _MSC_VER
-IDI_ICON1               ICON    DISCARDABLE     "../../misc/tremulous.ico"
+1 ICON "../../misc/tremfusion.ico"
 #else
-IDI_ICON1               ICON    DISCARDABLE     "misc/tremulous.ico"
+1 ICON "misc/tremfusion.ico"
 #endif
-
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// String Table
-//
-
-STRINGTABLE DISCARDABLE 
-BEGIN
-    IDS_STRING1             "Tremulous"
-END
-
-#endif    // English (U.S.) resources
-/////////////////////////////////////////////////////////////////////////////
-
-
diff -r 11104731f8c9 -r 87f98d895296 src/ui/ui_main.c
--- a/src/ui/ui_main.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/ui/ui_main.c	Sun Mar 29 01:15:08 2009 +0800
@@ -129,9 +129,10 @@
   { &ui_textWrapCache, "ui_textWrapCache", "1", CVAR_ARCHIVE },
   { &ui_developer, "ui_developer", "0", CVAR_ARCHIVE | CVAR_CHEAT },
   { &ui_emoticons, "cg_emoticons", "1", CVAR_LATCH | CVAR_ARCHIVE },
+  { &ui_winner, "ui_winner", "", CVAR_ROM },
   { &ui_screen, "ui_screen", "0", CVAR_ROM },
   { &ui_screens, "ui_screens", "0", CVAR_ROM },
-  { &ui_screenname, "ui_screenname", "", CVAR_ROM },
+  { &ui_screenname, "ui_screenname", "", CVAR_ROM }
 };
 
 static int    cvarTableSize = sizeof( cvarTable ) / sizeof( cvarTable[0] );
@@ -2020,6 +2021,18 @@
                     trap_R_RegisterShaderNoMip( va( "screenshots/%s", screenshots[ shotNumber ] ) ) );
 }
 
+static qboolean UI_HideScreen( int modifier )
+{
+  int shotNumber;
+
+  shotNumber = current_screen + modifier;
+
+  if ( shotNumber < 0 || shotNumber >= maxscreens )
+    return qtrue;
+  else
+    return qfalse;
+}
+
 // FIXME: table drive
 //
 static void UI_OwnerDraw( float x, float y, float w, float h,
@@ -2125,85 +2138,66 @@
   team = atoi( Info_ValueForKey( info, "t" ) );
 
 
-  while( flags )
-  {
-    if( flags & UI_SHOW_NOTSPECTATING )
-    {
-      if( team == TEAM_NONE )
+  if( flags & UI_SHOW_NOTSPECTATING )
+  {
+    if( team == TEAM_NONE )
+      vis = qfalse;
+  }
+
+  if( flags & UI_SHOW_VOTEACTIVE )
+  {
+    if( !trap_Cvar_VariableValue( "ui_voteActive" ) )
+      vis = qfalse;
+  }
+
+  if( flags & UI_SHOW_CANVOTE )
+  {
+    if( trap_Cvar_VariableValue( "ui_voteActive" ) )
+      vis = qfalse;
+  }
+
+  if( flags & UI_SHOW_TEAMVOTEACTIVE )
+  {
+    if( team == TEAM_ALIENS )
+    {
+      if( !trap_Cvar_VariableValue( "ui_alienTeamVoteActive" ) )
         vis = qfalse;
-
-      flags &= ~UI_SHOW_NOTSPECTATING;
-    }
-
-    if( flags & UI_SHOW_VOTEACTIVE )
-    {
-      if( !trap_Cvar_VariableValue( "ui_voteActive" ) )
+    }
+    else if( team == TEAM_HUMANS )
+    {
+      if( !trap_Cvar_VariableValue( "ui_humanTeamVoteActive" ) )
         vis = qfalse;
-
-      flags &= ~UI_SHOW_VOTEACTIVE;
-    }
-
-    if( flags & UI_SHOW_CANVOTE )
-    {
-      if( trap_Cvar_VariableValue( "ui_voteActive" ) )
+    }
+  }
+
+  if( flags & UI_SHOW_CANTEAMVOTE )
+  {
+    if( team == TEAM_ALIENS )
+    {
+      if( trap_Cvar_VariableValue( "ui_alienTeamVoteActive" ) )
         vis = qfalse;
-
-      flags &= ~UI_SHOW_CANVOTE;
-    }
-
-    if( flags & UI_SHOW_TEAMVOTEACTIVE )
-    {
-      if( team == TEAM_ALIENS )
-      {
-        if( !trap_Cvar_VariableValue( "ui_alienTeamVoteActive" ) )
-          vis = qfalse;
-      }
-      else if( team == TEAM_HUMANS )
-      {
-        if( !trap_Cvar_VariableValue( "ui_humanTeamVoteActive" ) )
-          vis = qfalse;
-      }
-
-      flags &= ~UI_SHOW_TEAMVOTEACTIVE;
-    }
-
-    if( flags & UI_SHOW_CANTEAMVOTE )
-    {
-      if( team == TEAM_ALIENS )
-      {
-        if( trap_Cvar_VariableValue( "ui_alienTeamVoteActive" ) )
-          vis = qfalse;
-      }
-      else if( team == TEAM_HUMANS )
-      {
-        if( trap_Cvar_VariableValue( "ui_humanTeamVoteActive" ) )
-          vis = qfalse;
-      }
-
-      flags &= ~UI_SHOW_CANTEAMVOTE;
-    }
-
-    if( flags & UI_SHOW_FAVORITESERVERS )
-    {
-      // this assumes you only put this type of display flag on something showing in the proper context
-
-      if( ui_netSource.integer != AS_FAVORITES )
+    }
+    else if( team == TEAM_HUMANS )
+    {
+      if( trap_Cvar_VariableValue( "ui_humanTeamVoteActive" ) )
         vis = qfalse;
-
-      flags &= ~UI_SHOW_FAVORITESERVERS;
-    }
-
-    if( flags & UI_SHOW_NOTFAVORITESERVERS )
-    {
-      // this assumes you only put this type of display flag on something showing in the proper context
-
-      if( ui_netSource.integer == AS_FAVORITES )
-        vis = qfalse;
-
-      flags &= ~UI_SHOW_NOTFAVORITESERVERS;
-    }
-    else
-      flags = 0;
+    }
+  }
+
+  if( flags & UI_SHOW_FAVORITESERVERS )
+  {
+    // this assumes you only put this type of display flag on something showing in the proper context
+
+    if( ui_netSource.integer != AS_FAVORITES )
+      vis = qfalse;
+  }
+
+  if( flags & UI_SHOW_NOTFAVORITESERVERS )
+  {
+    // this assumes you only put this type of display flag on something showing in the proper context
+
+    if( ui_netSource.integer == AS_FAVORITES )
+      vis = qfalse;
   }
 
   return vis;
@@ -2924,7 +2918,6 @@
 
 void UI_ScreenChange( char **args )
 {
-  static int saved_index = 0;
   const char *string;
   int i, modifier;
   char buffer[ 8192 ];
@@ -2973,11 +2966,6 @@
       if( Int_Parse( args, &modifier ) )
         current_screen = modifier;
     }
-    // Hack for saving the index when switching from multiview to detail view
-    else if( string[0] == '?' )
-      saved_index = current_screen;
-    else if( string[0] == '!' )
-      current_screen = saved_index;
   }
 
   // We don't want it to go below 0 or above the max number of screens
@@ -3175,9 +3163,7 @@
       char buffer[ MAX_CVAR_VALUE_STRING ];
       trap_Cvar_VariableStringBuffer( "ui_sayBuffer", buffer, sizeof( buffer ) );
 
-      if( !buffer[ 0 ] )
-      {
-      }
+      if( !buffer[ 0 ] ) {}
       else if( uiInfo.chatTargetClientNum != -1 )
         trap_Cmd_ExecuteText( EXEC_APPEND, va( "tell %i \"%s\"\n", uiInfo.chatTargetClientNum, buffer  ) );
       else if( uiInfo.chatTeam )
@@ -3189,10 +3175,7 @@
         char clantagDecolored[ 32 ];
         trap_Cvar_VariableStringBuffer( "cl_clantag", clantagDecolored, sizeof( clantagDecolored ) );
         Q_CleanStr( clantagDecolored );
-        if( strlen(clantagDecolored) > 2 && strlen(clantagDecolored) < 11 )
-          trap_Cmd_ExecuteText( EXEC_APPEND, va( "m \"%s\" \"%s\"\n", clantagDecolored, buffer ) );
-        else
-          Com_Printf( "^3Error: Your clantag has to be between 3 and 10 chars long. Current value is:^7 %s^7\n", clantagDecolored );
+        trap_Cmd_ExecuteText( EXEC_APPEND, va( "m \"%s\" \"%s\"\n", clantagDecolored, buffer ) );
       }
       else if( uiInfo.chatPrompt )
         trap_Cmd_ExecuteText( EXEC_APPEND, va( "vstr \"%s\"\n", uiInfo.chatPromptCallback ) );
@@ -4163,6 +4146,7 @@
   uiInfo.uiDC.ownerDrawItem = &UI_OwnerDraw;
   uiInfo.uiDC.getValue = &UI_GetValue;
   uiInfo.uiDC.ownerDrawVisible = &UI_OwnerDrawVisible;
+  uiInfo.uiDC.hideScreen = &UI_HideScreen;
   uiInfo.uiDC.runScript = &UI_RunMenuScript;
   uiInfo.uiDC.setCVar = trap_Cvar_Set;
   uiInfo.uiDC.getCVarString = trap_Cvar_VariableStringBuffer;
@@ -4645,9 +4629,10 @@
   
         if( prompt & DLP_SHOW )
         {
+          if (!Menus_ActivateByName( "download_popmenu" ))
+            return;
           Com_Printf( "Opening download prompt...\n" );
           trap_Key_SetCatcher( KEYCATCH_UI );
-          Menus_ActivateByName( "download_popmenu" );
           trap_Cvar_Set( "cl_downloadPrompt", "0" );
         }
 
diff -r 11104731f8c9 -r 87f98d895296 src/ui/ui_shared.c
--- a/src/ui/ui_shared.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/ui/ui_shared.c	Sun Mar 29 01:15:08 2009 +0800
@@ -43,6 +43,17 @@
 
 static scrollInfo_t scrollInfo;
 
+#define MAX_DELAYED_COMMANDS 64
+
+typedef struct delayed_cmd_s
+{
+  itemDef_t *item;
+  int time;
+}
+delayed_cmd_t; 
+
+delayed_cmd_t delayed_cmd[ MAX_DELAYED_COMMANDS ]; 
+
 // prevent compiler warnings
 void voidFunction( void *var )
 {
@@ -1176,8 +1187,8 @@
   item->window.rect.h = item->window.rectClient.h;
 
   // force the text rects to recompute
-  item->textRect.w = 0;
-  item->textRect.h = 0;
+  //item->textRect.w = 0;
+  //item->textRect.h = 0;
 }
 
 // FIXME: consolidate this with nearby stuff
@@ -1696,8 +1707,8 @@
     Menus_CloseByName( name );
 }
 
-void Menu_TransitionItemByName( menuDef_t *menu, const char *p, rectDef_t rectFrom, rectDef_t rectTo,
-                                int time, float amt )
+void Menu_TransitionItemByName( menuDef_t *menu, const char *p, rectDef_t rectTo,
+                                int time )
 {
   itemDef_t *item;
   int i;
@@ -1709,15 +1720,21 @@
 
     if( item != NULL )
     {
-      item->window.flags |= ( WINDOW_INTRANSITION | WINDOW_VISIBLE );
-      item->window.offsetTime = time;
-      memcpy( &item->window.rectClient, &rectFrom, sizeof( rectDef_t ) );
-      memcpy( &item->window.rectEffects, &rectTo, sizeof( rectDef_t ) );
-      item->window.rectEffects2.x = abs( rectTo.x - rectFrom.x ) / amt;
-      item->window.rectEffects2.y = abs( rectTo.y - rectFrom.y ) / amt;
-      item->window.rectEffects2.w = abs( rectTo.w - rectFrom.w ) / amt;
-      item->window.rectEffects2.h = abs( rectTo.h - rectFrom.h ) / amt;
-      Item_UpdatePosition( item );
+      if (time)
+      {
+        item->window.flags |= WINDOW_INTRANSITION;
+        memcpy( &item->window.rectEffects, &rectTo, sizeof( rectDef_t ) );
+        item->window.offsetTime = DC->realTime;
+        item->window.rectEffects2.x = abs( rectTo.x - item->window.rectClient.x ) / (float)time;
+        item->window.rectEffects2.y = abs( rectTo.y - item->window.rectClient.y ) / (float)time;
+        item->window.rectEffects2.w = abs( rectTo.w - item->window.rectClient.w ) / (float)time;
+        item->window.rectEffects2.h = abs( rectTo.h - item->window.rectClient.h ) / (float)time;
+      }
+      else
+      {
+        memcpy( &item->window.rectClient, &rectTo, sizeof( rectDef_t ) );
+        Item_UpdatePosition( item );
+      }
     }
   }
 }
@@ -1726,16 +1743,14 @@
 void Script_Transition( itemDef_t *item, char **args )
 {
   const char *name;
-  rectDef_t rectFrom, rectTo;
+  rectDef_t rectTo;
   int time;
-  float amt;
-
-  if( String_Parse( args, &name ) )
-  {
-    if( Rect_Parse( args, &rectFrom ) && Rect_Parse( args, &rectTo ) &&
-        Int_Parse( args, &time ) && Float_Parse( args, &amt ) )
-    {
-      Menu_TransitionItemByName( item->parent, name, rectFrom, rectTo, time, amt );
+
+  if( String_Parse( args, &name ) )
+  {
+    if( Rect_Parse( args, &rectTo ) && Int_Parse( args, &time ) )
+    {
+      Menu_TransitionItemByName( item->parent, name, rectTo, time );
     }
   }
 }
@@ -1788,13 +1803,13 @@
   const char *name;
   itemDef_t *focusItem;
 
+  Menu_ClearFocus( item->parent );
   if( String_Parse( args, &name ) )
   {
     focusItem = Menu_FindItemByName( item->parent, name );
 
     if( focusItem && !( focusItem->window.flags & WINDOW_DECORATION ) )
     {
-      Menu_ClearFocus( item->parent );
       focusItem->window.flags |= WINDOW_HASFOCUS;
 
       if( focusItem->onFocus )
@@ -1887,6 +1902,43 @@
   }
 }
 
+void Menu_DelayItemByName( menuDef_t *menu, const char *p, int time )
+{
+  itemDef_t *item;
+  int i, j = 0;
+  int count = Menu_ItemsMatchingGroup( menu, p );
+
+  for( i = 0; i < count; i++ )
+  {
+    item = Menu_GetMatchingItemByNumber( menu, i, p );
+
+    if( item != NULL && item->delayEvent && item->delayEvent[ 0 ] )
+    {
+      for( ; j < MAX_DELAYED_COMMANDS; j++ )
+      {
+        if( !delayed_cmd[ j ].time )
+        {
+          delayed_cmd[ j ].item = item;
+          delayed_cmd[ j ].time = DC->realTime + time;
+          j++;
+          break;
+        }
+      }
+    }
+  }
+}
+
+void Script_Delay( itemDef_t *item, char **args )
+{
+  const char *name;
+  int time;
+
+  if( Int_Parse( args, &time ) && String_Parse( args, &name ) )
+  {
+    Menu_DelayItemByName( item->parent, name, time );
+  }
+}
+
 static qboolean UI_Text_Emoticon( const char *s, qboolean *escaped,
                                   int *length, qhandle_t *h, int *width )
 {
@@ -2544,11 +2596,12 @@
     {"setplayermodel", &Script_SetPlayerModel},   // sets this background color to team color
     {"setplayerhead", &Script_SetPlayerHead},     // sets this background color to team color
     {"transition", &Script_Transition},           // group/name
-    {"setcvar", &Script_SetCvar},           // group/name
-    {"exec", &Script_Exec},           // group/name
-    {"play", &Script_Play},           // group/name
+    {"setcvar", &Script_SetCvar},                 // group/name
+    {"exec", &Script_Exec},                       // group/name
+    {"play", &Script_Play},                       // group/name
     {"playlooped", &Script_playLooped},           // group/name
-    {"orbit", &Script_Orbit},                      // group/name
+    {"orbit", &Script_Orbit},                     // group/name
+    {"delay", &Script_Delay},                     // group/name
   };
 
 int scriptCommandCount = sizeof( commandList ) / sizeof( commandDef_t );
@@ -3650,6 +3703,43 @@
 
         DC->setCVar( item->cvar, buff );
       }
+      else if( key == 'c' - 'a' + 1 )
+      {
+        // ctrl-c clears the field
+
+        item->cursorPos = 0;
+        DC->setCVar( item->cvar, "" );
+      }
+      else if( key == 'a' - 'a' + 1 )
+      {
+        // ctrl-a is home
+
+        item->cursorPos = 0;
+      }
+      else if( key == 'e' - 'a' + 1 )
+      {
+        // ctrl-e is end
+
+        item->cursorPos = strlen( buff ) - 1;
+      }
+      else if( key == 'w' - 'a' + 1 )
+      {
+        // ctrl-w deletes the last word
+
+        while ( item->cursorPos )
+        {
+          if ( buff[ item->cursorPos - 1 ] != ' ' ) {
+            buff[ item->cursorPos - 1 ] = 0;
+            item->cursorPos--;
+          } else {
+            item->cursorPos--;
+            if ( buff[ item->cursorPos - 1 ] != ' ' )
+              break;
+          }
+        }
+
+        DC->setCVar( item->cvar, buff );
+      }
       else if( ( key < 32 && key >= 0 ) || !item->cvar )
       {
         // Ignore any non printable chars
@@ -4305,7 +4395,6 @@
 {
   int i;
   itemDef_t *item = NULL;
-  qboolean inHandler = qfalse;
 
   // KTW: Draggable Windows
   if (key == K_MOUSE1 && down && Rect_ContainsPoint(&menu->window.rect, DC->cursorx, DC->cursory) &&
@@ -4314,12 +4403,9 @@
   else
       menu->window.flags &= ~WINDOW_DRAG;
 
-  inHandler = qtrue;
-
   if( g_waitingForKey && down )
   {
     Item_Bind_HandleKey( g_bindItem, key, down );
-    inHandler = qfalse;
     return;
   }
 
@@ -4330,7 +4416,6 @@
       g_editingField = qfalse;
       Item_RunScript( g_editItem, g_editItem->onTextEntry );
       g_editItem = NULL;
-      inHandler = qfalse;
       return;
     }
     else if( key == K_MOUSE1 || key == K_MOUSE2 || key == K_MOUSE3 )
@@ -4345,10 +4430,7 @@
   }
 
   if( menu == NULL )
-  {
-    inHandler = qfalse;
-    return;
-  }
+    return;
 
   // see if the mouse is within the window bounds and if so is this a mouse click
   if( down && !( menu->window.flags & WINDOW_POPUP ) &&
@@ -4361,7 +4443,6 @@
       inHandleKey = qtrue;
       Menus_HandleOOBClick( menu, key, down );
       inHandleKey = qfalse;
-      inHandler = qfalse;
       return;
     }
   }
@@ -4378,16 +4459,12 @@
     if( Item_HandleKey( item, key, down ) )
     {
       Item_Action( item );
-      inHandler = qfalse;
       return;
     }
   }
 
   if( !down )
-  {
-    inHandler = qfalse;
-    return;
-  }
+    return;
 
   // default handling
   switch( key )
@@ -4500,8 +4577,6 @@
 
       break;
   }
-
-  inHandler = qfalse;
 }
 
 void ToWindowCoords( float *x, float *y, windowDef_t *window )
@@ -4531,15 +4606,15 @@
   *width = item->textRect.w;
   *height = item->textRect.h;
 
+  // as long as the item isn't dynamic content (ownerdraw or cvar), this
   // keeps us from computing the widths and heights more than once
-
-  if( *width == 0 || ( item->type == ITEM_TYPE_OWNERDRAW && item->textalignment == ALIGN_CENTER ) )
+  if( *width == 0 || item->cvar || ( item->type == ITEM_TYPE_OWNERDRAW &&
+      item->textalignment != ALIGN_LEFT ) || ( ((menuDef_t*)item->parent)->window.flags & WINDOW_DRAG ) )
   {
     int originalWidth;
 
-    if( item->type == ITEM_TYPE_EDITFIELD && item->textalignment == ALIGN_CENTER && item->cvar )
-    {
-      //FIXME: this will only be called once?
+    if( item->cvar && item->textalignment != ALIGN_LEFT )
+    {
       char buff[256];
       DC->getCVarString( item->cvar, buff, 256 );
       originalWidth = UI_Text_Width( item->text, item->textscale, 0 ) +
@@ -4789,9 +4864,9 @@
   Q_strncpyz( cacheEntry->lines[ cacheEntry->numLines ], text,
               sizeof( cacheEntry->lines[ 0 ] ) );
 
-  cacheEntry->lineCoords[ cacheEntry->numLines ][ 0 ] = x;
-
-  cacheEntry->lineCoords[ cacheEntry->numLines ][ 1 ] = y;
+  cacheEntry->lineCoords[ cacheEntry->numLines ][ 0 ] = x - cacheEntry->rect.x;
+
+  cacheEntry->lineCoords[ cacheEntry->numLines ][ 1 ] = y - cacheEntry->rect.y;
 
   cacheEntry->numLines++;
 }
@@ -4812,9 +4887,7 @@
     if( Q_stricmp( text, cacheEntry->text ) )
       continue;
 
-    if( rect->x != cacheEntry->rect.x ||
-        rect->y != cacheEntry->rect.y ||
-        rect->w != cacheEntry->rect.w ||
+    if( rect->w != cacheEntry->rect.w ||
         rect->h != cacheEntry->rect.h )
       continue;
 
@@ -4822,6 +4895,9 @@
       continue;
 
     // This is a match
+    cacheEntry->rect.x = rect->x;
+    cacheEntry->rect.y = rect->y;
+
     cacheReadIndex = i;
 
     cacheReadLineNum = 0;
@@ -4842,9 +4918,9 @@
 
   *text = cacheEntry->lines[ cacheReadLineNum ];
 
-  *x    = cacheEntry->lineCoords[ cacheReadLineNum ][ 0 ];
-
-  *y    = cacheEntry->lineCoords[ cacheReadLineNum ][ 1 ];
+  *x    = cacheEntry->lineCoords[ cacheReadLineNum ][ 0 ] + cacheEntry->rect.x;
+
+  *y    = cacheEntry->lineCoords[ cacheReadLineNum ][ 1 ] + cacheEntry->rect.y;
 
   cacheReadLineNum++;
 
@@ -4955,6 +5031,7 @@
         itemDef_t   lineItem;
         int         width, height;
 
+        memset( &lineItem, 0, sizeof( itemDef_t ) );
         strncpy( buff, p, lineLength );
         buff[ lineLength ] = '\0';
         p = &textPtr[ i + 1 ];
@@ -6176,6 +6253,7 @@
 
 void Item_Paint( itemDef_t *item )
 {
+  int i;
   vec4_t red;
   menuDef_t *parent = ( menuDef_t* )item->parent;
   red[0] = red[3] = 1;
@@ -6184,6 +6262,16 @@
   if( item == NULL )
     return;
 
+  // check for delays
+  for( i = 0; i < MAX_DELAYED_COMMANDS; i++ )
+  {
+    if( delayed_cmd[ i ].item == item && delayed_cmd[ i ].time && delayed_cmd[ i ].time < DC->realTime )
+    {
+      Item_RunScript( item, item->delayEvent );
+      delayed_cmd[ i ].time = 0;
+    }
+  }
+
   if( item->window.flags & WINDOW_ORBITING )
   {
     if( DC->realTime > item->window.nextTime )
@@ -6209,122 +6297,119 @@
 
   if( item->window.flags & WINDOW_INTRANSITION )
   {
-    if( DC->realTime > item->window.nextTime )
-    {
-      int done = 0;
-      item->window.nextTime = DC->realTime + item->window.offsetTime;
-      // transition the x,y
-
-      if( item->window.rectClient.x == item->window.rectEffects.x )
-        done++;
-      else
-      {
+    int done = 0;
+    int timePast = DC->realTime - item->window.offsetTime;
+    item->window.offsetTime = DC->realTime;
+    // transition the x,y
+
+    if( item->window.rectClient.x == item->window.rectEffects.x )
+      done++;
+    else
+    {
+      if( item->window.rectClient.x < item->window.rectEffects.x )
+      {
+        item->window.rectClient.x += item->window.rectEffects2.x * timePast;
+
+        if( item->window.rectClient.x > item->window.rectEffects.x )
+        {
+          item->window.rectClient.x = item->window.rectEffects.x;
+          done++;
+        }
+      }
+      else
+      {
+        item->window.rectClient.x -= item->window.rectEffects2.x * timePast;
+
         if( item->window.rectClient.x < item->window.rectEffects.x )
         {
-          item->window.rectClient.x += item->window.rectEffects2.x;
-
-          if( item->window.rectClient.x > item->window.rectEffects.x )
-          {
-            item->window.rectClient.x = item->window.rectEffects.x;
-            done++;
-          }
-        }
-        else
-        {
-          item->window.rectClient.x -= item->window.rectEffects2.x;
-
-          if( item->window.rectClient.x < item->window.rectEffects.x )
-          {
-            item->window.rectClient.x = item->window.rectEffects.x;
-            done++;
-          }
-        }
-      }
-
-      if( item->window.rectClient.y == item->window.rectEffects.y )
-        done++;
-      else
-      {
+          item->window.rectClient.x = item->window.rectEffects.x;
+          done++;
+        }
+      }
+    }
+
+    if( item->window.rectClient.y == item->window.rectEffects.y )
+      done++;
+    else
+    {
+      if( item->window.rectClient.y < item->window.rectEffects.y )
+      {
+        item->window.rectClient.y += item->window.rectEffects2.y * timePast;
+
+        if( item->window.rectClient.y > item->window.rectEffects.y )
+        {
+          item->window.rectClient.y = item->window.rectEffects.y;
+          done++;
+        }
+      }
+      else
+      {
+        item->window.rectClient.y -= item->window.rectEffects2.y * timePast;
+
         if( item->window.rectClient.y < item->window.rectEffects.y )
         {
-          item->window.rectClient.y += item->window.rectEffects2.y;
-
-          if( item->window.rectClient.y > item->window.rectEffects.y )
-          {
-            item->window.rectClient.y = item->window.rectEffects.y;
-            done++;
-          }
-        }
-        else
-        {
-          item->window.rectClient.y -= item->window.rectEffects2.y;
-
-          if( item->window.rectClient.y < item->window.rectEffects.y )
-          {
-            item->window.rectClient.y = item->window.rectEffects.y;
-            done++;
-          }
-        }
-      }
-
-      if( item->window.rectClient.w == item->window.rectEffects.w )
-        done++;
-      else
-      {
+          item->window.rectClient.y = item->window.rectEffects.y;
+          done++;
+        }
+      }
+    }
+
+    if( item->window.rectClient.w == item->window.rectEffects.w )
+      done++;
+    else
+    {
+      if( item->window.rectClient.w < item->window.rectEffects.w )
+      {
+        item->window.rectClient.w += item->window.rectEffects2.w * timePast;
+
+        if( item->window.rectClient.w > item->window.rectEffects.w )
+        {
+          item->window.rectClient.w = item->window.rectEffects.w;
+          done++;
+        }
+      }
+      else
+      {
+        item->window.rectClient.w -= item->window.rectEffects2.w * timePast;
+
         if( item->window.rectClient.w < item->window.rectEffects.w )
         {
-          item->window.rectClient.w += item->window.rectEffects2.w;
-
-          if( item->window.rectClient.w > item->window.rectEffects.w )
-          {
-            item->window.rectClient.w = item->window.rectEffects.w;
-            done++;
-          }
-        }
-        else
-        {
-          item->window.rectClient.w -= item->window.rectEffects2.w;
-
-          if( item->window.rectClient.w < item->window.rectEffects.w )
-          {
-            item->window.rectClient.w = item->window.rectEffects.w;
-            done++;
-          }
-        }
-      }
-
-      if( item->window.rectClient.h == item->window.rectEffects.h )
-        done++;
-      else
-      {
+          item->window.rectClient.w = item->window.rectEffects.w;
+          done++;
+        }
+      }
+    }
+
+    if( item->window.rectClient.h == item->window.rectEffects.h )
+      done++;
+    else
+    {
+      if( item->window.rectClient.h < item->window.rectEffects.h )
+      {
+        item->window.rectClient.h += item->window.rectEffects2.h * timePast;
+
+        if( item->window.rectClient.h > item->window.rectEffects.h )
+        {
+          item->window.rectClient.h = item->window.rectEffects.h;
+          done++;
+        }
+      }
+      else
+      {
+        item->window.rectClient.h -= item->window.rectEffects2.h * timePast;
+
         if( item->window.rectClient.h < item->window.rectEffects.h )
         {
-          item->window.rectClient.h += item->window.rectEffects2.h;
-
-          if( item->window.rectClient.h > item->window.rectEffects.h )
-          {
-            item->window.rectClient.h = item->window.rectEffects.h;
-            done++;
-          }
-        }
-        else
-        {
-          item->window.rectClient.h -= item->window.rectEffects2.h;
-
-          if( item->window.rectClient.h < item->window.rectEffects.h )
-          {
-            item->window.rectClient.h = item->window.rectEffects.h;
-            done++;
-          }
-        }
-      }
-
-      Item_UpdatePosition( item );
-
-      if( done == 4 )
-        item->window.flags &= ~WINDOW_INTRANSITION;
-
-    }
+          item->window.rectClient.h = item->window.rectEffects.h;
+          done++;
+        }
+      }
+    }
+
+    Item_UpdatePosition( item );
+
+    if( done == 4 )
+      item->window.flags &= ~WINDOW_INTRANSITION;
   }
 
   if( item->window.ownerDrawFlags && DC->ownerDrawVisible )
@@ -6335,6 +6420,12 @@
       item->window.flags |= WINDOW_VISIBLE;
   }
 
+  if( item->window.ownerDraw == UI_SCREEN && DC->hideScreen )
+  {
+    if( DC->hideScreen( item->special ) )
+      item->window.flags &= ~WINDOW_VISIBLE;
+  }
+
   if( item->cvarFlags & ( CVAR_SHOW | CVAR_HIDE ) )
   {
     if( !Item_EnableShowViaCvar( item, CVAR_SHOW ) )
@@ -6626,8 +6717,6 @@
           !Item_EnableShowViaCvar( menu->items[i], CVAR_SHOW ) )
         continue;
 
-
-
       if( Rect_ContainsPoint( &menu->items[i]->window.rect, x, y ) )
       {
         if( pass == 1 )
@@ -7431,6 +7520,14 @@
   return qtrue;
 }
 
+qboolean ItemParse_delayEvent( itemDef_t *item, int handle )
+{
+  if( !PC_Script_Parse( handle, &item->delayEvent ) )
+    return qfalse;
+
+  return qtrue;
+}
+
 qboolean ItemParse_action( itemDef_t *item, int handle )
 {
   if( !PC_Script_Parse( handle, &item->action ) )
@@ -7794,6 +7891,7 @@
   {"mouseEnterText", ItemParse_mouseEnterText, NULL},
   {"mouseExitText", ItemParse_mouseExitText, NULL},
   {"onTextEntry", ItemParse_onTextEntry, NULL},
+  {"delayEvent", ItemParse_delayEvent, NULL},
   {"action", ItemParse_action, NULL},
   {"special", ItemParse_special, NULL},
   {"cvar", ItemParse_cvar, NULL},
diff -r 11104731f8c9 -r 87f98d895296 src/ui/ui_shared.h
--- a/src/ui/ui_shared.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/ui/ui_shared.h	Sun Mar 29 01:15:08 2009 +0800
@@ -37,7 +37,7 @@
 #define MAX_MENUDEFFILE 4096
 #define MAX_MENUFILE 32768
 #define MAX_MENUS 256
-#define MAX_MENUITEMS 128
+#define MAX_MENUITEMS 512
 #define MAX_COLOR_RANGES 10
 #define MAX_OPEN_MENUS 16
 
@@ -289,10 +289,11 @@
   const char *onFocus;           // select script
   const char *leaveFocus;        // select script
   const char *onTextEntry;       // called when text entered
+  const char *delayEvent;        // delay event script
   const char *cvar;              // associated cvar
   const char *cvarTest;          // associated cvar for enable actions
-  const char *enableCvar;         // enable, disable, show, or hide based on value, this can contain a list
-  int cvarFlags;                 //  what type of action to take on cvarenables
+  const char *enableCvar;        // enable, disable, show, or hide based on value, this can contain a list
+  int cvarFlags;                 // what type of action to take on cvarenables
   sfxHandle_t focusSound;
   int numColors;                 // number of color ranges
   colorRangeDef_t colorRanges[MAX_COLOR_RANGES];
@@ -400,6 +401,7 @@
                             vec4_t backColor, qhandle_t shader, int textStyle );
   float ( *getValue ) ( int ownerDraw );
   qboolean ( *ownerDrawVisible ) ( int flags );
+  qboolean ( *hideScreen ) ( int modifier );
   void ( *runScript )( char **p );
   void ( *getCVarString )( const char *cvar, char *buffer, int bufsize );
   float ( *getCVarValue )( const char *cvar );
diff -r 11104731f8c9 -r 87f98d895296 src/ui/ui_syscalls.c
--- a/src/ui/ui_syscalls.c	Thu Feb 19 05:06:14 2009 +0800
+++ b/src/ui/ui_syscalls.c	Sun Mar 29 01:15:08 2009 +0800
@@ -24,7 +24,7 @@
 #include "ui_local.h"
 
 // this file is only included when building a dll
-// syscalls.asm is included instead when building a qvm
+// ui_syscalls.asm is included instead when building a qvm
 
 static intptr_t ( QDECL *syscall )( intptr_t arg, ... ) = ( intptr_t ( QDECL * )( intptr_t, ... ) ) - 1;
 
diff -r 11104731f8c9 -r 87f98d895296 ui/help.txt
--- a/ui/help.txt	Thu Feb 19 05:06:14 2009 +0800
+++ b/ui/help.txt	Sun Mar 29 01:15:08 2009 +0800
@@ -68,9 +68,11 @@
   }
   "Marauder"
   {
-    "The Adv. Marauder now has a simpler, area-effect electric shock attack "
-    "that does not need to be aimed. Use this to attack large groups of Humans "
-    "or Human bases.\n\n"
+    "The Adv. Marauder's electric shock damage is no longer split between its "
+    "targets, making it more effective against large groups of humans and "
+    "buildables. Targets are now chosen slightly differently: instead of "
+    "each new chain section originating from the previous target, it will "
+    "originate from the first target."
   }
   "Mark Deconstruction"
   {
@@ -92,8 +94,7 @@
   }
   "Dretch"
   {
-    "The dretch bounding box and model have both slightly changed to line up "
-    "more closely.\nDretches can now damage any human structure while it "
+    "Dretches are slightly faster and can now damage any human structure while it "
     "is still building, but can no longer damage turrets and teslas that "
     "have been completed."
   }
diff -r 11104731f8c9 -r 87f98d895296 ui/menudef.h
--- a/ui/menudef.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/ui/menudef.h	Sun Mar 29 01:15:08 2009 +0800
@@ -105,26 +105,27 @@
 #define CG_PLAYER_BUILD_TIMER             6
 #define CG_PLAYER_CREDITS_VALUE           7
 #define CG_PLAYER_CREDITS_VALUE_NOPAD     9
-#define CG_PLAYER_STAMINA                 11
-#define CG_PLAYER_STAMINA_1               12
-#define CG_PLAYER_STAMINA_2               13
-#define CG_PLAYER_STAMINA_3               14
-#define CG_PLAYER_STAMINA_4               15
-#define CG_PLAYER_STAMINA_BOLT            16
-#define CG_PLAYER_BOOST_BOLT              17
-#define CG_PLAYER_CLIPS_RING              18
-#define CG_PLAYER_BUILD_TIMER_RING        19
-#define CG_PLAYER_SELECT                  20
-#define CG_PLAYER_SELECTTEXT              21
-#define CG_PLAYER_WEAPONICON              22
-#define CG_PLAYER_WALLCLIMBING            23
-#define CG_PLAYER_BOOSTED                 24
-#define CG_PLAYER_POISON_BARBS            25
-#define CG_PLAYER_ALIEN_SENSE             26
-#define CG_PLAYER_HUMAN_SCANNER           27
-#define CG_PLAYER_USABLE_BUILDABLE        28
-#define CG_KILLER                         29
-#define CG_SPECTATORS                     30
+#define CG_PLAYER_STAMINA                 10
+#define CG_PLAYER_STAMINA_1               11
+#define CG_PLAYER_STAMINA_2               12
+#define CG_PLAYER_STAMINA_3               13
+#define CG_PLAYER_STAMINA_4               14
+#define CG_PLAYER_STAMINA_BOLT            15
+#define CG_PLAYER_BOOST_BOLT              16
+#define CG_PLAYER_CLIPS_RING              17
+#define CG_PLAYER_BUILD_TIMER_RING        18
+#define CG_PLAYER_SELECT                  19
+#define CG_PLAYER_SELECTTEXT              20
+#define CG_PLAYER_WEAPONICON              21
+#define CG_PLAYER_WALLCLIMBING            22
+#define CG_PLAYER_BOOSTED                 23
+#define CG_PLAYER_POISON_BARBS            24
+#define CG_PLAYER_ALIEN_SENSE             25
+#define CG_PLAYER_HUMAN_SCANNER           26
+#define CG_PLAYER_USABLE_BUILDABLE        27
+#define CG_KILLER                         28
+#define CG_SPECTATORS                     29
+#define CG_FOLLOW                         30
 
 // loading screen
 #define CG_LOAD_LEVELSHOT                 31
@@ -190,4 +191,6 @@
 #define UI_CREDITS                        83
 #define UI_SCREEN                         84
 
+#define CG_PLAYER_SCORE                   85
+
 #endif
diff -r 11104731f8c9 -r 87f98d895296 ui/teamscore.menu
--- a/ui/teamscore.menu	Thu Feb 19 05:06:14 2009 +0800
+++ b/ui/teamscore.menu	Sun Mar 29 01:15:08 2009 +0800
@@ -356,5 +356,19 @@
       ownerdraw CG_SPECTATORS
       decoration
     }
+
+    itemDef
+    {
+      name winner
+      rect (W/2) (H+BAR_H) 0 0
+      style WINDOW_STYLE_EMPTY
+      forecolor 1 1 1 1
+      textscale 0.5
+      textalign ALIGN_CENTER
+      textvalign VALIGN_TOP
+      visible MENU_TRUE
+      cvar "ui_winner"
+      decoration
+    }
   }
 }
diff -r 11104731f8c9 -r 87f98d895296 ui/tremulous_alien_common_hud.h
--- a/ui/tremulous_alien_common_hud.h	Thu Feb 19 05:06:14 2009 +0800
+++ b/ui/tremulous_alien_common_hud.h	Sun Mar 29 01:15:08 2009 +0800
@@ -242,3 +242,18 @@
   background "ui/assets/neutral/charge_bg_h.tga"
 }
 
+//SPECTATOR TEXT
+itemDef
+{
+  name "followtext"
+  rect 200 375 240 25
+  foreColor 1 1 1 1
+  aspectBias ALIGN_CENTER
+  textalign ALIGN_CENTER
+  textvalign VALIGN_TOP
+  visible MENU_TRUE
+  decoration
+  textScale .7
+  textStyle ITEM_TEXTSTYLE_SHADOWED
+  ownerdraw CG_FOLLOW
+}
diff -r 11104731f8c9 -r 87f98d895296 ui/tremulous_default_hud.menu
--- a/ui/tremulous_default_hud.menu	Thu Feb 19 05:06:14 2009 +0800
+++ b/ui/tremulous_default_hud.menu	Sun Mar 29 01:15:08 2009 +0800
@@ -17,5 +17,21 @@
 #define COMMON_HUD_G 1.0
 #define COMMON_HUD_B 1.0
 #include "ui/tremulous_common_hud.h"
+
+    //SPECTATOR TEXT
+    itemDef
+    {
+      name "spectatortext"
+      text "SPECTATOR"
+      rect 200 415 240 25
+      foreColor 1 1 1 1
+      aspectBias ALIGN_CENTER
+      textalign ALIGN_CENTER
+      textvalign VALIGN_TOP
+      visible MENU_TRUE
+      decoration
+      textScale .7
+      textStyle ITEM_TEXTSTYLE_SHADOWED
+    }
   }
 }
diff -r 11104731f8c9 -r 87f98d895296 ui/tremulous_human_hud.menu
--- a/ui/tremulous_human_hud.menu	Thu Feb 19 05:06:14 2009 +0800
+++ b/ui/tremulous_human_hud.menu	Sun Mar 29 01:15:08 2009 +0800
@@ -386,5 +386,21 @@
       style WINDOW_STYLE_SHADER
       background "ui/assets/neutral/selected.tga"
     }
+
+    //SPECTATOR TEXT
+    itemDef
+    {
+      name "followtext"
+      rect 200 375 240 25
+      foreColor 1 1 1 1
+      aspectBias ALIGN_CENTER
+      textalign ALIGN_CENTER
+      textvalign VALIGN_TOP
+      visible MENU_TRUE
+      decoration
+      textScale .7
+      textStyle ITEM_TEXTSTYLE_SHADOWED
+      ownerdraw CG_FOLLOW
+    }
   }
 }
